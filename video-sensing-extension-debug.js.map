{"version":3,"file":"video-sensing-extension-debug.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AAEA;;;;;;;;;;;ACLA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;AChCA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;AF5fA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AGZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AC1BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;ACPA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AEhDA;AACA;AACA;AACA;AACA","sources":["webpack://scratch-vm/webpack/universalModuleDefinition","webpack://scratch-vm/./src/extensions/scratch3_video_sensing/debug.js","webpack://scratch-vm/./node_modules/expose-loader/dist/runtime/getGlobalThis.js","webpack://scratch-vm/./src/extensions/scratch3_video_sensing/view.js","webpack://scratch-vm/webpack/bootstrap","webpack://scratch-vm/webpack/runtime/chunk loaded","webpack://scratch-vm/webpack/runtime/global","webpack://scratch-vm/webpack/runtime/hasOwnProperty shorthand","webpack://scratch-vm/webpack/runtime/jsonp chunk loading","webpack://scratch-vm/webpack/before-startup","webpack://scratch-vm/webpack/startup","webpack://scratch-vm/webpack/after-startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"scratch-vm\"] = factory();\n\telse\n\t\troot[\"scratch-vm\"] = factory();\n})(self, () => {\nreturn ","var ___EXPOSE_LOADER_IMPORT___ = require(\"-!./debug.js\");\nvar ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = require(\"../../../node_modules/expose-loader/dist/runtime/getGlobalThis.js\");\nvar ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;\nif (typeof ___EXPOSE_LOADER_GLOBAL_THIS___[\"Scratch3VideoSensingDebug\"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___[\"Scratch3VideoSensingDebug\"] = ___EXPOSE_LOADER_IMPORT___;\nelse throw new Error('[exposes-loader] The \"Scratch3VideoSensingDebug\" value exists in the global scope, it may not be safe to overwrite it, use the \"override\" option')\nmodule.exports = ___EXPOSE_LOADER_IMPORT___;\n","\"use strict\";\n\n// eslint-disable-next-line func-names\nmodule.exports = function () {\n  if (typeof globalThis === \"object\") {\n    return globalThis;\n  }\n\n  var g;\n\n  try {\n    // This works if eval is allowed (see CSP)\n    // eslint-disable-next-line no-new-func\n    g = this || new Function(\"return this\")();\n  } catch (e) {\n    // This works if the window reference is available\n    if (typeof window === \"object\") {\n      return window;\n    } // This works if the self reference is available\n\n\n    if (typeof self === \"object\") {\n      return self;\n    } // This works if the global reference is available\n\n\n    if (typeof global !== \"undefined\") {\n      return global;\n    }\n  }\n\n  return g;\n}();","const {motionVector} = require('./math');\n\nconst WIDTH = 480;\nconst HEIGHT = 360;\nconst WINSIZE = 8;\nconst AMOUNT_SCALE = 100;\nconst THRESHOLD = 10;\n\n/**\n * Modes of debug output that can be rendered.\n * @type {object}\n */\nconst OUTPUT = {\n    /**\n     * Render the original input.\n     * @type {number}\n     */\n    INPUT: -1,\n\n    /**\n     * Render the difference of neighboring pixels for each pixel. The\n     * horizontal difference, or x value, renders in the red output component.\n     * The vertical difference, or y value, renders in the green output\n     * component. Pixels with equal neighbors with a kind of lime green or\n     * #008080 in a RGB hex value. Colors with more red have a lower value to\n     * the right than the value to the left. Colors with less red have a higher\n     * value to the right than the value to the left. Similarly colors with\n     * more green have lower values below than above and colors with less green\n     * have higher values below than above.\n     * @type {number}\n     */\n    XY: 0,\n\n    /**\n     * Render the XY output with groups of pixels averaged together. The group\n     * shape and size matches the full frame's analysis window size.\n     * @type {number}\n     */\n    XY_CELL: 1,\n\n    /**\n     * Render three color components matching the detection algorith's values\n     * that multiple the horizontal difference, or x value, and the vertical\n     * difference, or y value together. The red component is the x value\n     * squared. The green component is the y value squared. The blue component\n     * is the x value times the y value. The detection code refers to these\n     * values as A2, B1, and A1B2.\n     * @type {number}\n     */\n    AB: 2,\n\n    /**\n     * Render the AB output of groups of pixels summarized by their combined\n     * square root. The group shape and size matches the full frame's analysis\n     * window size.\n     * @type {number}\n     */\n    AB_CELL: 3,\n\n    /**\n     * Render a single color component matching the temporal difference or the\n     * difference in color for the same pixel coordinate in the current frame\n     * and the last frame. The difference is rendered in the blue color\n     * component since x and y axis differences tend to use red and green.\n     * @type {number}\n     */\n    T: 4,\n\n    /**\n     * Render the T output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    T_CELL: 5,\n\n    /**\n     * Render the XY and T outputs together. The x and y axis values use the\n     * red and green color components as they do in the XY output. The t values\n     * use the blue color component as the T output does.\n     * @type {number}\n     */\n    XYT: 6,\n\n    /**\n     * Render the XYT output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    XYT_CELL: 7,\n\n    /**\n     * Render the horizontal pixel difference times the temporal difference as\n     * red and the vertical and temporal difference as green. Multiplcation of\n     * these values ends up with sharp differences in the output showing edge\n     * details where motion is happening.\n     * @type {number}\n     */\n    C: 8,\n\n    /**\n     * Render the C output of groups of pixels averaged. The group shape and\n     * size matches the full frame's analysis window.\n     * @type {number}\n     */\n    C_CELL: 9,\n\n    /**\n     * Render a per pixel version of UV_CELL. UV_CELL is a close to final step\n     * of the motion code that builds a motion amount and direction from those\n     * values. UV_CELL renders grouped summarized values, UV does the per pixel\n     * version but its can only represent one motion vector code path out of\n     * two choices. Determining the motion vector compares some of the built\n     * values but building the values with one pixel ensures this first\n     * comparison says the values are equal. Even though only one code path is\n     * used to build the values, its output is close to approximating the\n     * better solution building vectors from groups of pixels to help\n     * illustrate when the code determines the motion amount and direction to\n     * be.\n     * @type {number}\n     */\n    UV: 10,\n\n    /**\n     * Render cells of mulitple pixels at a step in the motion code that has\n     * the same cell values and turns them into motion vectors showing the\n     * amount of motion in the x axis and y axis separately. Those values are a\n     * step away from becoming a motion amount and direction through standard\n     * vector to magnitude and angle values.\n     * @type {number}\n     */\n    UV_CELL: 11\n};\n\n/**\n * Temporary storage structure for returning values in\n * VideoMotionView._components.\n * @type {object}\n */\nconst _videoMotionViewComponentsTmp = {\n    A2: 0,\n    A1B2: 0,\n    B1: 0,\n    C2: 0,\n    C1: 0\n};\n\n/**\n * Manage a debug canvas with VideoMotion input frames running parts of what\n * VideoMotion does to visualize what it does.\n * @param {VideoMotion} motion - VideoMotion with inputs to visualize\n * @param {OUTPUT} output - visualization output mode\n * @constructor\n */\nclass VideoMotionView {\n    constructor (motion, output = OUTPUT.XYT) {\n        /**\n         * VideoMotion instance to visualize.\n         * @type {VideoMotion}\n         */\n        this.motion = motion;\n\n        /**\n         * Debug canvas to render to.\n         * @type {HTMLCanvasElement}\n         */\n        const canvas = this.canvas = document.createElement('canvas');\n        canvas.width = WIDTH;\n        canvas.height = HEIGHT;\n\n        /**\n         * 2D context to draw to debug canvas.\n         * @type {CanvasRendering2DContext}\n         */\n        this.context = canvas.getContext('2d');\n\n        /**\n         * Visualization output mode.\n         * @type {OUTPUT}\n         */\n        this.output = output;\n\n        /**\n         * Pixel buffer to store output values into before they replace the last frames info in the debug canvas.\n         * @type {Uint32Array}\n         */\n        this.buffer = new Uint32Array(WIDTH * HEIGHT);\n    }\n\n    /**\n     * Modes of debug output that can be rendered.\n     * @type {object}\n     */\n    static get OUTPUT () {\n        return OUTPUT;\n    }\n\n    /**\n     * Iterate each pixel address location and call a function with that address.\n     * @param {number} xStart - start location on the x axis of the output pixel buffer\n     * @param {number} yStart - start location on the y axis of the output pixel buffer\n     * @param {nubmer} xStop - location to stop at on the x axis\n     * @param {number} yStop - location to stop at on the y axis\n     * @param {function} fn - handle to call with each iterated address\n     */\n    _eachAddress (xStart, yStart, xStop, yStop, fn) {\n        for (let i = yStart; i < yStop; i++) {\n            for (let j = xStart; j < xStop; j++) {\n                const address = (i * WIDTH) + j;\n                fn(address, j, i);\n            }\n        }\n    }\n\n    /**\n     * Iterate over cells of pixels and call a function with a function to\n     * iterate over pixel addresses.\n     * @param {number} xStart - start location on the x axis\n     * @param {number} yStart - start lcoation on the y axis\n     * @param {number} xStop - location to stop at on the x axis\n     * @param {number} yStop - location to stop at on the y axis\n     * @param {number} xStep - width of the cells\n     * @param {number} yStep - height of the cells\n     * @param {function} fn - function to call with a bound handle to _eachAddress\n     */\n    _eachCell (xStart, yStart, xStop, yStop, xStep, yStep, fn) {\n        const xStep2 = (xStep / 2) | 0;\n        const yStep2 = (yStep / 2) | 0;\n        for (let i = yStart; i < yStop; i += yStep) {\n            for (let j = xStart; j < xStop; j += xStep) {\n                fn(\n                    _fn => this._eachAddress(j - xStep2 - 1, i - yStep2 - 1, j + xStep2, i + yStep2, _fn),\n                    j - xStep2 - 1,\n                    i - yStep2 - 1,\n                    j + xStep2,\n                    i + yStep2\n                );\n            }\n        }\n    }\n\n    /**\n     * Build horizontal, vertical, and temporal difference of a pixel address.\n     * @param {number} address - address to build values for\n     * @returns {object} a object with a gradX, grady, and gradT value\n     */\n    _grads (address) {\n        const {curr, prev} = this.motion;\n        const gradX = (curr[address - 1] & 0xff) - (curr[address + 1] & 0xff);\n        const gradY = (curr[address - WIDTH] & 0xff) - (curr[address + WIDTH] & 0xff);\n        const gradT = (prev[address] & 0xff) - (curr[address] & 0xff);\n        return {gradX, gradY, gradT};\n    }\n\n    /**\n     * Build component values used in determining a motion vector for a pixel\n     * address.\n     * @param {function} eachAddress - a bound handle to _eachAddress to build\n     *   component values for\n     * @returns {object} a object with a A2, A1B2, B1, C2, C1 value\n     */\n    _components (eachAddress) {\n        let A2 = 0;\n        let A1B2 = 0;\n        let B1 = 0;\n        let C2 = 0;\n        let C1 = 0;\n\n        eachAddress(address => {\n            const {gradX, gradY, gradT} = this._grads(address);\n            A2 += gradX * gradX;\n            A1B2 += gradX * gradY;\n            B1 += gradY * gradY;\n            C2 += gradX * gradT;\n            C1 += gradY * gradT;\n        });\n\n        _videoMotionViewComponentsTmp.A2 = A2;\n        _videoMotionViewComponentsTmp.A1B2 = A1B2;\n        _videoMotionViewComponentsTmp.B1 = B1;\n        _videoMotionViewComponentsTmp.C2 = C2;\n        _videoMotionViewComponentsTmp.C1 = C1;\n        return _videoMotionViewComponentsTmp;\n    }\n\n    /**\n     * Visualize the motion code output mode selected for this view to the\n     * debug canvas.\n     */\n    draw () {\n        if (!(this.motion.prev && this.motion.curr)) {\n            return;\n        }\n\n        const {buffer} = this;\n\n        if (this.output === OUTPUT.INPUT) {\n            const {curr} = this.motion;\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                buffer[address] = curr[address];\n            });\n        }\n        if (this.output === OUTPUT.XYT) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                const over1 = gradT / 0xcf;\n                buffer[address] =\n                    (0xff << 24) +\n                    (Math.floor((((gradY * over1) & 0xff) + 0xff) / 2) << 8) +\n                    Math.floor((((gradX * over1) & 0xff) + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XYT_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY, gradT} = this._grads(address);\n                    C2 += (Math.max(Math.min(gradX / 0x0f, 1), -1)) * (gradT / 0xff);\n                    C1 += (Math.max(Math.min(gradY / 0x0f, 1), -1)) * (gradT / 0xff);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        }\n        if (this.output === OUTPUT.XY) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] = (0xff << 24) + (((gradY + 0xff) / 2) << 8) + ((gradX + 0xff) / 2);\n            });\n        }\n        if (this.output === OUTPUT.XY_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let C1 = 0;\n                let C2 = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradX, gradY} = this._grads(address);\n                    C2 += Math.max(Math.min(gradX / 0x1f, 1), -1);\n                    C1 += Math.max(Math.min(gradY / 0x1f, 1), -1);\n                    n += 1;\n                });\n\n                C1 /= n;\n                C2 /= n;\n                C1 = Math.log(C1 + (1 * Math.sign(C1))) / Math.log(2);\n                C2 = Math.log(C2 + (1 * Math.sign(C2))) / Math.log(2);\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((C1 * 0x7f) | 0) + 0x80) << 8) & 0xff00) +\n                        (((((C2 * 0x7f) | 0) + 0x80) << 0) & 0xff);\n                });\n            });\n        } else if (this.output === OUTPUT.T) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradT} = this._grads(address);\n                buffer[address] = (0xff << 24) + ((gradT + 0xff) / 2 << 16);\n            });\n        }\n        if (this.output === OUTPUT.T_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let T = 0;\n                let n = 0;\n\n                eachAddress(address => {\n                    const {gradT} = this._grads(address);\n                    T += gradT / 0xff;\n                    n += 1;\n                });\n\n                T /= n;\n\n                eachAddress(address => {\n                    buffer[address] = (0xff << 24) +\n                        (((((T * 0x7f) | 0) + 0x80) << 16) & 0xff0000);\n                });\n            });\n        } else if (this.output === OUTPUT.C) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY, gradT} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    (((Math.sqrt(gradY * gradT) * 0x0f) & 0xff) << 8) +\n                    ((Math.sqrt(gradX * gradT) * 0x0f) & 0xff);\n            });\n        }\n        if (this.output === OUTPUT.C_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let {C2, C1} = this._components(eachAddress);\n\n                C2 = Math.sqrt(C2);\n                C1 = Math.sqrt(C1);\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        ((C1 & 0xff) << 8) +\n                        ((C2 & 0xff) << 0);\n                });\n            });\n        } else if (this.output === OUTPUT.AB) {\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {gradX, gradY} = this._grads(address);\n                buffer[address] =\n                    (0xff << 24) +\n                    (((gradX * gradY) & 0xff) << 16) +\n                    (((gradY * gradY) & 0xff) << 8) +\n                    ((gradX * gradX) & 0xff);\n            });\n        }\n        if (this.output === OUTPUT.AB_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                let {A2, A1B2, B1} = this._components(eachAddress);\n\n                A2 = Math.sqrt(A2);\n                A1B2 = Math.sqrt(A1B2);\n                B1 = Math.sqrt(B1);\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        ((A1B2 & 0xff) << 16) +\n                        ((B1 & 0xff) << 8) +\n                        (A2 & 0xff);\n                });\n            });\n        } else if (this.output === OUTPUT.UV) {\n            const winStep = (WINSIZE * 2) + 1;\n\n            this._eachAddress(1, 1, WIDTH - 1, HEIGHT - 1, address => {\n                const {A2, A1B2, B1, C2, C1} = this._components(fn => fn(address));\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                const inRange = (-winStep < u && u < winStep && -winStep < v && v < winStep);\n                const hypot = Math.hypot(u, v);\n                const amount = AMOUNT_SCALE * hypot;\n\n                buffer[address] =\n                    (0xff << 24) +\n                    (inRange && amount > THRESHOLD ?\n                        (((((v / winStep) + 1) / 2 * 0xff) << 8) & 0xff00) +\n                        (((((u / winStep) + 1) / 2 * 0xff) << 0) & 0xff) :\n                        0x8080\n                    );\n            });\n        } else if (this.output === OUTPUT.UV_CELL) {\n            const winStep = (WINSIZE * 2) + 1;\n            const wmax = WIDTH - WINSIZE - 1;\n            const hmax = HEIGHT - WINSIZE - 1;\n\n            this._eachCell(WINSIZE + 1, WINSIZE + 1, wmax, hmax, winStep, winStep, eachAddress => {\n                const {A2, A1B2, B1, C2, C1} = this._components(eachAddress);\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                const inRange = (-winStep < u && u < winStep && -winStep < v && v < winStep);\n                const hypot = Math.hypot(u, v);\n                const amount = AMOUNT_SCALE * hypot;\n\n                eachAddress(address => {\n                    buffer[address] =\n                        (0xff << 24) +\n                        (inRange && amount > THRESHOLD ?\n                            (((((v / winStep) + 1) / 2 * 0xff) << 8) & 0xff00) +\n                            (((((u / winStep) + 1) / 2 * 0xff) << 0) & 0xff) :\n                            0x8080\n                        );\n                });\n            });\n        }\n\n        const data = new ImageData(new Uint8ClampedArray(this.buffer.buffer), WIDTH, HEIGHT);\n        this.context.putImageData(data, 0, 0);\n    }\n}\n\nmodule.exports = VideoMotionView;\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","var deferred = [];\n__webpack_require__.O = (result, chunkIds, fn, priority) => {\n\tif(chunkIds) {\n\t\tpriority = priority || 0;\n\t\tfor(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];\n\t\tdeferred[i] = [chunkIds, fn, priority];\n\t\treturn;\n\t}\n\tvar notFulfilled = Infinity;\n\tfor (var i = 0; i < deferred.length; i++) {\n\t\tvar [chunkIds, fn, priority] = deferred[i];\n\t\tvar fulfilled = true;\n\t\tfor (var j = 0; j < chunkIds.length; j++) {\n\t\t\tif ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {\n\t\t\t\tchunkIds.splice(j--, 1);\n\t\t\t} else {\n\t\t\t\tfulfilled = false;\n\t\t\t\tif(priority < notFulfilled) notFulfilled = priority;\n\t\t\t}\n\t\t}\n\t\tif(fulfilled) {\n\t\t\tdeferred.splice(i--, 1)\n\t\t\tvar r = fn();\n\t\t\tif (r !== undefined) result = r;\n\t\t}\n\t}\n\treturn result;\n};","__webpack_require__.g = (function() {\n\tif (typeof globalThis === 'object') return globalThis;\n\ttry {\n\t\treturn this || new Function('return this')();\n\t} catch (e) {\n\t\tif (typeof window === 'object') return window;\n\t}\n})();","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","// no baseURI\n\n// object to store loaded and loading chunks\n// undefined = chunk not loaded, null = chunk preloaded/prefetched\n// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded\nvar installedChunks = {\n\t\"video-sensing-extension-debug\": 0\n};\n\n// no chunk on demand loading\n\n// no prefetching\n\n// no preloaded\n\n// no HMR\n\n// no HMR manifest\n\n__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);\n\n// install a JSONP callback for chunk loading\nvar webpackJsonpCallback = (parentChunkLoadingFunction, data) => {\n\tvar [chunkIds, moreModules, runtime] = data;\n\t// add \"moreModules\" to the modules object,\n\t// then flag all \"chunkIds\" as loaded and fire callback\n\tvar moduleId, chunkId, i = 0;\n\tif(chunkIds.some((id) => (installedChunks[id] !== 0))) {\n\t\tfor(moduleId in moreModules) {\n\t\t\tif(__webpack_require__.o(moreModules, moduleId)) {\n\t\t\t\t__webpack_require__.m[moduleId] = moreModules[moduleId];\n\t\t\t}\n\t\t}\n\t\tif(runtime) var result = runtime(__webpack_require__);\n\t}\n\tif(parentChunkLoadingFunction) parentChunkLoadingFunction(data);\n\tfor(;i < chunkIds.length; i++) {\n\t\tchunkId = chunkIds[i];\n\t\tif(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {\n\t\t\tinstalledChunks[chunkId][0]();\n\t\t}\n\t\tinstalledChunks[chunkId] = 0;\n\t}\n\treturn __webpack_require__.O(result);\n}\n\nvar chunkLoadingGlobal = self[\"webpackChunkscratch_vm\"] = self[\"webpackChunkscratch_vm\"] || [];\nchunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));\nchunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));","","// startup\n// Load entry module and return exports\n// This entry module depends on other loaded chunks and execution need to be delayed\nvar __webpack_exports__ = __webpack_require__.O(undefined, [\"src_extensions_scratch3_video_sensing_library_js\"], () => (__webpack_require__(\"./src/extensions/scratch3_video_sensing/debug-exposed.js\")))\n__webpack_exports__ = __webpack_require__.O(__webpack_exports__);\n",""],"names":[],"sourceRoot":""}