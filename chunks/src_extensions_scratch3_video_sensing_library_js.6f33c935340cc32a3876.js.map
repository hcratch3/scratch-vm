{"version":3,"file":"chunks/src_extensions_scratch3_video_sensing_library_js.6f33c935340cc32a3876.js","mappings":";;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AC/XA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA","sources":["webpack://scratch-vm/./src/extensions/scratch3_video_sensing/library.js","webpack://scratch-vm/./src/extensions/scratch3_video_sensing/math.js"],"sourcesContent":["/**\n * @file library.js\n *\n * Tony Hwang and John Maloney, January 2011\n * Michael \"Z\" Goddard, March 2018\n *\n * Video motion sensing primitives.\n */\n\nconst {motionVector, scratchAtan2} = require('./math');\n\n/**\n * The width of the intended resolution to analyze for motion.\n * @type {number}\n */\nconst WIDTH = 480;\n\n/**\n * The height of the intended resolution to analyze for motion.\n * @type {number}\n */\nconst HEIGHT = 360;\n\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v. This creates the motionAmount value.\n *\n * Old note: chosen empirically to give a range of roughly 0-100\n *\n * @type {number}\n */\nconst AMOUNT_SCALE = 100;\n\n/**\n * A constant value to scale the magnitude of the x and y components called u\n * and v in the local motion derivative. This creates the motionAmount value on\n * a target's motion state.\n *\n * Old note: note 2e-4 * activePixelNum is an experimentally tuned threshold\n * for my logitech Pro 9000 webcam - TTH\n *\n * @type {number}\n */\nconst LOCAL_AMOUNT_SCALE = AMOUNT_SCALE * 2e-4;\n\n/**\n * The motion amount must be higher than the THRESHOLD to calculate a new\n * direction value.\n * @type {number}\n */\nconst THRESHOLD = 10;\n\n/**\n * The size of the radius of the window of summarized values when considering\n * the motion inside the full resolution of the sample.\n * @type {number}\n */\nconst WINSIZE = 8;\n\n/**\n * A ceiling for the motionAmount stored to a local target's motion state. The\n * motionAmount is not allowed to be larger than LOCAL_MAX_AMOUNT.\n * @type {number}\n */\nconst LOCAL_MAX_AMOUNT = 100;\n\n/**\n * The motion amount for a target's local motion must be higher than the\n * LOCAL_THRESHOLD to calculate a new direction value.\n * @type {number}\n */\nconst LOCAL_THRESHOLD = THRESHOLD / 3;\n\n/**\n * Store the necessary image pixel data to compares frames of a video and\n * detect an amount and direction of motion in the full sample or in a\n * specified area.\n * @constructor\n */\nclass VideoMotion {\n    constructor () {\n        /**\n         * The number of frames that have been added from a source.\n         * @type {number}\n         */\n        this.frameNumber = 0;\n\n        /**\n         * The frameNumber last analyzed.\n         * @type {number}\n         */\n        this.lastAnalyzedFrame = 0;\n\n        /**\n         * The amount of motion detected in the current frame.\n         * @type {number}\n         */\n        this.motionAmount = 0;\n\n        /**\n         * The direction the motion detected in the frame is general moving in.\n         * @type {number}\n         */\n        this.motionDirection = 0;\n\n        /**\n         * A copy of the current frame's pixel values. A index of the array is\n         * represented in RGBA. The lowest byte is red. The next is green. The\n         * next is blue. And the last is the alpha value of that pixel.\n         * @type {Uint32Array}\n         */\n        this.curr = null;\n\n        /**\n         * A copy of the last frame's pixel values.\n         * @type {Uint32Array}\n         */\n        this.prev = null;\n\n        /**\n         * A buffer for holding one component of a pixel's full value twice.\n         * One for the current value. And one for the last value.\n         * @type {number}\n         */\n        this._arrays = new ArrayBuffer(WIDTH * HEIGHT * 2 * 1);\n\n        /**\n         * A clamped uint8 view of _arrays. One component of each index of the\n         * curr member is copied into this array.\n         * @type {number}\n         */\n        this._curr = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 0 * 1, WIDTH * HEIGHT);\n\n        /**\n         * A clamped uint8 view of _arrays. One component of each index of the\n         * prev member is copied into this array.\n         * @type {number}\n         */\n        this._prev = new Uint8ClampedArray(this._arrays, WIDTH * HEIGHT * 1 * 1, WIDTH * HEIGHT);\n    }\n\n    /**\n     * Reset internal state so future frame analysis does not consider values\n     * from before this method was called.\n     */\n    reset () {\n        this.frameNumber = 0;\n        this.lastAnalyzedFrame = 0;\n        this.motionAmount = this.motionDirection = 0;\n        this.prev = this.curr = null;\n    }\n\n    /**\n     * Add a frame to be next analyzed. The passed array represent a pixel with\n     * each index in the RGBA format.\n     * @param {Uint32Array} source - a source frame of pixels to copy\n     */\n    addFrame (source) {\n        this.frameNumber++;\n\n        // Swap curr to prev.\n        this.prev = this.curr;\n        // Create a clone of the array so any modifications made to the source\n        // array do not affect the work done in here.\n        this.curr = new Uint32Array(source.buffer.slice(0));\n\n        // Swap _prev and _curr. Copy one of the color components of the new\n        // array into _curr overwriting what was the old _prev data.\n        const _tmp = this._prev;\n        this._prev = this._curr;\n        this._curr = _tmp;\n        for (let i = 0; i < this.curr.length; i++) {\n            this._curr[i] = this.curr[i] & 0xff;\n        }\n    }\n\n    /**\n     * Analyze the current frame against the previous frame determining the\n     * amount of motion and direction of the motion.\n     */\n    analyzeFrame () {\n        if (!this.curr || !this.prev) {\n            this.motionAmount = this.motionDirection = -1;\n            // Don't have two frames to analyze yet\n            return;\n        }\n\n        // Return early if new data has not been received.\n        if (this.lastAnalyzedFrame === this.frameNumber) {\n            return;\n        }\n        this.lastAnalyzedFrame = this.frameNumber;\n\n        const {\n            _curr: curr,\n            _prev: prev\n        } = this;\n\n        const winStep = (WINSIZE * 2) + 1;\n        const wmax = WIDTH - WINSIZE - 1;\n        const hmax = HEIGHT - WINSIZE - 1;\n\n        // Accumulate 2d motion vectors from groups of pixels and average it\n        // later.\n        let uu = 0;\n        let vv = 0;\n        let n = 0;\n\n        // Iterate over groups of cells building up the components to determine\n        // a motion vector for each cell instead of the whole frame to avoid\n        // integer overflows.\n        for (let i = WINSIZE + 1; i < hmax; i += winStep) {\n            for (let j = WINSIZE + 1; j < wmax; j += winStep) {\n                let A2 = 0;\n                let A1B2 = 0;\n                let B1 = 0;\n                let C1 = 0;\n                let C2 = 0;\n\n                // This is a performance critical math region.\n                let address = ((i - WINSIZE) * WIDTH) + j - WINSIZE;\n                let nextAddress = address + winStep;\n                const maxAddress = ((i + WINSIZE) * WIDTH) + j + WINSIZE;\n                for (; address <= maxAddress; address += WIDTH - winStep, nextAddress += WIDTH) {\n                    for (; address <= nextAddress; address += 1) {\n                        // The difference in color between the last frame and\n                        // the current frame.\n                        const gradT = ((prev[address]) - (curr[address]));\n                        // The difference between the pixel to the left and the\n                        // pixel to the right.\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        // The difference between the pixel above and the pixel\n                        // below.\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        // Add the combined values of this pixel to previously\n                        // considered pixels.\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                    }\n                }\n\n                // Use the accumalated values from the for loop to determine a\n                // motion direction.\n                const {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n                // If u and v are within negative winStep to positive winStep,\n                // add them to a sum that will later be averaged.\n                if (-winStep < u && u < winStep && -winStep < v && v < winStep) {\n                    uu += u;\n                    vv += v;\n                    n++;\n                }\n            }\n        }\n\n        // Average the summed vector values of all of the motion groups.\n        uu /= n;\n        vv /= n;\n\n        // Scale the magnitude of the averaged UV vector.\n        this.motionAmount = Math.round(AMOUNT_SCALE * Math.hypot(uu, vv));\n        if (this.motionAmount > THRESHOLD) {\n            // Scratch direction\n            this.motionDirection = scratchAtan2(vv, uu);\n        }\n    }\n\n    /**\n     * Build motion amount and direction values based on stored current and\n     * previous frame that overlaps a given drawable.\n     * @param {Drawable} drawable - touchable and bounded drawable to build motion for\n     * @param {MotionState} state - state to store built values to\n     */\n    getLocalMotion (drawable, state) {\n        if (!this.curr || !this.prev) {\n            state.motionAmount = state.motionDirection = -1;\n            // Don't have two frames to analyze yet\n            return;\n        }\n\n        // Skip if the current frame has already been considered for this state.\n        if (state.motionFrameNumber !== this.frameNumber) {\n            const {\n                _prev: prev,\n                _curr: curr\n            } = this;\n\n            // The public APIs for Renderer#isTouching manage keeping the matrix and\n            // silhouette up-to-date, which is needed for drawable#isTouching to work (used below)\n            drawable.updateCPURenderAttributes();\n\n            // Restrict the region the amount and direction are built from to\n            // the area of the current frame overlapped by the given drawable's\n            // bounding box.\n            const boundingRect = drawable.getFastBounds();\n            // Transform the bounding box from scratch space to a space from 0,\n            // 0 to WIDTH, HEIGHT.\n            const xmin = Math.max(Math.floor(boundingRect.left + (WIDTH / 2)), 1);\n            const xmax = Math.min(Math.floor(boundingRect.right + (WIDTH / 2)), WIDTH - 1);\n            const ymin = Math.max(Math.floor((HEIGHT / 2) - boundingRect.top), 1);\n            const ymax = Math.min(Math.floor((HEIGHT / 2) - boundingRect.bottom), HEIGHT - 1);\n\n            let A2 = 0;\n            let A1B2 = 0;\n            let B1 = 0;\n            let C1 = 0;\n            let C2 = 0;\n            let scaleFactor = 0;\n\n            const position = [0, 0, 0];\n\n            // This is a performance critical math region.\n            for (let i = ymin; i < ymax; i++) {\n                for (let j = xmin; j < xmax; j++) {\n                    // i and j are in a coordinate planning ranging from 0 to\n                    // HEIGHT and 0 to WIDTH. Transform that into Scratch's\n                    // range of HEIGHT / 2 to -HEIGHT / 2 and -WIDTH / 2 to\n                    // WIDTH / 2;\n                    position[0] = j - (WIDTH / 2);\n                    position[1] = (HEIGHT / 2) - i;\n                    // Consider only pixels in the drawable that can touch the\n                    // edge or other drawables. Empty space in the current skin\n                    // is skipped.\n                    if (drawable.isTouching(position)) {\n                        const address = (i * WIDTH) + j;\n                        // The difference in color between the last frame and\n                        // the current frame.\n                        const gradT = ((prev[address]) - (curr[address]));\n                        // The difference between the pixel to the left and the\n                        // pixel to the right.\n                        const gradX = ((curr[address - 1]) - (curr[address + 1]));\n                        // The difference between the pixel above and the pixel\n                        // below.\n                        const gradY = ((curr[address - WIDTH]) - (curr[address + WIDTH]));\n\n                        // Add the combined values of this pixel to previously\n                        // considered pixels.\n                        A2 += gradX * gradX;\n                        A1B2 += gradX * gradY;\n                        B1 += gradY * gradY;\n                        C2 += gradX * gradT;\n                        C1 += gradY * gradT;\n                        scaleFactor++;\n                    }\n                }\n            }\n\n            // Use the accumalated values from the for loop to determine a\n            // motion direction.\n            let {u, v} = motionVector(A2, A1B2, B1, C2, C1);\n\n            let activePixelNum = 0;\n            if (scaleFactor) {\n                // Store the area of the sprite in pixels\n                activePixelNum = scaleFactor;\n\n                scaleFactor /= (2 * WINSIZE * 2 * WINSIZE);\n                u = u / scaleFactor;\n                v = v / scaleFactor;\n            }\n\n            // Scale the magnitude of the averaged UV vector and the number of\n            // overlapping drawable pixels.\n            state.motionAmount = Math.round(LOCAL_AMOUNT_SCALE * activePixelNum * Math.hypot(u, v));\n            if (state.motionAmount > LOCAL_MAX_AMOUNT) {\n                // Clip all magnitudes greater than 100.\n                state.motionAmount = LOCAL_MAX_AMOUNT;\n            }\n            if (state.motionAmount > LOCAL_THRESHOLD) {\n                // Scratch direction.\n                state.motionDirection = scratchAtan2(v, u);\n            }\n\n            // Skip future calls on this state until a new frame is added.\n            state.motionFrameNumber = this.frameNumber;\n        }\n    }\n}\n\nmodule.exports = VideoMotion;\n","/**\n * A constant value helping to transform a value in radians to degrees.\n * @type {number}\n */\nconst TO_DEGREE = 180 / Math.PI;\n\n/**\n * A object reused to save on memory allocation returning u and v vector from\n * motionVector.\n * @type {UV}\n */\nconst _motionVectorOut = {u: 0, v: 0};\n\n/**\n * Determine a motion vector combinations of the color component difference on\n * the x axis, y axis, and temporal axis.\n * @param {number} A2 - a sum of x axis squared\n * @param {number} A1B2 - a sum of x axis times y axis\n * @param {number} B1 - a sum of y axis squared\n * @param {number} C2 - a sum of x axis times temporal axis\n * @param {number} C1 - a sum of y axis times temporal axis\n * @param {UV} out - optional object to store return UV info in\n * @returns {UV} a uv vector representing the motion for the given input\n */\nconst motionVector = function (A2, A1B2, B1, C2, C1, out = _motionVectorOut) {\n    // Compare sums of X * Y and sums of X squared and Y squared.\n    const delta = ((A1B2 * A1B2) - (A2 * B1));\n    if (delta) {\n        // System is not singular - solving by Kramer method.\n        const deltaX = -((C1 * A1B2) - (C2 * B1));\n        const deltaY = -((A1B2 * C2) - (A2 * C1));\n        const Idelta = 8 / delta;\n        out.u = deltaX * Idelta;\n        out.v = deltaY * Idelta;\n    } else {\n        // Singular system - find optical flow in gradient direction.\n        const Norm = ((A1B2 + A2) * (A1B2 + A2)) + ((B1 + A1B2) * (B1 + A1B2));\n        if (Norm) {\n            const IGradNorm = 8 / Norm;\n            const temp = -(C1 + C2) * IGradNorm;\n            out.u = (A1B2 + A2) * temp;\n            out.v = (B1 + A1B2) * temp;\n        } else {\n            out.u = 0;\n            out.v = 0;\n        }\n    }\n    return out;\n};\n\n/**\n * Translate an angle in degrees with the range -180 to 180 rotated to\n * Scratch's reference angle.\n * @param {number} degrees - angle in range -180 to 180\n * @returns {number} angle from Scratch's reference angle\n */\nconst scratchDegrees = function (degrees) {\n    return ((degrees + 270) % 360) - 180;\n};\n\n/**\n * Get the angle of the y and x component of a 2d vector in degrees in\n * Scratch's coordinate plane.\n * @param {number} y - the y component of a 2d vector\n * @param {number} x - the x component of a 2d vector\n * @returns {number} angle in degrees in Scratch's coordinate plane\n */\nconst scratchAtan2 = function (y, x) {\n    return scratchDegrees(Math.atan2(y, x) * TO_DEGREE);\n};\n\nmodule.exports = {\n    motionVector,\n    scratchDegrees,\n    scratchAtan2\n};\n"],"names":[],"sourceRoot":""}