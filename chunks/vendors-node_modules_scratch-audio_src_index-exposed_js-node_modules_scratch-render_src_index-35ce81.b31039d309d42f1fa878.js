(self["webpackChunkscratch_vm"] = self["webpackChunkscratch_vm"] || []).push([["vendors-node_modules_scratch-audio_src_index-exposed_js-node_modules_scratch-render_src_index-35ce81"],{

/***/ "./node_modules/audio-context/index.js":
/*!*********************************************!*\
  !*** ./node_modules/audio-context/index.js ***!
  \*********************************************/
/***/ ((module) => {

"use strict";


var cache = {};
module.exports = function getContext(options) {
  if (typeof window === 'undefined') return null;
  var OfflineContext = window.OfflineAudioContext || window.webkitOfflineAudioContext;
  var Context = window.AudioContext || window.webkitAudioContext;
  if (!Context) return null;
  if (typeof options === 'number') {
    options = {
      sampleRate: options
    };
  }
  var sampleRate = options && options.sampleRate;
  if (options && options.offline) {
    if (!OfflineContext) return null;
    return new OfflineContext(options.channels || 2, options.length, sampleRate || 44100);
  }

  //cache by sampleRate, rather strong guess
  var ctx = cache[sampleRate];
  if (ctx) return ctx;

  //several versions of firefox have issues with the
  //constructor argument
  //see: https://bugzilla.mozilla.org/show_bug.cgi?id=1361475
  try {
    ctx = new Context(options);
  } catch (err) {
    ctx = new Context();
  }
  cache[ctx.sampleRate] = cache[sampleRate] = ctx;
  return ctx;
};

/***/ }),

/***/ "./node_modules/base64-js/lib/b64.js":
/*!*******************************************!*\
  !*** ./node_modules/base64-js/lib/b64.js ***!
  \*******************************************/
/***/ ((__unused_webpack_module, exports) => {

var lookup = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
;
(function (exports) {
  'use strict';

  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var PLUS = '+'.charCodeAt(0);
  var SLASH = '/'.charCodeAt(0);
  var NUMBER = '0'.charCodeAt(0);
  var LOWER = 'a'.charCodeAt(0);
  var UPPER = 'A'.charCodeAt(0);
  var PLUS_URL_SAFE = '-'.charCodeAt(0);
  var SLASH_URL_SAFE = '_'.charCodeAt(0);
  function decode(elt) {
    var code = elt.charCodeAt(0);
    if (code === PLUS || code === PLUS_URL_SAFE) return 62; // '+'
    if (code === SLASH || code === SLASH_URL_SAFE) return 63; // '/'
    if (code < NUMBER) return -1; //no match
    if (code < NUMBER + 10) return code - NUMBER + 26 + 26;
    if (code < UPPER + 26) return code - UPPER;
    if (code < LOWER + 26) return code - LOWER + 26;
  }
  function b64ToByteArray(b64) {
    var i, j, l, tmp, placeHolders, arr;
    if (b64.length % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    }

    // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice
    var len = b64.length;
    placeHolders = '=' === b64.charAt(len - 2) ? 2 : '=' === b64.charAt(len - 1) ? 1 : 0;

    // base64 is 4/3 + up to two characters of the original data
    arr = new Arr(b64.length * 3 / 4 - placeHolders);

    // if there are placeholders, only get up to the last complete 4 chars
    l = placeHolders > 0 ? b64.length - 4 : b64.length;
    var L = 0;
    function push(v) {
      arr[L++] = v;
    }
    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = decode(b64.charAt(i)) << 18 | decode(b64.charAt(i + 1)) << 12 | decode(b64.charAt(i + 2)) << 6 | decode(b64.charAt(i + 3));
      push((tmp & 0xFF0000) >> 16);
      push((tmp & 0xFF00) >> 8);
      push(tmp & 0xFF);
    }
    if (placeHolders === 2) {
      tmp = decode(b64.charAt(i)) << 2 | decode(b64.charAt(i + 1)) >> 4;
      push(tmp & 0xFF);
    } else if (placeHolders === 1) {
      tmp = decode(b64.charAt(i)) << 10 | decode(b64.charAt(i + 1)) << 4 | decode(b64.charAt(i + 2)) >> 2;
      push(tmp >> 8 & 0xFF);
      push(tmp & 0xFF);
    }
    return arr;
  }
  function uint8ToBase64(uint8) {
    var i,
      extraBytes = uint8.length % 3,
      // if we have 1 byte left, pad 2 bytes
      output = "",
      temp,
      length;
    function encode(num) {
      return lookup.charAt(num);
    }
    function tripletToBase64(num) {
      return encode(num >> 18 & 0x3F) + encode(num >> 12 & 0x3F) + encode(num >> 6 & 0x3F) + encode(num & 0x3F);
    }

    // go through the array every three bytes, we'll deal with trailing stuff later
    for (i = 0, length = uint8.length - extraBytes; i < length; i += 3) {
      temp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output += tripletToBase64(temp);
    }

    // pad the end with zeros, but make sure to not forget the extra bytes
    switch (extraBytes) {
      case 1:
        temp = uint8[uint8.length - 1];
        output += encode(temp >> 2);
        output += encode(temp << 4 & 0x3F);
        output += '==';
        break;
      case 2:
        temp = (uint8[uint8.length - 2] << 8) + uint8[uint8.length - 1];
        output += encode(temp >> 10);
        output += encode(temp >> 4 & 0x3F);
        output += encode(temp << 2 & 0x3F);
        output += '=';
        break;
    }
    return output;
  }
  exports.toByteArray = b64ToByteArray;
  exports.fromByteArray = uint8ToBase64;
})( false ? 0 : exports);

/***/ }),

/***/ "./node_modules/scratch-audio/src/index-exposed.js":
/*!*********************************************************!*\
  !*** ./node_modules/scratch-audio/src/index-exposed.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ "./node_modules/scratch-audio/src/index.js");
var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../../expose-loader/dist/runtime/getGlobalThis.js */ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js");
var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
if (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["AudioEngine"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___["AudioEngine"] = ___EXPOSE_LOADER_IMPORT___;else throw new Error('[exposes-loader] The "AudioEngine" value exists in the global scope, it may not be safe to overwrite it, use the "override" option');
module.exports = ___EXPOSE_LOADER_IMPORT___;

/***/ }),

/***/ "./node_modules/scratch-render/src/index-exposed.js":
/*!**********************************************************!*\
  !*** ./node_modules/scratch-render/src/index-exposed.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ___EXPOSE_LOADER_IMPORT___ = __webpack_require__(/*! -!./index.js */ "./node_modules/scratch-render/src/index.js");
var ___EXPOSE_LOADER_GET_GLOBAL_THIS___ = __webpack_require__(/*! ../../expose-loader/dist/runtime/getGlobalThis.js */ "./node_modules/expose-loader/dist/runtime/getGlobalThis.js");
var ___EXPOSE_LOADER_GLOBAL_THIS___ = ___EXPOSE_LOADER_GET_GLOBAL_THIS___;
if (typeof ___EXPOSE_LOADER_GLOBAL_THIS___["ScratchRender"] === 'undefined') ___EXPOSE_LOADER_GLOBAL_THIS___["ScratchRender"] = ___EXPOSE_LOADER_IMPORT___;else throw new Error('[exposes-loader] The "ScratchRender" value exists in the global scope, it may not be safe to overwrite it, use the "override" option');
module.exports = ___EXPOSE_LOADER_IMPORT___;

/***/ }),

/***/ "./node_modules/hull.js/src/convex.js":
/*!********************************************!*\
  !*** ./node_modules/hull.js/src/convex.js ***!
  \********************************************/
/***/ ((module) => {

function _cross(o, a, b) {
  return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
}
function _upperTangent(pointset) {
  var lower = [];
  for (var l = 0; l < pointset.length; l++) {
    while (lower.length >= 2 && _cross(lower[lower.length - 2], lower[lower.length - 1], pointset[l]) <= 0) {
      lower.pop();
    }
    lower.push(pointset[l]);
  }
  lower.pop();
  return lower;
}
function _lowerTangent(pointset) {
  var reversed = pointset.reverse(),
    upper = [];
  for (var u = 0; u < reversed.length; u++) {
    while (upper.length >= 2 && _cross(upper[upper.length - 2], upper[upper.length - 1], reversed[u]) <= 0) {
      upper.pop();
    }
    upper.push(reversed[u]);
  }
  upper.pop();
  return upper;
}

// pointset has to be sorted by X
function convex(pointset) {
  var convex,
    upper = _upperTangent(pointset),
    lower = _lowerTangent(pointset);
  convex = lower.concat(upper);
  convex.push(pointset[0]);
  return convex;
}
module.exports = convex;

/***/ }),

/***/ "./node_modules/hull.js/src/format.js":
/*!********************************************!*\
  !*** ./node_modules/hull.js/src/format.js ***!
  \********************************************/
/***/ ((module) => {

module.exports = {
  toXy: function toXy(pointset, format) {
    if (format === undefined) {
      return pointset.slice();
    }
    return pointset.map(function (pt) {
      /*jslint evil: true */
      var _getXY = new Function('pt', 'return [pt' + format[0] + ',' + 'pt' + format[1] + '];');
      return _getXY(pt);
    });
  },
  fromXy: function fromXy(pointset, format) {
    if (format === undefined) {
      return pointset.slice();
    }
    return pointset.map(function (pt) {
      /*jslint evil: true */
      var _getObj = new Function('pt', 'var o = {}; o' + format[0] + '= pt[0]; o' + format[1] + '= pt[1]; return o;');
      return _getObj(pt);
    });
  }
};

/***/ }),

/***/ "./node_modules/hull.js/src/grid.js":
/*!******************************************!*\
  !*** ./node_modules/hull.js/src/grid.js ***!
  \******************************************/
/***/ ((module) => {

function Grid(points, cellSize) {
  this._cells = [];
  this._cellSize = cellSize;
  points.forEach(function (point) {
    var cellXY = this.point2CellXY(point),
      x = cellXY[0],
      y = cellXY[1];
    if (this._cells[x] === undefined) {
      this._cells[x] = [];
    }
    if (this._cells[x][y] === undefined) {
      this._cells[x][y] = [];
    }
    this._cells[x][y].push(point);
  }, this);
}
Grid.prototype = {
  cellPoints: function cellPoints(x, y) {
    // (Number, Number) -> Array
    return this._cells[x] !== undefined && this._cells[x][y] !== undefined ? this._cells[x][y] : [];
  },
  rangePoints: function rangePoints(bbox) {
    // (Array) -> Array
    var tlCellXY = this.point2CellXY([bbox[0], bbox[1]]),
      brCellXY = this.point2CellXY([bbox[2], bbox[3]]),
      points = [];
    for (var x = tlCellXY[0]; x <= brCellXY[0]; x++) {
      for (var y = tlCellXY[1]; y <= brCellXY[1]; y++) {
        points = points.concat(this.cellPoints(x, y));
      }
    }
    return points;
  },
  removePoint: function removePoint(point) {
    // (Array) -> Array
    var cellXY = this.point2CellXY(point),
      cell = this._cells[cellXY[0]][cellXY[1]],
      pointIdxInCell;
    for (var i = 0; i < cell.length; i++) {
      if (cell[i][0] === point[0] && cell[i][1] === point[1]) {
        pointIdxInCell = i;
        break;
      }
    }
    cell.splice(pointIdxInCell, 1);
    return cell;
  },
  point2CellXY: function point2CellXY(point) {
    // (Array) -> Array
    var x = parseInt(point[0] / this._cellSize),
      y = parseInt(point[1] / this._cellSize);
    return [x, y];
  },
  extendBbox: function extendBbox(bbox, scaleFactor) {
    // (Array, Number) -> Array
    return [bbox[0] - scaleFactor * this._cellSize, bbox[1] - scaleFactor * this._cellSize, bbox[2] + scaleFactor * this._cellSize, bbox[3] + scaleFactor * this._cellSize];
  }
};
function grid(points, cellSize) {
  return new Grid(points, cellSize);
}
module.exports = grid;

/***/ }),

/***/ "./node_modules/hull.js/src/hull.js":
/*!******************************************!*\
  !*** ./node_modules/hull.js/src/hull.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*
 (c) 2014-2016, Andrii Heonia
 Hull.js, a JavaScript library for concave hull generation by set of points.
 https://github.com/AndriiHeonia/hull
*/



var intersect = __webpack_require__(/*! ./intersect.js */ "./node_modules/hull.js/src/intersect.js");
var grid = __webpack_require__(/*! ./grid.js */ "./node_modules/hull.js/src/grid.js");
var formatUtil = __webpack_require__(/*! ./format.js */ "./node_modules/hull.js/src/format.js");
var convexHull = __webpack_require__(/*! ./convex.js */ "./node_modules/hull.js/src/convex.js");
function _filterDuplicates(pointset) {
  return pointset.filter(function (el, idx, arr) {
    var prevEl = arr[idx - 1];
    return idx === 0 || !(prevEl[0] === el[0] && prevEl[1] === el[1]);
  });
}
function _sortByX(pointset) {
  return pointset.sort(function (a, b) {
    if (a[0] == b[0]) {
      return a[1] - b[1];
    } else {
      return a[0] - b[0];
    }
  });
}
function _sqLength(a, b) {
  return Math.pow(b[0] - a[0], 2) + Math.pow(b[1] - a[1], 2);
}
function _cos(o, a, b) {
  var aShifted = [a[0] - o[0], a[1] - o[1]],
    bShifted = [b[0] - o[0], b[1] - o[1]],
    sqALen = _sqLength(o, a),
    sqBLen = _sqLength(o, b),
    dot = aShifted[0] * bShifted[0] + aShifted[1] * bShifted[1];
  return dot / Math.sqrt(sqALen * sqBLen);
}
function _intersect(segment, pointset) {
  for (var i = 0; i < pointset.length - 1; i++) {
    var seg = [pointset[i], pointset[i + 1]];
    if (segment[0][0] === seg[0][0] && segment[0][1] === seg[0][1] || segment[0][0] === seg[1][0] && segment[0][1] === seg[1][1]) {
      continue;
    }
    if (intersect(segment, seg)) {
      return true;
    }
  }
  return false;
}
function _occupiedArea(pointset) {
  var minX = Infinity,
    minY = Infinity,
    maxX = -Infinity,
    maxY = -Infinity;
  for (var i = pointset.length - 1; i >= 0; i--) {
    if (pointset[i][0] < minX) {
      minX = pointset[i][0];
    }
    if (pointset[i][1] < minY) {
      minY = pointset[i][1];
    }
    if (pointset[i][0] > maxX) {
      maxX = pointset[i][0];
    }
    if (pointset[i][1] > maxY) {
      maxY = pointset[i][1];
    }
  }
  return [maxX - minX,
  // width
  maxY - minY // height
  ];
}
function _bBoxAround(edge) {
  return [Math.min(edge[0][0], edge[1][0]),
  // left
  Math.min(edge[0][1], edge[1][1]),
  // top
  Math.max(edge[0][0], edge[1][0]),
  // right
  Math.max(edge[0][1], edge[1][1]) // bottom
  ];
}
function _midPoint(edge, innerPoints, convex) {
  var point = null,
    angle1Cos = MAX_CONCAVE_ANGLE_COS,
    angle2Cos = MAX_CONCAVE_ANGLE_COS,
    a1Cos,
    a2Cos;
  for (var i = 0; i < innerPoints.length; i++) {
    a1Cos = _cos(edge[0], edge[1], innerPoints[i]);
    a2Cos = _cos(edge[1], edge[0], innerPoints[i]);
    if (a1Cos > angle1Cos && a2Cos > angle2Cos && !_intersect([edge[0], innerPoints[i]], convex) && !_intersect([edge[1], innerPoints[i]], convex)) {
      angle1Cos = a1Cos;
      angle2Cos = a2Cos;
      point = innerPoints[i];
    }
  }
  return point;
}
function _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList) {
  var edge,
    keyInSkipList,
    scaleFactor,
    midPoint,
    bBoxAround,
    bBoxWidth,
    bBoxHeight,
    midPointInserted = false;
  for (var i = 0; i < convex.length - 1; i++) {
    edge = [convex[i], convex[i + 1]];
    keyInSkipList = edge[0].join() + ',' + edge[1].join();
    if (_sqLength(edge[0], edge[1]) < maxSqEdgeLen || edgeSkipList[keyInSkipList] === true) {
      continue;
    }
    scaleFactor = 0;
    bBoxAround = _bBoxAround(edge);
    do {
      bBoxAround = grid.extendBbox(bBoxAround, scaleFactor);
      bBoxWidth = bBoxAround[2] - bBoxAround[0];
      bBoxHeight = bBoxAround[3] - bBoxAround[1];
      midPoint = _midPoint(edge, grid.rangePoints(bBoxAround), convex);
      scaleFactor++;
    } while (midPoint === null && (maxSearchArea[0] > bBoxWidth || maxSearchArea[1] > bBoxHeight));
    if (bBoxWidth >= maxSearchArea[0] && bBoxHeight >= maxSearchArea[1]) {
      edgeSkipList[keyInSkipList] = true;
    }
    if (midPoint !== null) {
      convex.splice(i + 1, 0, midPoint);
      grid.removePoint(midPoint);
      midPointInserted = true;
    }
  }
  if (midPointInserted) {
    return _concave(convex, maxSqEdgeLen, maxSearchArea, grid, edgeSkipList);
  }
  return convex;
}
function hull(pointset, concavity, format) {
  var convex,
    concave,
    innerPoints,
    occupiedArea,
    maxSearchArea,
    cellSize,
    points,
    maxEdgeLen = concavity || 20;
  points = _filterDuplicates(_sortByX(formatUtil.toXy(pointset, format)));
  if (points.length < 4) {
    return points.concat([points[0]]);
  }
  occupiedArea = _occupiedArea(points);
  maxSearchArea = [occupiedArea[0] * MAX_SEARCH_BBOX_SIZE_PERCENT, occupiedArea[1] * MAX_SEARCH_BBOX_SIZE_PERCENT];
  convex = convexHull(points);
  innerPoints = points.filter(function (pt) {
    return convex.indexOf(pt) < 0;
  });
  cellSize = Math.ceil(1 / (points.length / (occupiedArea[0] * occupiedArea[1])));
  concave = _concave(convex, Math.pow(maxEdgeLen, 2), maxSearchArea, grid(innerPoints, cellSize), {});
  return formatUtil.fromXy(concave, format);
}
var MAX_CONCAVE_ANGLE_COS = Math.cos(90 / (180 / Math.PI)); // angle = 90 deg
var MAX_SEARCH_BBOX_SIZE_PERCENT = 0.6;
module.exports = hull;

/***/ }),

/***/ "./node_modules/hull.js/src/intersect.js":
/*!***********************************************!*\
  !*** ./node_modules/hull.js/src/intersect.js ***!
  \***********************************************/
/***/ ((module) => {

function ccw(x1, y1, x2, y2, x3, y3) {
  var cw = (y3 - y1) * (x2 - x1) - (y2 - y1) * (x3 - x1);
  return cw > 0 ? true : cw < 0 ? false : true; // colinear
}
function intersect(seg1, seg2) {
  var x1 = seg1[0][0],
    y1 = seg1[0][1],
    x2 = seg1[1][0],
    y2 = seg1[1][1],
    x3 = seg2[0][0],
    y3 = seg2[0][1],
    x4 = seg2[1][0],
    y4 = seg2[1][1];
  return ccw(x1, y1, x3, y3, x4, y4) !== ccw(x2, y2, x3, y3, x4, y4) && ccw(x1, y1, x2, y2, x3, y3) !== ccw(x1, y1, x2, y2, x4, y4);
}
module.exports = intersect;

/***/ }),

/***/ "./node_modules/linebreak/src/classes.js":
/*!***********************************************!*\
  !*** ./node_modules/linebreak/src/classes.js ***!
  \***********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.7.1
(function () {
  var AI, AL, B2, BA, BB, BK, CB, CJ, CL, CM, CP, CR, EX, GL, H2, H3, HL, HY, ID, IN, IS, JL, JT, JV, LF, NL, NS, NU, OP, PO, PR, QU, RI, SA, SG, SP, SY, WJ, XX, ZW;
  exports.OP = OP = 0;
  exports.CL = CL = 1;
  exports.CP = CP = 2;
  exports.QU = QU = 3;
  exports.GL = GL = 4;
  exports.NS = NS = 5;
  exports.EX = EX = 6;
  exports.SY = SY = 7;
  exports.IS = IS = 8;
  exports.PR = PR = 9;
  exports.PO = PO = 10;
  exports.NU = NU = 11;
  exports.AL = AL = 12;
  exports.HL = HL = 13;
  exports.ID = ID = 14;
  exports.IN = IN = 15;
  exports.HY = HY = 16;
  exports.BA = BA = 17;
  exports.BB = BB = 18;
  exports.B2 = B2 = 19;
  exports.ZW = ZW = 20;
  exports.CM = CM = 21;
  exports.WJ = WJ = 22;
  exports.H2 = H2 = 23;
  exports.H3 = H3 = 24;
  exports.JL = JL = 25;
  exports.JV = JV = 26;
  exports.JT = JT = 27;
  exports.RI = RI = 28;
  exports.AI = AI = 29;
  exports.BK = BK = 30;
  exports.CB = CB = 31;
  exports.CJ = CJ = 32;
  exports.CR = CR = 33;
  exports.LF = LF = 34;
  exports.NL = NL = 35;
  exports.SA = SA = 36;
  exports.SG = SG = 37;
  exports.SP = SP = 38;
  exports.XX = XX = 39;
}).call(this);

/***/ }),

/***/ "./node_modules/linebreak/src/pairs.js":
/*!*********************************************!*\
  !*** ./node_modules/linebreak/src/pairs.js ***!
  \*********************************************/
/***/ (function(__unused_webpack_module, exports) {

// Generated by CoffeeScript 1.7.1
(function () {
  var CI_BRK, CP_BRK, DI_BRK, IN_BRK, PR_BRK;
  exports.DI_BRK = DI_BRK = 0;
  exports.IN_BRK = IN_BRK = 1;
  exports.CI_BRK = CI_BRK = 2;
  exports.CP_BRK = CP_BRK = 3;
  exports.PR_BRK = PR_BRK = 4;
  exports.pairTable = [[PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, CP_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, DI_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, PR_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK], [IN_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, IN_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, DI_BRK], [DI_BRK, PR_BRK, PR_BRK, IN_BRK, IN_BRK, IN_BRK, PR_BRK, PR_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK, IN_BRK, DI_BRK, DI_BRK, PR_BRK, CI_BRK, PR_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, DI_BRK, IN_BRK]];
}).call(this);

/***/ }),

/***/ "./node_modules/scratch-audio/src/ADPCMSoundDecoder.js":
/*!*************************************************************!*\
  !*** ./node_modules/scratch-audio/src/ADPCMSoundDecoder.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const ArrayBufferStream = __webpack_require__(/*! ./ArrayBufferStream */ "./node_modules/scratch-audio/src/ArrayBufferStream.js");
const log = __webpack_require__(/*! ./log */ "./node_modules/scratch-audio/src/log.js");

/**
 * Data used by the decompression algorithm
 * @type {Array}
 */
const STEP_TABLE = [7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 19, 21, 23, 25, 28, 31, 34, 37, 41, 45, 50, 55, 60, 66, 73, 80, 88, 97, 107, 118, 130, 143, 157, 173, 190, 209, 230, 253, 279, 307, 337, 371, 408, 449, 494, 544, 598, 658, 724, 796, 876, 963, 1060, 1166, 1282, 1411, 1552, 1707, 1878, 2066, 2272, 2499, 2749, 3024, 3327, 3660, 4026, 4428, 4871, 5358, 5894, 6484, 7132, 7845, 8630, 9493, 10442, 11487, 12635, 13899, 15289, 16818, 18500, 20350, 22385, 24623, 27086, 29794, 32767];

/**
 * Data used by the decompression algorithm
 * @type {Array}
 */
const INDEX_TABLE = [-1, -1, -1, -1, 2, 4, 6, 8, -1, -1, -1, -1, 2, 4, 6, 8];
let _deltaTable = null;

/**
 * Build a table of deltas from the 89 possible steps and 16 codes.
 * @return {Array<number>} computed delta values
 */
const deltaTable = function deltaTable() {
  if (_deltaTable === null) {
    const NUM_STEPS = STEP_TABLE.length;
    const NUM_INDICES = INDEX_TABLE.length;
    _deltaTable = new Array(NUM_STEPS * NUM_INDICES).fill(0);
    let i = 0;
    for (let index = 0; index < NUM_STEPS; index++) {
      for (let code = 0; code < NUM_INDICES; code++) {
        const step = STEP_TABLE[index];
        let delta = 0;
        if (code & 4) delta += step;
        if (code & 2) delta += step >> 1;
        if (code & 1) delta += step >> 2;
        delta += step >> 3;
        _deltaTable[i++] = code & 8 ? -delta : delta;
      }
    }
  }
  return _deltaTable;
};

/**
 * Decode wav audio files that have been compressed with the ADPCM format.
 * This is necessary because, while web browsers have native decoders for many audio
 * formats, ADPCM is a non-standard format used by Scratch since its early days.
 * This decoder is based on code from Scratch-Flash:
 * https://github.com/LLK/scratch-flash/blob/master/src/sound/WAVFile.as
 */
class ADPCMSoundDecoder {
  /**
   * @param {AudioContext} audioContext - a webAudio context
   * @constructor
   */
  constructor(audioContext) {
    this.audioContext = audioContext;
  }

  /**
   * Data used by the decompression algorithm
   * @type {Array}
   */
  static get STEP_TABLE() {
    return STEP_TABLE;
  }

  /**
   * Data used by the decompression algorithm
   * @type {Array}
   */
  static get INDEX_TABLE() {
    return INDEX_TABLE;
  }

  /**
   * Decode an ADPCM sound stored in an ArrayBuffer and return a promise
   * with the decoded audio buffer.
   * @param  {ArrayBuffer} audioData - containing ADPCM encoded wav audio
   * @return {Promise.<AudioBuffer>} the decoded audio buffer
   */
  decode(audioData) {
    return new Promise((resolve, reject) => {
      const stream = new ArrayBufferStream(audioData);
      const riffStr = stream.readUint8String(4);
      if (riffStr !== 'RIFF') {
        log.warn('incorrect adpcm wav header');
        reject(new Error('incorrect adpcm wav header'));
      }
      const lengthInHeader = stream.readInt32();
      if (lengthInHeader + 8 !== audioData.byteLength) {
        log.warn("adpcm wav length in header: ".concat(lengthInHeader, " is incorrect"));
      }
      const wavStr = stream.readUint8String(4);
      if (wavStr !== 'WAVE') {
        log.warn('incorrect adpcm wav header');
        reject(new Error('incorrect adpcm wav header'));
      }
      const formatChunk = this.extractChunk('fmt ', stream);
      this.encoding = formatChunk.readUint16();
      this.channels = formatChunk.readUint16();
      this.samplesPerSecond = formatChunk.readUint32();
      this.bytesPerSecond = formatChunk.readUint32();
      this.blockAlignment = formatChunk.readUint16();
      this.bitsPerSample = formatChunk.readUint16();
      formatChunk.position += 2; // skip extra header byte count
      this.samplesPerBlock = formatChunk.readUint16();
      this.adpcmBlockSize = (this.samplesPerBlock - 1) / 2 + 4; // block size in bytes

      const compressedData = this.extractChunk('data', stream);
      const sampleCount = this.numberOfSamples(compressedData, this.adpcmBlockSize);
      const buffer = this.audioContext.createBuffer(1, sampleCount, this.samplesPerSecond);
      this.imaDecompress(compressedData, this.adpcmBlockSize, buffer.getChannelData(0));
      resolve(buffer);
    });
  }

  /**
   * Extract a chunk of audio data from the stream, consisting of a set of audio data bytes
   * @param  {string} chunkType - the type of chunk to extract. 'data' or 'fmt' (format)
   * @param  {ArrayBufferStream} stream - an stream containing the audio data
   * @return {ArrayBufferStream} a stream containing the desired chunk
   */
  extractChunk(chunkType, stream) {
    stream.position = 12;
    while (stream.position < stream.getLength() - 8) {
      const typeStr = stream.readUint8String(4);
      const chunkSize = stream.readInt32();
      if (typeStr === chunkType) {
        const chunk = stream.extract(chunkSize);
        return chunk;
      }
      stream.position += chunkSize;
    }
  }

  /**
   * Count the exact number of samples in the compressed data.
   * @param {ArrayBufferStream} compressedData - the compressed data
   * @param {number} blockSize - size of each block in the data in bytes
   * @return {number} number of samples in the compressed data
   */
  numberOfSamples(compressedData, blockSize) {
    if (!compressedData) return 0;
    compressedData.position = 0;
    const available = compressedData.getBytesAvailable();
    const blocks = available / blockSize | 0;
    // Number of samples in full blocks.
    const fullBlocks = blocks * (2 * (blockSize - 4)) + 1;
    // Number of samples in the last incomplete block. 0 if the last block
    // is full.
    const subBlock = Math.max(available % blockSize - 4, 0) * 2;
    // 1 if the last block is incomplete. 0 if it is complete.
    const incompleteBlock = Math.min(available % blockSize, 1);
    return fullBlocks + subBlock + incompleteBlock;
  }

  /**
   * Decompress sample data using the IMA ADPCM algorithm.
   * Note: Handles only one channel, 4-bits per sample.
   * @param  {ArrayBufferStream} compressedData - a stream of compressed audio samples
   * @param  {number} blockSize - the number of bytes in the stream
   * @param  {Float32Array} out - the uncompressed audio samples
   */
  imaDecompress(compressedData, blockSize, out) {
    let sample;
    let code;
    let delta;
    let index = 0;
    let lastByte = -1; // -1 indicates that there is no saved lastByte

    // Bail and return no samples if we have no data
    if (!compressedData) return;
    compressedData.position = 0;
    const size = out.length;
    const samplesAfterBlockHeader = (blockSize - 4) * 2;
    const DELTA_TABLE = deltaTable();
    let i = 0;
    while (i < size) {
      // read block header
      sample = compressedData.readInt16();
      index = compressedData.readUint8();
      compressedData.position++; // skip extra header byte
      if (index > 88) index = 88;
      out[i++] = sample / 32768;
      const blockLength = Math.min(samplesAfterBlockHeader, size - i);
      const blockStart = i;
      while (i - blockStart < blockLength) {
        // read 4-bit code and compute delta from previous sample
        lastByte = compressedData.readUint8();
        code = lastByte & 0xF;
        delta = DELTA_TABLE[index * 16 + code];
        // compute next index
        index += INDEX_TABLE[code];
        if (index > 88) index = 88;else if (index < 0) index = 0;
        // compute and output sample
        sample += delta;
        if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;
        out[i++] = sample / 32768;

        // use 4-bit code from lastByte and compute delta from previous
        // sample
        code = lastByte >> 4 & 0xF;
        delta = DELTA_TABLE[index * 16 + code];
        // compute next index
        index += INDEX_TABLE[code];
        if (index > 88) index = 88;else if (index < 0) index = 0;
        // compute and output sample
        sample += delta;
        if (sample > 32767) sample = 32767;else if (sample < -32768) sample = -32768;
        out[i++] = sample / 32768;
      }
    }
  }
}
module.exports = ADPCMSoundDecoder;

/***/ }),

/***/ "./node_modules/scratch-audio/src/ArrayBufferStream.js":
/*!*************************************************************!*\
  !*** ./node_modules/scratch-audio/src/ArrayBufferStream.js ***!
  \*************************************************************/
/***/ ((module) => {

class ArrayBufferStream {
  /**
   * ArrayBufferStream wraps the built-in javascript ArrayBuffer, adding the ability to access
   * data in it like a stream, tracking its position.
   * You can request to read a value from the front of the array, and it will keep track of the position
   * within the byte array, so that successive reads are consecutive.
   * The available types to read include:
   * Uint8, Uint8String, Int16, Uint16, Int32, Uint32
   * @param {ArrayBuffer} arrayBuffer - array to use as a stream
   * @param {number} start - the start position in the raw buffer. position
   * will be relative to the start value.
   * @param {number} end - the end position in the raw buffer. length and
   * bytes available will be relative to the end value.
   * @param {ArrayBufferStream} parent - if passed reuses the parent's
   * internal objects
   * @constructor
   */
  constructor(arrayBuffer) {
    let start = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    let end = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : arrayBuffer.byteLength;
    let {
      _uint8View = new Uint8Array(arrayBuffer)
    } = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    /**
     * Raw data buffer for stream to read.
     * @type {ArrayBufferStream}
     */
    this.arrayBuffer = arrayBuffer;

    /**
     * Start position in arrayBuffer. Read values are relative to the start
     * in the arrayBuffer.
     * @type {number}
     */
    this.start = start;

    /**
     * End position in arrayBuffer. Length and bytes available are relative
     * to the start, end, and _position in the arrayBuffer;
     * @type {number};
     */
    this.end = end;

    /**
     * Cached Uint8Array view of the arrayBuffer. Heavily used for reading
     * Uint8 values and Strings from the stream.
     * @type {Uint8Array}
     */
    this._uint8View = _uint8View;

    /**
     * Raw position in the arrayBuffer relative to the beginning of the
     * arrayBuffer.
     * @type {number}
     */
    this._position = start;
  }

  /**
   * Return a new ArrayBufferStream that is a slice of the existing one
   * @param  {number} length - the number of bytes of extract
   * @return {ArrayBufferStream} the extracted stream
   */
  extract(length) {
    return new ArrayBufferStream(this.arrayBuffer, this._position, this._position + length, this);
  }

  /**
   * @return {number} the length of the stream in bytes
   */
  getLength() {
    return this.end - this.start;
  }

  /**
   * @return {number} the number of bytes available after the current position in the stream
   */
  getBytesAvailable() {
    return this.end - this._position;
  }

  /**
   * Position relative to the start value in the arrayBuffer of this
   * ArrayBufferStream.
   * @type {number}
   */
  get position() {
    return this._position - this.start;
  }

  /**
   * Set the position to read from in the arrayBuffer.
   * @type {number}
   * @param {number} value - new value to set position to
   */
  set position(value) {
    this._position = value + this.start;
  }

  /**
   * Read an unsigned 8 bit integer from the stream
   * @return {number} the next 8 bit integer in the stream
   */
  readUint8() {
    const val = this._uint8View[this._position];
    this._position += 1;
    return val;
  }

  /**
   * Read a sequence of bytes of the given length and convert to a string.
   * This is a convenience method for use with short strings.
   * @param {number} length - the number of bytes to convert
   * @return {string} a String made by concatenating the chars in the input
   */
  readUint8String(length) {
    const arr = this._uint8View;
    let str = '';
    const end = this._position + length;
    for (let i = this._position; i < end; i++) {
      str += String.fromCharCode(arr[i]);
    }
    this._position += length;
    return str;
  }

  /**
   * Read a 16 bit integer from the stream
   * @return {number} the next 16 bit integer in the stream
   */
  readInt16() {
    const val = new Int16Array(this.arrayBuffer, this._position, 1)[0];
    this._position += 2; // one 16 bit int is 2 bytes
    return val;
  }

  /**
   * Read an unsigned 16 bit integer from the stream
   * @return {number} the next unsigned 16 bit integer in the stream
   */
  readUint16() {
    const val = new Uint16Array(this.arrayBuffer, this._position, 1)[0];
    this._position += 2; // one 16 bit int is 2 bytes
    return val;
  }

  /**
   * Read a 32 bit integer from the stream
   * @return {number} the next 32 bit integer in the stream
   */
  readInt32() {
    let val;
    if (this._position % 4 === 0) {
      val = new Int32Array(this.arrayBuffer, this._position, 1)[0];
    } else {
      // Cannot read Int32 directly out because offset is not multiple of 4
      // Need to slice out the values first
      val = new Int32Array(this.arrayBuffer.slice(this._position, this._position + 4))[0];
    }
    this._position += 4; // one 32 bit int is 4 bytes
    return val;
  }

  /**
   * Read an unsigned 32 bit integer from the stream
   * @return {number} the next unsigned 32 bit integer in the stream
   */
  readUint32() {
    const val = new Uint32Array(this.arrayBuffer, this._position, 1)[0];
    this._position += 4; // one 32 bit int is 4 bytes
    return val;
  }
}
module.exports = ArrayBufferStream;

/***/ }),

/***/ "./node_modules/scratch-audio/src/AudioEngine.js":
/*!*******************************************************!*\
  !*** ./node_modules/scratch-audio/src/AudioEngine.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const StartAudioContext = __webpack_require__(/*! ./StartAudioContext */ "./node_modules/scratch-audio/src/StartAudioContext.js");
const AudioContext = __webpack_require__(/*! audio-context */ "./node_modules/audio-context/index.js");
const log = __webpack_require__(/*! ./log */ "./node_modules/scratch-audio/src/log.js");
const uid = __webpack_require__(/*! ./uid */ "./node_modules/scratch-audio/src/uid.js");
const ADPCMSoundDecoder = __webpack_require__(/*! ./ADPCMSoundDecoder */ "./node_modules/scratch-audio/src/ADPCMSoundDecoder.js");
const Loudness = __webpack_require__(/*! ./Loudness */ "./node_modules/scratch-audio/src/Loudness.js");
const SoundPlayer = __webpack_require__(/*! ./SoundPlayer */ "./node_modules/scratch-audio/src/SoundPlayer.js");
const EffectChain = __webpack_require__(/*! ./effects/EffectChain */ "./node_modules/scratch-audio/src/effects/EffectChain.js");
const PanEffect = __webpack_require__(/*! ./effects/PanEffect */ "./node_modules/scratch-audio/src/effects/PanEffect.js");
const PitchEffect = __webpack_require__(/*! ./effects/PitchEffect */ "./node_modules/scratch-audio/src/effects/PitchEffect.js");
const VolumeEffect = __webpack_require__(/*! ./effects/VolumeEffect */ "./node_modules/scratch-audio/src/effects/VolumeEffect.js");
const SoundBank = __webpack_require__(/*! ./SoundBank */ "./node_modules/scratch-audio/src/SoundBank.js");

/**
 * Wrapper to ensure that audioContext.decodeAudioData is a promise
 * @param {object} audioContext The current AudioContext
 * @param {ArrayBuffer} buffer Audio data buffer to decode
 * @return {Promise} A promise that resolves to the decoded audio
 */
const decodeAudioData = function decodeAudioData(audioContext, buffer) {
  // Check for newer promise-based API
  if (audioContext.decodeAudioData.length === 1) {
    return audioContext.decodeAudioData(buffer);
  }
  // Fall back to callback API
  return new Promise((resolve, reject) => {
    audioContext.decodeAudioData(buffer, decodedAudio => resolve(decodedAudio), error => reject(error));
  });
};

/**
 * There is a single instance of the AudioEngine. It handles global audio
 * properties and effects, loads all the audio buffers for sounds belonging to
 * sprites.
 */
class AudioEngine {
  constructor() {
    let audioContext = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new AudioContext();
    /**
     * AudioContext to play and manipulate sounds with a graph of source
     * and effect nodes.
     * @type {AudioContext}
     */
    this.audioContext = audioContext;
    StartAudioContext(this.audioContext);

    /**
     * Master GainNode that all sounds plays through. Changing this node
     * will change the volume for all sounds.
     * @type {GainNode}
     */
    this.inputNode = this.audioContext.createGain();
    this.inputNode.connect(this.audioContext.destination);

    /**
     * a map of soundIds to audio buffers, holding sounds for all sprites
     * @type {Object<String, ArrayBuffer>}
     */
    this.audioBuffers = {};

    /**
     * A Loudness detector.
     * @type {Loudness}
     */
    this.loudness = null;

    /**
     * Array of effects applied in order, left to right,
     * Left is closest to input, Right is closest to output
     */
    this.effects = [PanEffect, PitchEffect, VolumeEffect];
  }

  /**
   * Current time in the AudioEngine.
   * @type {number}
   */
  get currentTime() {
    return this.audioContext.currentTime;
  }

  /**
   * Names of the audio effects.
   * @enum {string}
   */
  get EFFECT_NAMES() {
    return {
      pitch: 'pitch',
      pan: 'pan'
    };
  }

  /**
   * A short duration to transition audio prarameters.
   *
   * Used as a time constant for exponential transitions. A general value
   * must be large enough that it does not cute off lower frequency, or bass,
   * sounds. Human hearing lower limit is ~20Hz making a safe value 25
   * milliseconds or 0.025 seconds, where half of a 20Hz wave will play along
   * with the DECAY. Higher frequencies will play multiple waves during the
   * same amount of time and avoid clipping.
   *
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/AudioParam/setTargetAtTime}
   * @const {number}
   */
  get DECAY_DURATION() {
    return 0.025;
  }

  /**
   * Some environments cannot smoothly change parameters immediately, provide
   * a small delay before decaying.
   *
   * @see {@link https://bugzilla.mozilla.org/show_bug.cgi?id=1228207}
   * @const {number}
   */
  get DECAY_WAIT() {
    return 0.05;
  }

  /**
   * Get the input node.
   * @return {AudioNode} - audio node that is the input for this effect
   */
  getInputNode() {
    return this.inputNode;
  }

  /**
   * Decode a sound, decompressing it into audio samples.
   * @param {object} sound - an object containing audio data and metadata for
   *     a sound
   * @param {Buffer} sound.data - sound data loaded from scratch-storage
   * @returns {?Promise} - a promise which will resolve to the sound id and
   *     buffer if decoded
   */
  _decodeSound(sound) {
    // Make a copy of the buffer because decoding detaches the original
    // buffer
    const bufferCopy1 = sound.data.buffer.slice(0);

    // todo: multiple decodings of the same buffer create duplicate decoded
    // copies in audioBuffers. Create a hash id of the buffer or deprecate
    // audioBuffers to avoid memory issues for large audio buffers.
    const soundId = uid();

    // Attempt to decode the sound using the browser's native audio data
    // decoder If that fails, attempt to decode as ADPCM
    const decoding = decodeAudioData(this.audioContext, bufferCopy1).catch(() => {
      // If the file is empty, create an empty sound
      if (sound.data.length === 0) {
        return this._emptySound();
      }

      // The audio context failed to parse the sound data
      // we gave it, so try to decode as 'adpcm'

      // First we need to create another copy of our original data
      const bufferCopy2 = sound.data.buffer.slice(0);
      // Try decoding as adpcm
      return new ADPCMSoundDecoder(this.audioContext).decode(bufferCopy2).catch(() => this._emptySound());
    }).then(buffer => [soundId, buffer], error => {
      log.warn('audio data could not be decoded', error);
    });
    return decoding;
  }

  /**
   * An empty sound buffer, for use when we are unable to decode a sound file.
   * @returns {AudioBuffer} - an empty audio buffer.
   */
  _emptySound() {
    return this.audioContext.createBuffer(1, 1, this.audioContext.sampleRate);
  }

  /**
   * Decode a sound, decompressing it into audio samples.
   *
   * Store a reference to it the sound in the audioBuffers dictionary,
   * indexed by soundId.
   *
   * @param {object} sound - an object containing audio data and metadata for
   *     a sound
   * @param {Buffer} sound.data - sound data loaded from scratch-storage
   * @returns {?Promise} - a promise which will resolve to the sound id
   */
  decodeSound(sound) {
    return this._decodeSound(sound).then(_ref => {
      let [id, buffer] = _ref;
      this.audioBuffers[id] = buffer;
      return id;
    });
  }

  /**
   * Decode a sound, decompressing it into audio samples.
   *
   * Create a SoundPlayer instance that can be used to play the sound and
   * stop and fade out playback.
   *
   * @param {object} sound - an object containing audio data and metadata for
   *     a sound
   * @param {Buffer} sound.data - sound data loaded from scratch-storage
   * @returns {?Promise} - a promise which will resolve to the buffer
   */
  decodeSoundPlayer(sound) {
    return this._decodeSound(sound).then(_ref2 => {
      let [id, buffer] = _ref2;
      return new SoundPlayer(this, {
        id,
        buffer
      });
    });
  }

  /**
   * Get the current loudness of sound received by the microphone.
   * Sound is measured in RMS and smoothed.
   * @return {number} loudness scaled 0 to 100
   */
  getLoudness() {
    // The microphone has not been set up, so try to connect to it
    if (!this.loudness) {
      this.loudness = new Loudness(this.audioContext);
    }
    return this.loudness.getLoudness();
  }

  /**
   * Create an effect chain.
   * @returns {EffectChain} chain of effects defined by this AudioEngine
   */
  createEffectChain() {
    const effects = new EffectChain(this, this.effects);
    effects.connect(this);
    return effects;
  }

  /**
   * Create a sound bank and effect chain.
   * @returns {SoundBank} a sound bank configured with an effect chain
   *     defined by this AudioEngine
   */
  createBank() {
    return new SoundBank(this, this.createEffectChain());
  }
}
module.exports = AudioEngine;

/***/ }),

/***/ "./node_modules/scratch-audio/src/Loudness.js":
/*!****************************************************!*\
  !*** ./node_modules/scratch-audio/src/Loudness.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const log = __webpack_require__(/*! ./log */ "./node_modules/scratch-audio/src/log.js");
class Loudness {
  /**
   * Instrument and detect a loudness value from a local microphone.
   * @param {AudioContext} audioContext - context to create nodes from for
   *     detecting loudness
   * @constructor
   */
  constructor(audioContext) {
    /**
     * AudioContext the mic will connect to and provide analysis of
     * @type {AudioContext}
     */
    this.audioContext = audioContext;

    /**
     * Are we connecting to the mic yet?
     * @type {Boolean}
     */
    this.connectingToMic = false;

    /**
     * microphone, for measuring loudness, with a level meter analyzer
     * @type {MediaStreamSourceNode}
     */
    this.mic = null;
  }

  /**
   * Get the current loudness of sound received by the microphone.
   * Sound is measured in RMS and smoothed.
   * Some code adapted from Tone.js: https://github.com/Tonejs/Tone.js
   * @return {number} loudness scaled 0 to 100
   */
  getLoudness() {
    // The microphone has not been set up, so try to connect to it
    if (!this.mic && !this.connectingToMic) {
      this.connectingToMic = true; // prevent multiple connection attempts
      navigator.mediaDevices.getUserMedia({
        audio: true
      }).then(stream => {
        this.audioStream = stream;
        this.mic = this.audioContext.createMediaStreamSource(stream);
        this.analyser = this.audioContext.createAnalyser();
        this.mic.connect(this.analyser);
        this.micDataArray = new Float32Array(this.analyser.fftSize);
      }).catch(err => {
        log.warn(err);
      });
    }

    // If the microphone is set up and active, measure the loudness
    if (this.mic && this.audioStream.active) {
      this.analyser.getFloatTimeDomainData(this.micDataArray);
      let sum = 0;
      // compute the RMS of the sound
      for (let i = 0; i < this.micDataArray.length; i++) {
        sum += Math.pow(this.micDataArray[i], 2);
      }
      let rms = Math.sqrt(sum / this.micDataArray.length);
      // smooth the value, if it is descending
      if (this._lastValue) {
        rms = Math.max(rms, this._lastValue * 0.6);
      }
      this._lastValue = rms;

      // Scale the measurement so it's more sensitive to quieter sounds
      rms *= 1.63;
      rms = Math.sqrt(rms);
      // Scale it up to 0-100 and round
      rms = Math.round(rms * 100);
      // Prevent it from going above 100
      rms = Math.min(rms, 100);
      return rms;
    }

    // if there is no microphone input, return -1
    return -1;
  }
}
module.exports = Loudness;

/***/ }),

/***/ "./node_modules/scratch-audio/src/SoundBank.js":
/*!*****************************************************!*\
  !*** ./node_modules/scratch-audio/src/SoundBank.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const log = __webpack_require__(/*! ./log */ "./node_modules/scratch-audio/src/log.js");

/**
 * A symbol indicating all targets are to be effected.
 * @const {string}
 */
const ALL_TARGETS = '*';
class SoundBank {
  /**
   * A bank of sounds that can be played.
   * @constructor
   * @param {AudioEngine} audioEngine - related AudioEngine
   * @param {EffectChain} effectChainPrime - original EffectChain cloned for
   *     playing sounds
   */
  constructor(audioEngine, effectChainPrime) {
    /**
     * AudioEngine this SoundBank is related to.
     * @type {AudioEngine}
     */
    this.audioEngine = audioEngine;

    /**
     * Map of ids to soundPlayers.
     * @type {object<SoundPlayer>}
     */
    this.soundPlayers = {};

    /**
     * Map of targets by sound id.
     * @type {Map<string, Target>}
     */
    this.playerTargets = new Map();

    /**
     * Map of effect chains by sound id.
     * @type {Map<string, EffectChain}
     */
    this.soundEffects = new Map();

    /**
     * Original EffectChain cloned for every playing sound.
     * @type {EffectChain}
     */
    this.effectChainPrime = effectChainPrime;
  }

  /**
   * Add a sound player instance likely from AudioEngine.decodeSoundPlayer
   * @param {SoundPlayer} soundPlayer - SoundPlayer to add
   */
  addSoundPlayer(soundPlayer) {
    this.soundPlayers[soundPlayer.id] = soundPlayer;
  }

  /**
   * Get a sound player by id.
   * @param {string} soundId - sound to look for
   * @returns {SoundPlayer} instance of sound player for the id
   */
  getSoundPlayer(soundId) {
    if (!this.soundPlayers[soundId]) {
      log.error("SoundBank.getSoundPlayer(".concat(soundId, "): called missing sound in bank"));
    }
    return this.soundPlayers[soundId];
  }

  /**
   * Get a sound EffectChain by id.
   * @param {string} sound - sound to look for an EffectChain
   * @returns {EffectChain} available EffectChain for this id
   */
  getSoundEffects(sound) {
    if (!this.soundEffects.has(sound)) {
      this.soundEffects.set(sound, this.effectChainPrime.clone());
    }
    return this.soundEffects.get(sound);
  }

  /**
   * Play a sound.
   * @param {Target} target - Target to play for
   * @param {string} soundId - id of sound to play
   * @returns {Promise} promise that resolves when the sound finishes playback
   */
  playSound(target, soundId) {
    const effects = this.getSoundEffects(soundId);
    const player = this.getSoundPlayer(soundId);
    if (this.playerTargets.get(soundId) !== target) {
      // make sure to stop the old sound, effectively "forking" the output
      // when the target switches before we adjust it's effects
      player.stop();
    }
    this.playerTargets.set(soundId, target);
    effects.addSoundPlayer(player);
    effects.setEffectsFromTarget(target);
    player.connect(effects);
    player.play();
    return player.finished();
  }

  /**
   * Set the effects (pan, pitch, and volume) from values on the given target.
   * @param {Target} target - target to set values from
   */
  setEffects(target) {
    this.playerTargets.forEach((playerTarget, key) => {
      if (playerTarget === target) {
        this.getSoundEffects(key).setEffectsFromTarget(target);
      }
    });
  }

  /**
   * Stop playback of sound by id if was lasted played by the target.
   * @param {Target} target - target to check if it last played the sound
   * @param {string} soundId - id of the sound to stop
   */
  stop(target, soundId) {
    if (this.playerTargets.get(soundId) === target) {
      this.soundPlayers[soundId].stop();
    }
  }

  /**
   * Stop all sounds for all targets or a specific target.
   * @param {Target|string} target - a symbol for all targets or the target
   *     to stop sounds for
   */
  stopAllSounds() {
    let target = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ALL_TARGETS;
    this.playerTargets.forEach((playerTarget, key) => {
      if (target === ALL_TARGETS || playerTarget === target) {
        this.getSoundPlayer(key).stop();
      }
    });
  }

  /**
   * Dispose of all EffectChains and SoundPlayers.
   */
  dispose() {
    this.playerTargets.clear();
    this.soundEffects.forEach(effects => effects.dispose());
    this.soundEffects.clear();
    for (const soundId in this.soundPlayers) {
      if (Object.prototype.hasOwnProperty.call(this.soundPlayers, soundId)) {
        this.soundPlayers[soundId].dispose();
      }
    }
    this.soundPlayers = {};
  }
}
module.exports = SoundBank;

/***/ }),

/***/ "./node_modules/scratch-audio/src/SoundPlayer.js":
/*!*******************************************************!*\
  !*** ./node_modules/scratch-audio/src/SoundPlayer.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const {
  EventEmitter
} = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const VolumeEffect = __webpack_require__(/*! ./effects/VolumeEffect */ "./node_modules/scratch-audio/src/effects/VolumeEffect.js");

/**
 * Name of event that indicates playback has ended.
 * @const {string}
 */
const ON_ENDED = 'ended';
class SoundPlayer extends EventEmitter {
  /**
   * Play sounds that stop without audible clipping.
   *
   * @param {AudioEngine} audioEngine - engine to play sounds on
   * @param {object} data - required data for sound playback
   * @param {string} data.id - a unique id for this sound
   * @param {ArrayBuffer} data.buffer - buffer of the sound's waveform to play
   * @constructor
   */
  constructor(audioEngine, _ref) {
    let {
      id,
      buffer
    } = _ref;
    super();

    /**
     * Unique sound identifier set by AudioEngine.
     * @type {string}
     */
    this.id = id;

    /**
     * AudioEngine creating this sound player.
     * @type {AudioEngine}
     */
    this.audioEngine = audioEngine;

    /**
     * Decoded audio buffer from audio engine for playback.
     * @type {AudioBuffer}
     */
    this.buffer = buffer;

    /**
     * Output audio node.
     * @type {AudioNode}
     */
    this.outputNode = null;

    /**
     * VolumeEffect used to fade out playing sounds when stopping them.
     * @type {VolumeEffect}
     */
    this.volumeEffect = null;

    /**
     * Target engine, effect, or chain this player directly connects to.
     * @type {AudioEngine|Effect|EffectChain}
     */
    this.target = null;

    /**
     * Internally is the SoundPlayer initialized with at least its buffer
     * source node and output node.
     * @type {boolean}
     */
    this.initialized = false;

    /**
     * Is the sound playing or starting to play?
     * @type {boolean}
     */
    this.isPlaying = false;

    /**
     * Timestamp sound is expected to be starting playback until. Once the
     * future timestamp is reached the sound is considered to be playing
     * through the audio hardware and stopping should fade out instead of
     * cutting off playback.
     * @type {number}
     */
    this.startingUntil = 0;

    /**
     * Rate to play back the audio at.
     * @type {number}
     */
    this.playbackRate = 1;

    // handleEvent is a EventTarget api for the DOM, however the
    // web-audio-test-api we use uses an addEventListener that isn't
    // compatable with object and requires us to pass this bound function
    // instead
    this.handleEvent = this.handleEvent.bind(this);
  }

  /**
   * Is plaback currently starting?
   * @type {boolean}
   */
  get isStarting() {
    return this.isPlaying && this.startingUntil > this.audioEngine.currentTime;
  }

  /**
   * Handle any event we have told the output node to listen for.
   * @param {Event} event - dom event to handle
   */
  handleEvent(event) {
    if (event.type === ON_ENDED) {
      this.onEnded();
    }
  }

  /**
   * Event listener for when playback ends.
   */
  onEnded() {
    this.emit('stop');
    this.isPlaying = false;
  }

  /**
   * Create the buffer source node during initialization or secondary
   * playback.
   */
  _createSource() {
    if (this.outputNode !== null) {
      this.outputNode.removeEventListener(ON_ENDED, this.handleEvent);
      this.outputNode.disconnect();
    }
    this.outputNode = this.audioEngine.audioContext.createBufferSource();
    this.outputNode.playbackRate.value = this.playbackRate;
    this.outputNode.buffer = this.buffer;
    this.outputNode.addEventListener(ON_ENDED, this.handleEvent);
    if (this.target !== null) {
      this.connect(this.target);
    }
  }

  /**
   * Initialize the player for first playback.
   */
  initialize() {
    this.initialized = true;
    this._createSource();
  }

  /**
   * Connect the player to the engine or an effect chain.
   * @param {object} target - object to connect to
   * @returns {object} - return this sound player
   */
  connect(target) {
    if (target === this.volumeEffect) {
      this.outputNode.disconnect();
      this.outputNode.connect(this.volumeEffect.getInputNode());
      return;
    }
    this.target = target;
    if (!this.initialized) {
      return;
    }
    if (this.volumeEffect === null) {
      this.outputNode.disconnect();
      this.outputNode.connect(target.getInputNode());
    } else {
      this.volumeEffect.connect(target);
    }
    return this;
  }

  /**
   * Teardown the player.
   */
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.stopImmediately();
    if (this.volumeEffect !== null) {
      this.volumeEffect.dispose();
      this.volumeEffect = null;
    }
    this.outputNode.disconnect();
    this.outputNode = null;
    this.target = null;
    this.initialized = false;
  }

  /**
   * Take the internal state of this player and create a new player from
   * that. Restore the state of this player to that before its first playback.
   *
   * The returned player can be used to stop the original playback or
   * continue it without manipulation from the original player.
   *
   * @returns {SoundPlayer} - new SoundPlayer with old state
   */
  take() {
    if (this.outputNode) {
      this.outputNode.removeEventListener(ON_ENDED, this.handleEvent);
    }
    const taken = new SoundPlayer(this.audioEngine, this);
    taken.playbackRate = this.playbackRate;
    if (this.isPlaying) {
      taken.startingUntil = this.startingUntil;
      taken.isPlaying = this.isPlaying;
      taken.initialized = this.initialized;
      taken.outputNode = this.outputNode;
      taken.outputNode.addEventListener(ON_ENDED, taken.handleEvent);
      taken.volumeEffect = this.volumeEffect;
      if (taken.volumeEffect) {
        taken.volumeEffect.audioPlayer = taken;
      }
      if (this.target !== null) {
        taken.connect(this.target);
      }
      this.emit('stop');
      taken.emit('play');
    }
    this.outputNode = null;
    this.volumeEffect = null;
    this.initialized = false;
    this.startingUntil = 0;
    this.isPlaying = false;
    return taken;
  }

  /**
   * Start playback for this sound.
   *
   * If the sound is already playing it will stop playback with a quick fade
   * out.
   */
  play() {
    if (this.isStarting) {
      this.emit('stop');
      this.emit('play');
      return;
    }
    if (this.isPlaying) {
      this.stop();
    }
    if (this.initialized) {
      this._createSource();
    } else {
      this.initialize();
    }
    this.outputNode.start();
    this.isPlaying = true;
    const {
      currentTime,
      DECAY_DURATION
    } = this.audioEngine;
    this.startingUntil = currentTime + DECAY_DURATION;
    this.emit('play');
  }

  /**
   * Stop playback after quickly fading out.
   */
  stop() {
    if (!this.isPlaying) {
      return;
    }

    // always do a manual stop on a taken / volume effect fade out sound
    // player take will emit "stop" as well as reset all of our playing
    // statuses / remove our nodes / etc
    const taken = this.take();
    taken.volumeEffect = new VolumeEffect(taken.audioEngine, taken, null);
    taken.volumeEffect.connect(taken.target);
    // volumeEffect will recursively connect to us if it needs to, so this
    // happens too:
    // taken.connect(taken.volumeEffect);

    taken.finished().then(() => taken.dispose());
    taken.volumeEffect.set(0);
    const {
      currentTime,
      DECAY_DURATION
    } = this.audioEngine;
    taken.outputNode.stop(currentTime + DECAY_DURATION);
  }

  /**
   * Stop immediately without fading out. May cause audible clipping.
   */
  stopImmediately() {
    if (!this.isPlaying) {
      return;
    }
    this.outputNode.stop();
    this.isPlaying = false;
    this.startingUntil = 0;
    this.emit('stop');
  }

  /**
   * Return a promise that resolves when the sound next finishes.
   * @returns {Promise} - resolves when the sound finishes
   */
  finished() {
    return new Promise(resolve => {
      this.once('stop', resolve);
    });
  }

  /**
   * Set the sound's playback rate.
   * @param {number} value - playback rate. Default is 1.
   */
  setPlaybackRate(value) {
    this.playbackRate = value;
    if (this.initialized) {
      this.outputNode.playbackRate.value = value;
    }
  }
}
module.exports = SoundPlayer;

/***/ }),

/***/ "./node_modules/scratch-audio/src/StartAudioContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/scratch-audio/src/StartAudioContext.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// StartAudioContext assumes that we are in a window/document setting and messes with the unit
// tests, this is our own version just checking to see if we have a global document to listen
// to before we even try to "start" it.  Our test api audio context is started by default.
const StartAudioContext = __webpack_require__(/*! startaudiocontext */ "./node_modules/startaudiocontext/StartAudioContext.js");
module.exports = function (context) {
  if (typeof document !== 'undefined') {
    return StartAudioContext(context);
  }
};

/***/ }),

/***/ "./node_modules/scratch-audio/src/effects/Effect.js":
/*!**********************************************************!*\
  !*** ./node_modules/scratch-audio/src/effects/Effect.js ***!
  \**********************************************************/
/***/ ((module) => {

/**
 * An effect on an AudioPlayer and all its SoundPlayers.
 */
class Effect {
  /**
    * @param {AudioEngine} audioEngine - audio engine this runs with
    * @param {AudioPlayer} audioPlayer - audio player this affects
    * @param {Effect} lastEffect - effect in the chain before this one
    * @constructor
    */
  constructor(audioEngine, audioPlayer, lastEffect) {
    this.audioEngine = audioEngine;
    this.audioPlayer = audioPlayer;
    this.lastEffect = lastEffect;
    this.value = this.DEFAULT_VALUE;
    this.initialized = false;
    this.inputNode = null;
    this.outputNode = null;
    this.target = null;
  }

  /**
   * Return the name of the effect.
   * @type {string}
   */
  get name() {
    throw new Error("".concat(this.constructor.name, ".name is not implemented"));
  }

  /**
   * Default value to set the Effect to when constructed and when clear'ed.
   * @const {number}
   */
  get DEFAULT_VALUE() {
    return 0;
  }

  /**
   * Should the effect be connected to the audio graph?
   * The pitch effect is an example that does not need to be patched in.
   * Instead of affecting the graph it affects the player directly.
   * @return {boolean} is the effect affecting the graph?
   */
  get _isPatch() {
    return this.initialized && (this.value !== this.DEFAULT_VALUE || this.audioPlayer === null);
  }

  /**
   * Get the input node.
   * @return {AudioNode} - audio node that is the input for this effect
   */
  getInputNode() {
    if (this._isPatch) {
      return this.inputNode;
    }
    return this.target.getInputNode();
  }

  /**
   * Initialize the Effect.
   * Effects start out uninitialized. Then initialize when they are first set
   * with some value.
   * @throws {Error} throws when left unimplemented
   */
  initialize() {
    throw new Error("".concat(this.constructor.name, ".initialize is not implemented."));
  }

  /**
   * Set the effects value.
   * @private
   * @param {number} value - new value to set effect to
   */
  _set() {
    throw new Error("".concat(this.constructor.name, "._set is not implemented."));
  }

  /**
   * Set the effects value.
   * @param {number} value - new value to set effect to
   */
  set(value) {
    // Initialize the node on first set.
    if (!this.initialized) {
      this.initialize();
    }

    // Store whether the graph should currently affected by this effect.
    const wasPatch = this._isPatch;
    if (wasPatch) {
      this._lastPatch = this.audioEngine.currentTime;
    }

    // Call the internal implementation per this Effect.
    this._set(value);

    // Connect or disconnect from the graph if this now applies or no longer
    // applies an effect.
    if (this._isPatch !== wasPatch && this.target !== null) {
      this.connect(this.target);
    }
  }

  /**
   * Update the effect for changes in the audioPlayer.
   */
  update() {}

  /**
   * Clear the value back to the default.
   */
  clear() {
    this.set(this.DEFAULT_VALUE);
  }

  /**
   * Connnect this effect's output to another audio node
   * @param {object} target - target whose node to should be connected
   */
  connect(target) {
    if (target === null) {
      throw new Error('target may not be null');
    }
    const checkForCircularReference = subtarget => {
      if (subtarget) {
        if (subtarget === this) {
          return true;
        }
        return checkForCircularReference(subtarget.target);
      }
    };
    if (checkForCircularReference(target)) {
      throw new Error('Effect cannot connect to itself');
    }
    this.target = target;
    if (this.outputNode !== null) {
      this.outputNode.disconnect();
    }
    if (this._isPatch || this._lastPatch + this.audioEngine.DECAY_DURATION < this.audioEngine.currentTime) {
      this.outputNode.connect(target.getInputNode());
    }
    if (this.lastEffect === null) {
      if (this.audioPlayer !== null) {
        this.audioPlayer.connect(this);
      }
    } else {
      this.lastEffect.connect(this);
    }
  }

  /**
   * Clean up and disconnect audio nodes.
   */
  dispose() {
    this.inputNode = null;
    this.outputNode = null;
    this.target = null;
    this.initialized = false;
  }
}
module.exports = Effect;

/***/ }),

/***/ "./node_modules/scratch-audio/src/effects/EffectChain.js":
/*!***************************************************************!*\
  !*** ./node_modules/scratch-audio/src/effects/EffectChain.js ***!
  \***************************************************************/
/***/ ((module) => {

class EffectChain {
  /**
   * Chain of effects that can be applied to a group of SoundPlayers.
   * @param {AudioEngine} audioEngine - engine whose effects these belong to
   * @param {Array<Effect>} effects - array of Effect classes to construct
   */
  constructor(audioEngine, effects) {
    /**
     * AudioEngine whose effects these belong to.
     * @type {AudioEngine}
     */
    this.audioEngine = audioEngine;

    /**
     * Node incoming connections will attach to. This node than connects to
     * the items in the chain which finally connect to some output.
     * @type {AudioNode}
     */
    this.inputNode = this.audioEngine.audioContext.createGain();

    /**
     * List of Effect types to create.
     * @type {Array<Effect>}
     */
    this.effects = effects;

    // Effects are instantiated in reverse so that the first refers to the
    // second, the second refers to the third, etc and the last refers to
    // null.
    let lastEffect = null;
    /**
     * List of instantiated Effects.
     * @type {Array<Effect>}
     */
    this._effects = effects.reverse().map(Effect => {
      const effect = new Effect(audioEngine, this, lastEffect);
      this[effect.name] = effect;
      lastEffect = effect;
      return effect;
    }).reverse();

    /**
     * First effect of this chain.
     * @type {Effect}
     */
    this.firstEffect = this._effects[0];

    /**
     * Last effect of this chain.
     * @type {Effect}
     */
    this.lastEffect = this._effects[this._effects.length - 1];

    /**
     * A set of players this chain is managing.
     */
    this._soundPlayers = new Set();
  }

  /**
   * Create a clone of the EffectChain.
   * @returns {EffectChain} a clone of this EffectChain
   */
  clone() {
    const chain = new EffectChain(this.audioEngine, this.effects);
    if (this.target) {
      chain.connect(this.target);
    }
    return chain;
  }

  /**
   * Add a sound player.
   * @param {SoundPlayer} soundPlayer - a sound player to manage
   */
  addSoundPlayer(soundPlayer) {
    if (!this._soundPlayers.has(soundPlayer)) {
      this._soundPlayers.add(soundPlayer);
      this.update();
    }
  }

  /**
   * Remove a sound player.
   * @param {SoundPlayer} soundPlayer - a sound player to stop managing
   */
  removeSoundPlayer(soundPlayer) {
    this._soundPlayers.remove(soundPlayer);
  }

  /**
   * Get the audio input node.
   * @returns {AudioNode} audio node the upstream can connect to
   */
  getInputNode() {
    return this.inputNode;
  }

  /**
   * Connnect this player's output to another audio node.
   * @param {object} target - target whose node to should be connected
   */
  connect(target) {
    const {
      firstEffect,
      lastEffect
    } = this;
    if (target === lastEffect) {
      this.inputNode.disconnect();
      this.inputNode.connect(lastEffect.getInputNode());
      return;
    } else if (target === firstEffect) {
      return;
    }
    this.target = target;
    firstEffect.connect(target);
  }

  /**
   * Array of SoundPlayers managed by this EffectChain.
   * @returns {Array<SoundPlayer>} sound players managed by this chain
   */
  getSoundPlayers() {
    return [...this._soundPlayers];
  }

  /**
   * Set Effect values with named values on target.soundEffects if it exist
   * and then from target itself.
   * @param {Target} target - target to set values from
   */
  setEffectsFromTarget(target) {
    this._effects.forEach(effect => {
      if ('soundEffects' in target && effect.name in target.soundEffects) {
        effect.set(target.soundEffects[effect.name]);
      } else if (effect.name in target) {
        effect.set(target[effect.name]);
      }
    });
  }

  /**
   * Set an effect value by its name.
   * @param {string} effect - effect name to change
   * @param {number} value - value to set effect to
   */
  set(effect, value) {
    if (effect in this) {
      this[effect].set(value);
    }
  }

  /**
   * Update managed sound players with the effects on this chain.
   */
  update() {
    this._effects.forEach(effect => effect.update());
  }

  /**
   * Clear all effects to their default values.
   */
  clear() {
    this._effects.forEach(effect => effect.clear());
  }

  /**
   * Dispose of all effects in this chain. Nothing is done to managed
   * SoundPlayers.
   */
  dispose() {
    this._soundPlayers = null;
    this._effects.forEach(effect => effect.dispose());
    this._effects = null;
  }
}
module.exports = EffectChain;

/***/ }),

/***/ "./node_modules/scratch-audio/src/effects/PanEffect.js":
/*!*************************************************************!*\
  !*** ./node_modules/scratch-audio/src/effects/PanEffect.js ***!
  \*************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Effect = __webpack_require__(/*! ./Effect */ "./node_modules/scratch-audio/src/effects/Effect.js");

/**
 * A pan effect, which moves the sound to the left or right between the speakers
 * Effect value of -100 puts the audio entirely on the left channel,
 * 0 centers it, 100 puts it on the right.
 */
class PanEffect extends Effect {
  /**
   * @param {AudioEngine} audioEngine - audio engine this runs with
   * @param {AudioPlayer} audioPlayer - audio player this affects
   * @param {Effect} lastEffect - effect in the chain before this one
   * @constructor
   */
  constructor(audioEngine, audioPlayer, lastEffect) {
    super(audioEngine, audioPlayer, lastEffect);
    this.leftGain = null;
    this.rightGain = null;
    this.channelMerger = null;
  }

  /**
   * Return the name of the effect.
   * @type {string}
   */
  get name() {
    return 'pan';
  }

  /**
   * Initialize the Effect.
   * Effects start out uninitialized. Then initialize when they are first set
   * with some value.
   * @throws {Error} throws when left unimplemented
   */
  initialize() {
    const audioContext = this.audioEngine.audioContext;
    this.inputNode = audioContext.createGain();
    this.leftGain = audioContext.createGain();
    this.rightGain = audioContext.createGain();
    this.channelMerger = audioContext.createChannelMerger(2);
    this.outputNode = this.channelMerger;
    this.inputNode.connect(this.leftGain);
    this.inputNode.connect(this.rightGain);
    this.leftGain.connect(this.channelMerger, 0, 0);
    this.rightGain.connect(this.channelMerger, 0, 1);
    this.initialized = true;
  }

  /**
   * Set the effect value
   * @param {number} value - the new value to set the effect to
   */
  _set(value) {
    this.value = value;

    // Map the scratch effect value (-100 to 100) to (0 to 1)
    const p = (value + 100) / 200;

    // Use trig functions for equal-loudness panning
    // See e.g. https://docs.cycling74.com/max7/tutorials/13_panningchapter01
    const leftVal = Math.cos(p * Math.PI / 2);
    const rightVal = Math.sin(p * Math.PI / 2);
    const {
      currentTime,
      DECAY_WAIT,
      DECAY_DURATION
    } = this.audioEngine;
    this.leftGain.gain.setTargetAtTime(leftVal, currentTime + DECAY_WAIT, DECAY_DURATION);
    this.rightGain.gain.setTargetAtTime(rightVal, currentTime + DECAY_WAIT, DECAY_DURATION);
  }

  /**
   * Clean up and disconnect audio nodes.
   */
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.inputNode.disconnect();
    this.leftGain.disconnect();
    this.rightGain.disconnect();
    this.channelMerger.disconnect();
    this.inputNode = null;
    this.leftGain = null;
    this.rightGain = null;
    this.channelMerger = null;
    this.outputNode = null;
    this.target = null;
    this.initialized = false;
  }
}
module.exports = PanEffect;

/***/ }),

/***/ "./node_modules/scratch-audio/src/effects/PitchEffect.js":
/*!***************************************************************!*\
  !*** ./node_modules/scratch-audio/src/effects/PitchEffect.js ***!
  \***************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Effect = __webpack_require__(/*! ./Effect */ "./node_modules/scratch-audio/src/effects/Effect.js");

/**
 * A pitch change effect, which changes the playback rate of the sound in order
 * to change its pitch: reducing the playback rate lowers the pitch, increasing
 * the rate raises the pitch. The duration of the sound is also changed.
 *
 * Changing the value of the pitch effect by 10 causes a change in pitch by 1
 * semitone (i.e. a musical half-step, such as the difference between C and C#)
 * Changing the pitch effect by 120 changes the pitch by one octave (12
 * semitones)
 *
 * The value of this effect is not clamped (i.e. it is typically between -120
 * and 120, but can be set much higher or much lower, with weird and fun
 * results). We should consider what extreme values to use for clamping it.
 *
 * Note that this effect functions differently from the other audio effects. It
 * is not part of a chain of audio nodes. Instead, it provides a way to set the
 * playback on one SoundPlayer or a group of them.
 */
class PitchEffect extends Effect {
  /**
   * @param {AudioEngine} audioEngine - audio engine this runs with
   * @param {AudioPlayer} audioPlayer - audio player this affects
   * @param {Effect} lastEffect - effect in the chain before this one
   * @constructor
   */
  constructor(audioEngine, audioPlayer, lastEffect) {
    super(audioEngine, audioPlayer, lastEffect);

    /**
     * The playback rate ratio
     * @type {Number}
     */
    this.ratio = 1;
  }

  /**
   * Return the name of the effect.
   * @type {string}
   */
  get name() {
    return 'pitch';
  }

  /**
   * Should the effect be connected to the audio graph?
   * @return {boolean} is the effect affecting the graph?
   */
  get _isPatch() {
    return false;
  }

  /**
   * Get the input node.
   * @return {AudioNode} - audio node that is the input for this effect
   */
  getInputNode() {
    return this.target.getInputNode();
  }

  /**
   * Initialize the Effect.
   * Effects start out uninitialized. Then initialize when they are first set
   * with some value.
   * @throws {Error} throws when left unimplemented
   */
  initialize() {
    this.initialized = true;
  }

  /**
   * Set the effect value.
   * @param {number} value - the new value to set the effect to
   */
  _set(value) {
    this.value = value;
    this.ratio = this.getRatio(this.value);
    this.updatePlayers(this.audioPlayer.getSoundPlayers());
  }

  /**
   * Update the effect for changes in the audioPlayer.
   */
  update() {
    this.updatePlayers(this.audioPlayer.getSoundPlayers());
  }

  /**
   * Compute the playback ratio for an effect value.
   * The playback ratio is scaled so that a change of 10 in the effect value
   * gives a change of 1 semitone in the ratio.
   * @param {number} val - an effect value
   * @returns {number} a playback ratio
   */
  getRatio(val) {
    const interval = val / 10;
    // Convert the musical interval in semitones to a frequency ratio
    return Math.pow(2, interval / 12);
  }

  /**
   * Update a sound player's playback rate using the current ratio for the
   * effect
   * @param {object} player - a SoundPlayer object
   */
  updatePlayer(player) {
    player.setPlaybackRate(this.ratio);
  }

  /**
   * Update a sound player's playback rate using the current ratio for the
   * effect
   * @param {object} players - a dictionary of SoundPlayer objects to update,
   *     indexed by md5
   */
  updatePlayers(players) {
    if (!players) return;
    for (const id in players) {
      if (Object.prototype.hasOwnProperty.call(players, id)) {
        this.updatePlayer(players[id]);
      }
    }
  }
}
module.exports = PitchEffect;

/***/ }),

/***/ "./node_modules/scratch-audio/src/effects/VolumeEffect.js":
/*!****************************************************************!*\
  !*** ./node_modules/scratch-audio/src/effects/VolumeEffect.js ***!
  \****************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const Effect = __webpack_require__(/*! ./Effect */ "./node_modules/scratch-audio/src/effects/Effect.js");

/**
 * Affect the volume of an effect chain.
 */
class VolumeEffect extends Effect {
  /**
   * Default value to set the Effect to when constructed and when clear'ed.
   * @const {number}
   */
  get DEFAULT_VALUE() {
    return 100;
  }

  /**
   * Return the name of the effect.
   * @type {string}
   */
  get name() {
    return 'volume';
  }

  /**
   * Initialize the Effect.
   * Effects start out uninitialized. Then initialize when they are first set
   * with some value.
   * @throws {Error} throws when left unimplemented
   */
  initialize() {
    this.inputNode = this.audioEngine.audioContext.createGain();
    this.outputNode = this.inputNode;
    this.initialized = true;
  }

  /**
   * Set the effects value.
   * @private
   * @param {number} value - new value to set effect to
   */
  _set(value) {
    this.value = value;
    const {
      gain
    } = this.outputNode;
    const {
      currentTime,
      DECAY_DURATION
    } = this.audioEngine;
    gain.linearRampToValueAtTime(value / 100, currentTime + DECAY_DURATION);
  }

  /**
   * Clean up and disconnect audio nodes.
   */
  dispose() {
    if (!this.initialized) {
      return;
    }
    this.outputNode.disconnect();
    this.inputNode = null;
    this.outputNode = null;
    this.target = null;
    this.initialized = false;
  }
}
module.exports = VolumeEffect;

/***/ }),

/***/ "./node_modules/scratch-audio/src/log.js":
/*!***********************************************!*\
  !*** ./node_modules/scratch-audio/src/log.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const minilog = __webpack_require__(/*! minilog */ "./node_modules/minilog/lib/web/index.js");
minilog.enable();
module.exports = minilog('scratch-audioengine');

/***/ }),

/***/ "./node_modules/scratch-audio/src/uid.js":
/*!***********************************************!*\
  !*** ./node_modules/scratch-audio/src/uid.js ***!
  \***********************************************/
/***/ ((module) => {

/**
 * @fileoverview UID generator, from Blockly.
 */

/**
 * Legal characters for the unique ID.
 * Should be all on a US keyboard.  No XML special characters or control codes.
 * Removed $ due to issue 251.
 * @private
 */
const soup_ = '!#%()*+,-./:;=?@[]^_`{|}~' + 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';

/**
 * Generate a unique ID, from Blockly.  This should be globally unique.
 * 87 characters ^ 20 length > 128 bits (better than a UUID).
 * @return {string} A globally unique ID string.
 */
const uid = function uid() {
  const length = 20;
  const soupLength = soup_.length;
  const id = [];
  for (let i = 0; i < length; i++) {
    id[i] = soup_.charAt(Math.random() * soupLength);
  }
  return id.join('');
};
module.exports = uid;

/***/ }),

/***/ "./node_modules/scratch-render/src/BitmapSkin.js":
/*!*******************************************************!*\
  !*** ./node_modules/scratch-render/src/BitmapSkin.js ***!
  \*******************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const Skin = __webpack_require__(/*! ./Skin */ "./node_modules/scratch-render/src/Skin.js");
class BitmapSkin extends Skin {
  /**
   * Create a new Bitmap Skin.
   * @extends Skin
   * @param {!int} id - The ID for this Skin.
   * @param {!RenderWebGL} renderer - The renderer which will use this skin.
   */
  constructor(id, renderer) {
    super(id);

    /** @type {!int} */
    this._costumeResolution = 1;

    /** @type {!RenderWebGL} */
    this._renderer = renderer;

    /** @type {Array<int>} */
    this._textureSize = [0, 0];
  }

  /**
   * Dispose of this object. Do not use it after calling this method.
   */
  dispose() {
    if (this._texture) {
      this._renderer.gl.deleteTexture(this._texture);
      this._texture = null;
    }
    super.dispose();
  }

  /**
   * @return {Array<number>} the "native" size, in texels, of this skin.
   */
  get size() {
    return [this._textureSize[0] / this._costumeResolution, this._textureSize[1] / this._costumeResolution];
  }

  /**
   * @param {Array<number>} scale - The scaling factors to be used.
   * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.
   */
  // eslint-disable-next-line no-unused-vars
  getTexture(scale) {
    return this._texture || super.getTexture();
  }

  /**
   * Set the contents of this skin to a snapshot of the provided bitmap data.
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.
   * @param {int} [costumeResolution=1] - The resolution to use for this bitmap.
   * @param {Array<number>} [rotationCenter] - Optional rotation center for the bitmap. If not supplied, it will be
   * calculated from the bounding box
   * @fires Skin.event:WasAltered
   */
  setBitmap(bitmapData, costumeResolution, rotationCenter) {
    if (!bitmapData.width || !bitmapData.height) {
      super.setEmptyImageData();
      return;
    }
    const gl = this._renderer.gl;

    // Preferably bitmapData is ImageData. ImageData speeds up updating
    // Silhouette and is better handled by more browsers in regards to
    // memory.
    let textureData = bitmapData;
    if (bitmapData instanceof HTMLCanvasElement) {
      // Given a HTMLCanvasElement get the image data to pass to webgl and
      // Silhouette.
      const context = bitmapData.getContext('2d');
      textureData = context.getImageData(0, 0, bitmapData.width, bitmapData.height);
    }
    if (this._texture === null) {
      const textureOptions = {
        auto: false,
        wrap: gl.CLAMP_TO_EDGE
      };
      this._texture = twgl.createTexture(gl, textureOptions);
    }
    this._setTexture(textureData);

    // Do these last in case any of the above throws an exception
    this._costumeResolution = costumeResolution || 2;
    this._textureSize = BitmapSkin._getBitmapSize(bitmapData);
    if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();
    this._rotationCenter[0] = rotationCenter[0];
    this._rotationCenter[1] = rotationCenter[1];
    this.emit(Skin.Events.WasAltered);
  }

  /**
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - bitmap data to inspect.
   * @returns {Array<int>} the width and height of the bitmap data, in pixels.
   * @private
   */
  static _getBitmapSize(bitmapData) {
    if (bitmapData instanceof HTMLImageElement) {
      return [bitmapData.naturalWidth || bitmapData.width, bitmapData.naturalHeight || bitmapData.height];
    }
    if (bitmapData instanceof HTMLVideoElement) {
      return [bitmapData.videoWidth || bitmapData.width, bitmapData.videoHeight || bitmapData.height];
    }

    // ImageData or HTMLCanvasElement
    return [bitmapData.width, bitmapData.height];
  }
}
module.exports = BitmapSkin;

/***/ }),

/***/ "./node_modules/scratch-render/src/Drawable.js":
/*!*****************************************************!*\
  !*** ./node_modules/scratch-render/src/Drawable.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const Rectangle = __webpack_require__(/*! ./Rectangle */ "./node_modules/scratch-render/src/Rectangle.js");
const RenderConstants = __webpack_require__(/*! ./RenderConstants */ "./node_modules/scratch-render/src/RenderConstants.js");
const ShaderManager = __webpack_require__(/*! ./ShaderManager */ "./node_modules/scratch-render/src/ShaderManager.js");
const Skin = __webpack_require__(/*! ./Skin */ "./node_modules/scratch-render/src/Skin.js");
const EffectTransform = __webpack_require__(/*! ./EffectTransform */ "./node_modules/scratch-render/src/EffectTransform.js");
const log = __webpack_require__(/*! ./util/log */ "./node_modules/scratch-render/src/util/log.js");

/**
 * An internal workspace for calculating texture locations from world vectors
 * this is REUSED for memory conservation reasons
 * @type {twgl.v3}
 */
const __isTouchingPosition = twgl.v3.create();
const FLOATING_POINT_ERROR_ALLOWANCE = 1e-6;

/**
 * Convert a scratch space location into a texture space float.  Uses the
 * internal __isTouchingPosition as a return value, so this should be copied
 * if you ever need to get two local positions and store both.  Requires that
 * the drawable inverseMatrix is up to date.
 *
 * @param {Drawable} drawable The drawable to get the inverse matrix and uniforms from
 * @param {twgl.v3} vec [x,y] scratch space vector
 * @return {twgl.v3} [x,y] texture space float vector - transformed by effects and matrix
 */
const getLocalPosition = (drawable, vec) => {
  // Transfrom from world coordinates to Drawable coordinates.
  const localPosition = __isTouchingPosition;
  const v0 = vec[0];
  const v1 = vec[1];
  const m = drawable._inverseMatrix;
  // var v2 = v[2];
  const d = v0 * m[3] + v1 * m[7] + m[15];
  // The RenderWebGL quad flips the texture's X axis. So rendered bottom
  // left is 1, 0 and the top right is 0, 1. Flip the X axis so
  // localPosition matches that transformation.
  localPosition[0] = 0.5 - (v0 * m[0] + v1 * m[4] + m[12]) / d;
  localPosition[1] = (v0 * m[1] + v1 * m[5] + m[13]) / d + 0.5;
  // Fix floating point issues near 0. Filed https://github.com/LLK/scratch-render/issues/688 that
  // they're happening in the first place.
  // TODO: Check if this can be removed after render pull 479 is merged
  if (Math.abs(localPosition[0]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[0] = 0;
  if (Math.abs(localPosition[1]) < FLOATING_POINT_ERROR_ALLOWANCE) localPosition[1] = 0;
  // Apply texture effect transform if the localPosition is within the drawable's space,
  // and any effects are currently active.
  if (drawable.enabledEffects !== 0 && localPosition[0] >= 0 && localPosition[0] < 1 && localPosition[1] >= 0 && localPosition[1] < 1) {
    EffectTransform.transformPoint(drawable, localPosition, localPosition);
  }
  return localPosition;
};
class Drawable {
  /**
   * An object which can be drawn by the renderer.
   * @todo double-buffer all rendering state (position, skin, effects, etc.)
   * @param {!int} id - This Drawable's unique ID.
   * @constructor
   */
  constructor(id) {
    /** @type {!int} */
    this._id = id;

    /**
     * The uniforms to be used by the vertex and pixel shaders.
     * Some of these are used by other parts of the renderer as well.
     * @type {Object.<string,*>}
     * @private
     */
    this._uniforms = {
      /**
       * The model matrix, to concat with projection at draw time.
       * @type {module:twgl/m4.Mat4}
       */
      u_modelMatrix: twgl.m4.identity(),
      /**
       * The color to use in the silhouette draw mode.
       * @type {Array<number>}
       */
      u_silhouetteColor: Drawable.color4fFromID(this._id)
    };

    // Effect values are uniforms too
    const numEffects = ShaderManager.EFFECTS.length;
    for (let index = 0; index < numEffects; ++index) {
      const effectName = ShaderManager.EFFECTS[index];
      const effectInfo = ShaderManager.EFFECT_INFO[effectName];
      const converter = effectInfo.converter;
      this._uniforms[effectInfo.uniformName] = converter(0);
    }
    this._position = twgl.v3.create(0, 0);
    this._scale = twgl.v3.create(100, 100);
    this._direction = 90;
    this._transformDirty = true;
    this._rotationMatrix = twgl.m4.identity();
    this._rotationTransformDirty = true;
    this._rotationAdjusted = twgl.v3.create();
    this._rotationCenterDirty = true;
    this._skinScale = twgl.v3.create(0, 0, 0);
    this._skinScaleDirty = true;
    this._inverseMatrix = twgl.m4.identity();
    this._inverseTransformDirty = true;
    this._visible = true;

    /** A bitmask identifying which effects are currently in use.
     * @readonly
     * @type {int} */
    this.enabledEffects = 0;

    /** @todo move convex hull functionality, maybe bounds functionality overall, to Skin classes */
    this._convexHullPoints = null;
    this._convexHullDirty = true;

    // The precise bounding box will be from the transformed convex hull points,
    // so initialize the array of transformed hull points in setConvexHullPoints.
    // Initializing it once per convex hull recalculation avoids unnecessary creation of twgl.v3 objects.
    this._transformedHullPoints = null;
    this._transformedHullDirty = true;
    this._skinWasAltered = this._skinWasAltered.bind(this);
    this.isTouching = this._isTouchingNever;
  }

  /**
   * Dispose of this Drawable. Do not use it after calling this method.
   */
  dispose() {
    // Use the setter: disconnect events
    this.skin = null;
  }

  /**
   * Mark this Drawable's transform as dirty.
   * It will be recalculated next time it's needed.
   */
  setTransformDirty() {
    this._transformDirty = true;
    this._inverseTransformDirty = true;
    this._transformedHullDirty = true;
  }

  /**
   * @returns {number} The ID for this Drawable.
   */
  get id() {
    return this._id;
  }

  /**
   * @returns {Skin} the current skin for this Drawable.
   */
  get skin() {
    return this._skin;
  }

  /**
   * @param {Skin} newSkin - A new Skin for this Drawable.
   */
  set skin(newSkin) {
    if (this._skin !== newSkin) {
      if (this._skin) {
        this._skin.removeListener(Skin.Events.WasAltered, this._skinWasAltered);
      }
      this._skin = newSkin;
      if (this._skin) {
        this._skin.addListener(Skin.Events.WasAltered, this._skinWasAltered);
      }
      this._skinWasAltered();
    }
  }

  /**
   * @returns {Array<number>} the current scaling percentages applied to this Drawable. [100,100] is normal size.
   */
  get scale() {
    return [this._scale[0], this._scale[1]];
  }

  /**
   * @returns {object.<string, *>} the shader uniforms to be used when rendering this Drawable.
   */
  getUniforms() {
    if (this._transformDirty) {
      this._calculateTransform();
    }
    return this._uniforms;
  }

  /**
   * @returns {boolean} whether this Drawable is visible.
   */
  getVisible() {
    return this._visible;
  }

  /**
   * Update the position if it is different. Marks the transform as dirty.
   * @param {Array.<number>} position A new position.
   */
  updatePosition(position) {
    if (this._position[0] !== position[0] || this._position[1] !== position[1]) {
      this._position[0] = Math.round(position[0]);
      this._position[1] = Math.round(position[1]);
      this.setTransformDirty();
    }
  }

  /**
   * Update the direction if it is different. Marks the transform as dirty.
   * @param {number} direction A new direction.
   */
  updateDirection(direction) {
    if (this._direction !== direction) {
      this._direction = direction;
      this._rotationTransformDirty = true;
      this.setTransformDirty();
    }
  }

  /**
   * Update the scale if it is different. Marks the transform as dirty.
   * @param {Array.<number>} scale A new scale.
   */
  updateScale(scale) {
    if (this._scale[0] !== scale[0] || this._scale[1] !== scale[1]) {
      this._scale[0] = scale[0];
      this._scale[1] = scale[1];
      this._rotationCenterDirty = true;
      this._skinScaleDirty = true;
      this.setTransformDirty();
    }
  }

  /**
   * Update visibility if it is different. Marks the convex hull as dirty.
   * @param {boolean} visible A new visibility state.
   */
  updateVisible(visible) {
    if (this._visible !== visible) {
      this._visible = visible;
      this.setConvexHullDirty();
    }
  }

  /**
   * Update an effect. Marks the convex hull as dirty if the effect changes shape.
   * @param {string} effectName The name of the effect.
   * @param {number} rawValue A new effect value.
   */
  updateEffect(effectName, rawValue) {
    const effectInfo = ShaderManager.EFFECT_INFO[effectName];
    if (rawValue) {
      this.enabledEffects |= effectInfo.mask;
    } else {
      this.enabledEffects &= ~effectInfo.mask;
    }
    const converter = effectInfo.converter;
    this._uniforms[effectInfo.uniformName] = converter(rawValue);
    if (effectInfo.shapeChanges) {
      this.setConvexHullDirty();
    }
  }

  /**
   * Update the position, direction, scale, or effect properties of this Drawable.
   * @deprecated Use specific update* methods instead.
   * @param {object.<string,*>} properties The new property values to set.
   */
  updateProperties(properties) {
    if ('position' in properties) {
      this.updatePosition(properties.position);
    }
    if ('direction' in properties) {
      this.updateDirection(properties.direction);
    }
    if ('scale' in properties) {
      this.updateScale(properties.scale);
    }
    if ('visible' in properties) {
      this.updateVisible(properties.visible);
    }
    const numEffects = ShaderManager.EFFECTS.length;
    for (let index = 0; index < numEffects; ++index) {
      const effectName = ShaderManager.EFFECTS[index];
      if (effectName in properties) {
        this.updateEffect(effectName, properties[effectName]);
      }
    }
  }

  /**
   * Calculate the transform to use when rendering this Drawable.
   * @private
   */
  _calculateTransform() {
    if (this._rotationTransformDirty) {
      const rotation = (270 - this._direction) * Math.PI / 180;

      // Calling rotationZ sets the destination matrix to a rotation
      // around the Z axis setting matrix components 0, 1, 4 and 5 with
      // cosine and sine values of the rotation.
      // twgl.m4.rotationZ(rotation, this._rotationMatrix);

      // twgl assumes the last value set to the matrix was anything.
      // Drawable knows, it was another rotationZ matrix, so we can skip
      // assigning the values that will never change.
      const c = Math.cos(rotation);
      const s = Math.sin(rotation);
      this._rotationMatrix[0] = c;
      this._rotationMatrix[1] = s;
      // this._rotationMatrix[2] = 0;
      // this._rotationMatrix[3] = 0;
      this._rotationMatrix[4] = -s;
      this._rotationMatrix[5] = c;
      // this._rotationMatrix[6] = 0;
      // this._rotationMatrix[7] = 0;
      // this._rotationMatrix[8] = 0;
      // this._rotationMatrix[9] = 0;
      // this._rotationMatrix[10] = 1;
      // this._rotationMatrix[11] = 0;
      // this._rotationMatrix[12] = 0;
      // this._rotationMatrix[13] = 0;
      // this._rotationMatrix[14] = 0;
      // this._rotationMatrix[15] = 1;

      this._rotationTransformDirty = false;
    }

    // Adjust rotation center relative to the skin.
    if (this._rotationCenterDirty && this.skin !== null) {
      // twgl version of the following in function work.
      // let rotationAdjusted = twgl.v3.subtract(
      //     this.skin.rotationCenter,
      //     twgl.v3.divScalar(this.skin.size, 2, this._rotationAdjusted),
      //     this._rotationAdjusted
      // );
      // rotationAdjusted = twgl.v3.multiply(
      //     rotationAdjusted, this._scale, rotationAdjusted
      // );
      // rotationAdjusted = twgl.v3.divScalar(
      //     rotationAdjusted, 100, rotationAdjusted
      // );
      // rotationAdjusted[1] *= -1; // Y flipped to Scratch coordinate.
      // rotationAdjusted[2] = 0; // Z coordinate is 0.

      // Locally assign rotationCenter and skinSize to keep from having
      // the Skin getter properties called twice while locally assigning
      // their components for readability.
      const rotationCenter = this.skin.rotationCenter;
      const skinSize = this.skin.size;
      const center0 = rotationCenter[0];
      const center1 = rotationCenter[1];
      const skinSize0 = skinSize[0];
      const skinSize1 = skinSize[1];
      const scale0 = this._scale[0];
      const scale1 = this._scale[1];
      const rotationAdjusted = this._rotationAdjusted;
      rotationAdjusted[0] = (center0 - skinSize0 / 2) * scale0 / 100;
      rotationAdjusted[1] = (center1 - skinSize1 / 2) * scale1 / 100 * -1;
      // rotationAdjusted[2] = 0;

      this._rotationCenterDirty = false;
    }
    if (this._skinScaleDirty && this.skin !== null) {
      // twgl version of the following in function work.
      // const scaledSize = twgl.v3.divScalar(
      //     twgl.v3.multiply(this.skin.size, this._scale),
      //     100
      // );
      // // was NaN because the vectors have only 2 components.
      // scaledSize[2] = 0;

      // Locally assign skinSize to keep from having the Skin getter
      // properties called twice.
      const skinSize = this.skin.size;
      const scaledSize = this._skinScale;
      scaledSize[0] = skinSize[0] * this._scale[0] / 100;
      scaledSize[1] = skinSize[1] * this._scale[1] / 100;
      // scaledSize[2] = 0;

      this._skinScaleDirty = false;
    }
    const modelMatrix = this._uniforms.u_modelMatrix;

    // twgl version of the following in function work.
    // twgl.m4.identity(modelMatrix);
    // twgl.m4.translate(modelMatrix, this._position, modelMatrix);
    // twgl.m4.multiply(modelMatrix, this._rotationMatrix, modelMatrix);
    // twgl.m4.translate(modelMatrix, this._rotationAdjusted, modelMatrix);
    // twgl.m4.scale(modelMatrix, scaledSize, modelMatrix);

    // Drawable configures a 3D matrix for drawing in WebGL, but most values
    // will never be set because the inputs are on the X and Y position axis
    // and the Z rotation axis. Drawable can bring the work inside
    // _calculateTransform and greatly reduce the ammount of math and array
    // assignments needed.

    const scale0 = this._skinScale[0];
    const scale1 = this._skinScale[1];
    const rotation00 = this._rotationMatrix[0];
    const rotation01 = this._rotationMatrix[1];
    const rotation10 = this._rotationMatrix[4];
    const rotation11 = this._rotationMatrix[5];
    const adjusted0 = this._rotationAdjusted[0];
    const adjusted1 = this._rotationAdjusted[1];
    const position0 = this._position[0];
    const position1 = this._position[1];

    // Commented assignments show what the values are when the matrix was
    // instantiated. Those values will never change so they do not need to
    // be reassigned.
    modelMatrix[0] = scale0 * rotation00;
    modelMatrix[1] = scale0 * rotation01;
    // modelMatrix[2] = 0;
    // modelMatrix[3] = 0;
    modelMatrix[4] = scale1 * rotation10;
    modelMatrix[5] = scale1 * rotation11;
    // modelMatrix[6] = 0;
    // modelMatrix[7] = 0;
    // modelMatrix[8] = 0;
    // modelMatrix[9] = 0;
    // modelMatrix[10] = 1;
    // modelMatrix[11] = 0;
    modelMatrix[12] = rotation00 * adjusted0 + rotation10 * adjusted1 + position0;
    modelMatrix[13] = rotation01 * adjusted0 + rotation11 * adjusted1 + position1;
    // modelMatrix[14] = 0;
    // modelMatrix[15] = 1;

    this._transformDirty = false;
  }

  /**
   * Whether the Drawable needs convex hull points provided by the renderer.
   * @return {boolean} True when no convex hull known, or it's dirty.
   */
  needsConvexHullPoints() {
    return !this._convexHullPoints || this._convexHullDirty || this._convexHullPoints.length === 0;
  }

  /**
   * Set the convex hull to be dirty.
   * Do this whenever the Drawable's shape has possibly changed.
   */
  setConvexHullDirty() {
    this._convexHullDirty = true;
  }

  /**
   * Set the convex hull points for the Drawable.
   * @param {Array<Array<number>>} points Convex hull points, as [[x, y], ...]
   */
  setConvexHullPoints(points) {
    this._convexHullPoints = points;
    this._convexHullDirty = false;

    // Re-create the "transformed hull points" array.
    // We only do this when the hull points change to avoid unnecessary allocations and GC.
    this._transformedHullPoints = [];
    for (let i = 0; i < points.length; i++) {
      this._transformedHullPoints.push(twgl.v3.create());
    }
    this._transformedHullDirty = true;
  }

  /**
   * @function
   * @name isTouching
   * Check if the world position touches the skin.
   * The caller is responsible for ensuring this drawable's inverse matrix & its skin's silhouette are up-to-date.
   * @see updateCPURenderAttributes
   * @param {twgl.v3} vec World coordinate vector.
   * @return {boolean} True if the world position touches the skin.
   */

  // `updateCPURenderAttributes` sets this Drawable instance's `isTouching` method
  // to one of the following three functions:
  // If this drawable has no skin, set it to `_isTouchingNever`.
  // Otherwise, if this drawable uses nearest-neighbor scaling at its current scale, set it to `_isTouchingNearest`.
  // Otherwise, set it to `_isTouchingLinear`.
  // This allows several checks to be moved from the `isTouching` function to `updateCPURenderAttributes`.

  // eslint-disable-next-line no-unused-vars
  _isTouchingNever(vec) {
    return false;
  }
  _isTouchingNearest(vec) {
    return this.skin.isTouchingNearest(getLocalPosition(this, vec));
  }
  _isTouchingLinear(vec) {
    return this.skin.isTouchingLinear(getLocalPosition(this, vec));
  }

  /**
   * Get the precise bounds for a Drawable.
   * This function applies the transform matrix to the known convex hull,
   * and then finds the minimum box along the axes.
   * Before calling this, ensure the renderer has updated convex hull points.
   * @param {?Rectangle} result optional destination for bounds calculation
   * @return {!Rectangle} Bounds for a tight box around the Drawable.
   */
  getBounds(result) {
    if (this.needsConvexHullPoints()) {
      throw new Error('Needs updated convex hull points before bounds calculation.');
    }
    if (this._transformDirty) {
      this._calculateTransform();
    }
    const transformedHullPoints = this._getTransformedHullPoints();
    // Search through transformed points to generate box on axes.
    result = result || new Rectangle();
    result.initFromPointsAABB(transformedHullPoints);
    return result;
  }

  /**
   * Get the precise bounds for the upper 8px slice of the Drawable.
   * Used for calculating where to position a text bubble.
   * Before calling this, ensure the renderer has updated convex hull points.
   * @param {?Rectangle} result optional destination for bounds calculation
   * @return {!Rectangle} Bounds for a tight box around a slice of the Drawable.
   */
  getBoundsForBubble(result) {
    if (this.needsConvexHullPoints()) {
      throw new Error('Needs updated convex hull points before bubble bounds calculation.');
    }
    if (this._transformDirty) {
      this._calculateTransform();
    }
    const slice = 8; // px, how tall the top slice to measure should be.
    const transformedHullPoints = this._getTransformedHullPoints();
    const maxY = Math.max.apply(null, transformedHullPoints.map(p => p[1]));
    const filteredHullPoints = transformedHullPoints.filter(p => p[1] > maxY - slice);
    // Search through filtered points to generate box on axes.
    result = result || new Rectangle();
    result.initFromPointsAABB(filteredHullPoints);
    return result;
  }

  /**
   * Get the rough axis-aligned bounding box for the Drawable.
   * Calculated by transforming the skin's bounds.
   * Note that this is less precise than the box returned by `getBounds`,
   * which is tightly snapped to account for a Drawable's transparent regions.
   * `getAABB` returns a much less accurate bounding box, but will be much
   * faster to calculate so may be desired for quick checks/optimizations.
   * @param {?Rectangle} result optional destination for bounds calculation
   * @return {!Rectangle} Rough axis-aligned bounding box for Drawable.
   */
  getAABB(result) {
    if (this._transformDirty) {
      this._calculateTransform();
    }
    const tm = this._uniforms.u_modelMatrix;
    result = result || new Rectangle();
    result.initFromModelMatrix(tm);
    return result;
  }

  /**
   * Return the best Drawable bounds possible without performing graphics queries.
   * I.e., returns the tight bounding box when the convex hull points are already
   * known, but otherwise return the rough AABB of the Drawable.
   * @param {?Rectangle} result optional destination for bounds calculation
   * @return {!Rectangle} Bounds for the Drawable.
   */
  getFastBounds(result) {
    if (!this.needsConvexHullPoints()) {
      return this.getBounds(result);
    }
    return this.getAABB(result);
  }

  /**
   * Transform all the convex hull points by the current Drawable's
   * transform. This allows us to skip recalculating the convex hull
   * for many Drawable updates, including translation, rotation, scaling.
   * @return {!Array.<!Array.number>} Array of glPoints which are Array<x, y>
   * @private
   */
  _getTransformedHullPoints() {
    if (!this._transformedHullDirty) {
      return this._transformedHullPoints;
    }
    const projection = twgl.m4.ortho(-1, 1, -1, 1, -1, 1);
    const skinSize = this.skin.size;
    const halfXPixel = 1 / skinSize[0] / 2;
    const halfYPixel = 1 / skinSize[1] / 2;
    const tm = twgl.m4.multiply(this._uniforms.u_modelMatrix, projection);
    for (let i = 0; i < this._convexHullPoints.length; i++) {
      const point = this._convexHullPoints[i];
      const dstPoint = this._transformedHullPoints[i];
      dstPoint[0] = 0.5 + -point[0] / skinSize[0] - halfXPixel;
      dstPoint[1] = point[1] / skinSize[1] - 0.5 + halfYPixel;
      twgl.m4.transformPoint(tm, dstPoint, dstPoint);
    }
    this._transformedHullDirty = false;
    return this._transformedHullPoints;
  }

  /**
   * Update the transform matrix and calculate it's inverse for collision
   * and local texture position purposes.
   */
  updateMatrix() {
    if (this._transformDirty) {
      this._calculateTransform();
    }
    // Get the inverse of the model matrix or update it.
    if (this._inverseTransformDirty) {
      const inverse = this._inverseMatrix;
      twgl.m4.copy(this._uniforms.u_modelMatrix, inverse);
      // The normal matrix uses a z scaling of 0 causing model[10] to be
      // 0. Getting a 4x4 inverse is impossible without a scaling in x, y,
      // and z.
      inverse[10] = 1;
      twgl.m4.inverse(inverse, inverse);
      this._inverseTransformDirty = false;
    }
  }

  /**
   * Update everything necessary to render this drawable on the CPU.
   */
  updateCPURenderAttributes() {
    this.updateMatrix();
    // CPU rendering always occurs at the "native" size, so no need to scale up this._scale
    if (this.skin) {
      this.skin.updateSilhouette(this._scale);
      if (this.skin.useNearest(this._scale, this)) {
        this.isTouching = this._isTouchingNearest;
      } else {
        this.isTouching = this._isTouchingLinear;
      }
    } else {
      log.warn("Could not find skin for drawable with id: ".concat(this._id));
      this.isTouching = this._isTouchingNever;
    }
  }

  /**
   * Respond to an internal change in the current Skin.
   * @private
   */
  _skinWasAltered() {
    this._rotationCenterDirty = true;
    this._skinScaleDirty = true;
    this.setConvexHullDirty();
    this.setTransformDirty();
  }

  /**
   * Calculate a color to represent the given ID number. At least one component of
   * the resulting color will be non-zero if the ID is not RenderConstants.ID_NONE.
   * @param {int} id The ID to convert.
   * @returns {Array<number>} An array of [r,g,b,a], each component in the range [0,1].
   */
  static color4fFromID(id) {
    id -= RenderConstants.ID_NONE;
    const r = (id >> 0 & 255) / 255.0;
    const g = (id >> 8 & 255) / 255.0;
    const b = (id >> 16 & 255) / 255.0;
    return [r, g, b, 1.0];
  }

  /**
   * Calculate the ID number represented by the given color. If all components of
   * the color are zero, the result will be RenderConstants.ID_NONE; otherwise the result
   * will be a valid ID.
   * @param {int} r The red value of the color, in the range [0,255].
   * @param {int} g The green value of the color, in the range [0,255].
   * @param {int} b The blue value of the color, in the range [0,255].
   * @returns {int} The ID represented by that color.
   */
  static color3bToID(r, g, b) {
    let id;
    id = (r & 255) << 0;
    id |= (g & 255) << 8;
    id |= (b & 255) << 16;
    return id + RenderConstants.ID_NONE;
  }

  /**
   * Sample a color from a drawable's texture.
   * The caller is responsible for ensuring this drawable's inverse matrix & its skin's silhouette are up-to-date.
   * @see updateCPURenderAttributes
   * @param {twgl.v3} vec The scratch space [x,y] vector
   * @param {Drawable} drawable The drawable to sample the texture from
   * @param {Uint8ClampedArray} dst The "color4b" representation of the texture at point.
   * @param {number} [effectMask] A bitmask for which effects to use. Optional.
   * @returns {Uint8ClampedArray} The dst object filled with the color4b
   */
  static sampleColor4b(vec, drawable, dst, effectMask) {
    const localPosition = getLocalPosition(drawable, vec);
    if (localPosition[0] < 0 || localPosition[1] < 0 || localPosition[0] > 1 || localPosition[1] > 1) {
      dst[0] = 0;
      dst[1] = 0;
      dst[2] = 0;
      dst[3] = 0;
      return dst;
    }
    const textColor =
    // commenting out to only use nearest for now
    // drawable.skin.useNearest(drawable._scale, drawable) ?
    drawable.skin._silhouette.colorAtNearest(localPosition, dst);
    // : drawable.skin._silhouette.colorAtLinear(localPosition, dst);

    if (drawable.enabledEffects === 0) return textColor;
    return EffectTransform.transformColor(drawable, textColor, effectMask);
  }
}
module.exports = Drawable;

/***/ }),

/***/ "./node_modules/scratch-render/src/EffectTransform.js":
/*!************************************************************!*\
  !*** ./node_modules/scratch-render/src/EffectTransform.js ***!
  \************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileoverview
 * A utility to transform a texture coordinate to another texture coordinate
 * representing how the shaders apply effects.
 */

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const {
  rgbToHsv,
  hsvToRgb
} = __webpack_require__(/*! ./util/color-conversions */ "./node_modules/scratch-render/src/util/color-conversions.js");
const ShaderManager = __webpack_require__(/*! ./ShaderManager */ "./node_modules/scratch-render/src/ShaderManager.js");

/**
 * A texture coordinate is between 0 and 1. 0.5 is the center position.
 * @const {number}
 */
const CENTER_X = 0.5;

/**
 * A texture coordinate is between 0 and 1. 0.5 is the center position.
 * @const {number}
 */
const CENTER_Y = 0.5;

/**
 * Reused memory location for storing an HSV color value.
 * @type {Array<number>}
 */
const __hsv = [0, 0, 0];
class EffectTransform {
  /**
   * Transform a color in-place given the drawable's effect uniforms.  Will apply
   * Ghost and Color and Brightness effects.
   * @param {Drawable} drawable The drawable to get uniforms from.
   * @param {Uint8ClampedArray} inOutColor The color to transform.
   * @param {number} [effectMask] A bitmask for which effects to use. Optional.
   * @returns {Uint8ClampedArray} dst filled with the transformed color
   */
  static transformColor(drawable, inOutColor, effectMask) {
    // If the color is fully transparent, don't bother attempting any transformations.
    if (inOutColor[3] === 0) {
      return inOutColor;
    }
    let effects = drawable.enabledEffects;
    if (typeof effectMask === 'number') effects &= effectMask;
    const uniforms = drawable.getUniforms();
    const enableColor = (effects & ShaderManager.EFFECT_INFO.color.mask) !== 0;
    const enableBrightness = (effects & ShaderManager.EFFECT_INFO.brightness.mask) !== 0;
    if (enableColor || enableBrightness) {
      // gl_FragColor.rgb /= gl_FragColor.a + epsilon;
      // Here, we're dividing by the (previously pre-multiplied) alpha to ensure HSV is properly calculated
      // for partially transparent pixels.
      // epsilon is present in the shader because dividing by 0 (fully transparent pixels) messes up calculations.
      // We're doing this with a Uint8ClampedArray here, so dividing by 0 just gives 255. We're later multiplying
      // by 0 again, so it won't affect results.
      const alpha = inOutColor[3] / 255;
      inOutColor[0] /= alpha;
      inOutColor[1] /= alpha;
      inOutColor[2] /= alpha;
      if (enableColor) {
        // vec3 hsv = convertRGB2HSV(gl_FragColor.xyz);
        const hsv = rgbToHsv(inOutColor, __hsv);

        // this code forces grayscale values to be slightly saturated
        // so that some slight change of hue will be visible
        // const float minLightness = 0.11 / 2.0;
        const minV = 0.11 / 2.0;
        // const float minSaturation = 0.09;
        const minS = 0.09;
        // if (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);
        if (hsv[2] < minV) {
          hsv[0] = 0;
          hsv[1] = 1;
          hsv[2] = minV;
          // else if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);
        } else if (hsv[1] < minS) {
          hsv[0] = 0;
          hsv[1] = minS;
        }

        // hsv.x = mod(hsv.x + u_color, 1.0);
        // if (hsv.x < 0.0) hsv.x += 1.0;
        hsv[0] = uniforms.u_color + hsv[0] + 1;

        // gl_FragColor.rgb = convertHSV2RGB(hsl);
        hsvToRgb(hsv, inOutColor);
      }
      if (enableBrightness) {
        const brightness = uniforms.u_brightness * 255;
        // gl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));
        // We don't need to clamp because the Uint8ClampedArray does that for us
        inOutColor[0] += brightness;
        inOutColor[1] += brightness;
        inOutColor[2] += brightness;
      }

      // gl_FragColor.rgb *= gl_FragColor.a + epsilon;
      // Now we're doing the reverse, premultiplying by the alpha once again.
      inOutColor[0] *= alpha;
      inOutColor[1] *= alpha;
      inOutColor[2] *= alpha;
    }
    if ((effects & ShaderManager.EFFECT_INFO.ghost.mask) !== 0) {
      // gl_FragColor *= u_ghost
      inOutColor[0] *= uniforms.u_ghost;
      inOutColor[1] *= uniforms.u_ghost;
      inOutColor[2] *= uniforms.u_ghost;
      inOutColor[3] *= uniforms.u_ghost;
    }
    return inOutColor;
  }

  /**
   * Transform a texture coordinate to one that would be select after applying shader effects.
   * @param {Drawable} drawable The drawable whose effects to emulate.
   * @param {twgl.v3} vec The texture coordinate to transform.
   * @param {twgl.v3} dst A place to store the output coordinate.
   * @return {twgl.v3} dst - The coordinate after being transform by effects.
   */
  static transformPoint(drawable, vec, dst) {
    twgl.v3.copy(vec, dst);
    const effects = drawable.enabledEffects;
    const uniforms = drawable.getUniforms();
    if ((effects & ShaderManager.EFFECT_INFO.mosaic.mask) !== 0) {
      // texcoord0 = fract(u_mosaic * texcoord0);
      dst[0] = uniforms.u_mosaic * dst[0] % 1;
      dst[1] = uniforms.u_mosaic * dst[1] % 1;
    }
    if ((effects & ShaderManager.EFFECT_INFO.pixelate.mask) !== 0) {
      const skinUniforms = drawable.skin.getUniforms();
      // vec2 pixelTexelSize = u_skinSize / u_pixelate;
      const texelX = skinUniforms.u_skinSize[0] / uniforms.u_pixelate;
      const texelY = skinUniforms.u_skinSize[1] / uniforms.u_pixelate;
      // texcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) /
      //   pixelTexelSize;
      dst[0] = (Math.floor(dst[0] * texelX) + CENTER_X) / texelX;
      dst[1] = (Math.floor(dst[1] * texelY) + CENTER_Y) / texelY;
    }
    if ((effects & ShaderManager.EFFECT_INFO.whirl.mask) !== 0) {
      // const float kRadius = 0.5;
      const RADIUS = 0.5;
      // vec2 offset = texcoord0 - kCenter;
      const offsetX = dst[0] - CENTER_X;
      const offsetY = dst[1] - CENTER_Y;
      // float offsetMagnitude = length(offset);
      const offsetMagnitude = Math.sqrt(Math.pow(offsetX, 2) + Math.pow(offsetY, 2));
      // float whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);
      const whirlFactor = Math.max(1.0 - offsetMagnitude / RADIUS, 0.0);
      // float whirlActual = u_whirl * whirlFactor * whirlFactor;
      const whirlActual = uniforms.u_whirl * whirlFactor * whirlFactor;
      // float sinWhirl = sin(whirlActual);
      const sinWhirl = Math.sin(whirlActual);
      // float cosWhirl = cos(whirlActual);
      const cosWhirl = Math.cos(whirlActual);
      // mat2 rotationMatrix = mat2(
      //     cosWhirl, -sinWhirl,
      //     sinWhirl, cosWhirl
      // );
      const rot1 = cosWhirl;
      const rot2 = -sinWhirl;
      const rot3 = sinWhirl;
      const rot4 = cosWhirl;

      // texcoord0 = rotationMatrix * offset + kCenter;
      dst[0] = rot1 * offsetX + rot3 * offsetY + CENTER_X;
      dst[1] = rot2 * offsetX + rot4 * offsetY + CENTER_Y;
    }
    if ((effects & ShaderManager.EFFECT_INFO.fisheye.mask) !== 0) {
      // vec2 vec = (texcoord0 - kCenter) / kCenter;
      const vX = (dst[0] - CENTER_X) / CENTER_X;
      const vY = (dst[1] - CENTER_Y) / CENTER_Y;
      // float vecLength = length(vec);
      const vLength = Math.sqrt(vX * vX + vY * vY);
      // float r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);
      const r = Math.pow(Math.min(vLength, 1), uniforms.u_fisheye) * Math.max(1, vLength);
      // vec2 unit = vec / vecLength;
      const unitX = vX / vLength;
      const unitY = vY / vLength;
      // texcoord0 = kCenter + r * unit * kCenter;
      dst[0] = CENTER_X + r * unitX * CENTER_X;
      dst[1] = CENTER_Y + r * unitY * CENTER_Y;
    }
    return dst;
  }
}
module.exports = EffectTransform;

/***/ }),

/***/ "./node_modules/scratch-render/src/PenSkin.js":
/*!****************************************************!*\
  !*** ./node_modules/scratch-render/src/PenSkin.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const RenderConstants = __webpack_require__(/*! ./RenderConstants */ "./node_modules/scratch-render/src/RenderConstants.js");
const Skin = __webpack_require__(/*! ./Skin */ "./node_modules/scratch-render/src/Skin.js");
const ShaderManager = __webpack_require__(/*! ./ShaderManager */ "./node_modules/scratch-render/src/ShaderManager.js");

/**
 * Attributes to use when drawing with the pen
 * @typedef {object} PenSkin#PenAttributes
 * @property {number} [diameter] - The size (diameter) of the pen.
 * @property {Array<number>} [color4f] - The pen color as an array of [r,g,b,a], each component in the range [0,1].
 */

/**
 * The pen attributes to use when unspecified.
 * @type {PenSkin#PenAttributes}
 * @memberof PenSkin
 * @private
 * @const
 */
const DefaultPenAttributes = {
  color4f: [0, 0, 1, 1],
  diameter: 1
};

/**
 * Reused memory location for storing a premultiplied pen color.
 * @type {FloatArray}
 */
const __premultipliedColor = [0, 0, 0, 0];
class PenSkin extends Skin {
  /**
   * Create a Skin which implements a Scratch pen layer.
   * @param {int} id - The unique ID for this Skin.
   * @param {RenderWebGL} renderer - The renderer which will use this Skin.
   * @extends Skin
   * @listens RenderWebGL#event:NativeSizeChanged
   */
  constructor(id, renderer) {
    super(id);

    /**
     * @private
     * @type {RenderWebGL}
     */
    this._renderer = renderer;

    /** @type {Array<number>} */
    this._size = null;

    /** @type {WebGLFramebuffer} */
    this._framebuffer = null;

    /** @type {boolean} */
    this._silhouetteDirty = false;

    /** @type {Uint8Array} */
    this._silhouettePixels = null;

    /** @type {ImageData} */
    this._silhouetteImageData = null;

    /** @type {object} */
    this._lineOnBufferDrawRegionId = {
      enter: () => this._enterDrawLineOnBuffer(),
      exit: () => this._exitDrawLineOnBuffer()
    };

    /** @type {object} */
    this._usePenBufferDrawRegionId = {
      enter: () => this._enterUsePenBuffer(),
      exit: () => this._exitUsePenBuffer()
    };

    /** @type {twgl.BufferInfo} */
    this._lineBufferInfo = twgl.createBufferInfoFromArrays(this._renderer.gl, {
      a_position: {
        numComponents: 2,
        data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]
      }
    });
    const NO_EFFECTS = 0;
    /** @type {twgl.ProgramInfo} */
    this._lineShader = this._renderer._shaderManager.getShader(ShaderManager.DRAW_MODE.line, NO_EFFECTS);
    this.onNativeSizeChanged = this.onNativeSizeChanged.bind(this);
    this._renderer.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);
    this._setCanvasSize(renderer.getNativeSize());
  }

  /**
   * Dispose of this object. Do not use it after calling this method.
   */
  dispose() {
    this._renderer.removeListener(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);
    this._renderer.gl.deleteTexture(this._texture);
    this._texture = null;
    super.dispose();
  }

  /**
   * @return {Array<number>} the "native" size, in texels, of this skin. [width, height]
   */
  get size() {
    return this._size;
  }
  useNearest(scale) {
    // Use nearest-neighbor interpolation when scaling up the pen skin-- this matches Scratch 2.0.
    // When scaling it down, use linear interpolation to avoid giving pen lines a "dashed" appearance.
    return Math.max(scale[0], scale[1]) >= 100;
  }

  /**
   * @param {Array<number>} scale The X and Y scaling factors to be used, as percentages of this skin's "native" size.
   * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.
   */
  // eslint-disable-next-line no-unused-vars
  getTexture(scale) {
    return this._texture;
  }

  /**
   * Clear the pen layer.
   */
  clear() {
    this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);

    /* Reset framebuffer to transparent black */
    const gl = this._renderer.gl;
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this._silhouetteDirty = true;
  }

  /**
   * Draw a point on the pen layer.
   * @param {PenAttributes} penAttributes - how the point should be drawn.
   * @param {number} x - the X coordinate of the point to draw.
   * @param {number} y - the Y coordinate of the point to draw.
   */
  drawPoint(penAttributes, x, y) {
    this.drawLine(penAttributes, x, y, x, y);
  }

  /**
   * Draw a line on the pen layer.
   * @param {PenAttributes} penAttributes - how the line should be drawn.
   * @param {number} x0 - the X coordinate of the beginning of the line.
   * @param {number} y0 - the Y coordinate of the beginning of the line.
   * @param {number} x1 - the X coordinate of the end of the line.
   * @param {number} y1 - the Y coordinate of the end of the line.
   */
  drawLine(penAttributes, x0, y0, x1, y1) {
    // For compatibility with Scratch 2.0, offset pen lines of width 1 and 3 so they're pixel-aligned.
    // See https://github.com/LLK/scratch-render/pull/314
    const diameter = penAttributes.diameter || DefaultPenAttributes.diameter;
    const offset = diameter === 1 || diameter === 3 ? 0.5 : 0;
    this._drawLineOnBuffer(penAttributes, x0 + offset, y0 + offset, x1 + offset, y1 + offset);
    this._silhouetteDirty = true;
  }

  /**
   * Prepare to draw lines in the _lineOnBufferDrawRegionId region.
   */
  _enterDrawLineOnBuffer() {
    const gl = this._renderer.gl;
    twgl.bindFramebufferInfo(gl, this._framebuffer);
    gl.viewport(0, 0, this._size[0], this._size[1]);
    const currentShader = this._lineShader;
    gl.useProgram(currentShader.program);
    twgl.setBuffersAndAttributes(gl, currentShader, this._lineBufferInfo);
    const uniforms = {
      u_skin: this._texture,
      u_stageSize: this._size
    };
    twgl.setUniforms(currentShader, uniforms);
  }

  /**
   * Return to a base state from _lineOnBufferDrawRegionId.
   */
  _exitDrawLineOnBuffer() {
    const gl = this._renderer.gl;
    twgl.bindFramebufferInfo(gl, null);
  }

  /**
   * Prepare to do things with this PenSkin's framebuffer
   */
  _enterUsePenBuffer() {
    twgl.bindFramebufferInfo(this._renderer.gl, this._framebuffer);
  }

  /**
   * Return to a base state
   */
  _exitUsePenBuffer() {
    twgl.bindFramebufferInfo(this._renderer.gl, null);
  }

  /**
   * Draw a line on the framebuffer.
   * Note that the point coordinates are in the following coordinate space:
   * +y is down, (0, 0) is the center, and the coords range from (-width / 2, -height / 2) to (height / 2, width / 2).
   * @param {PenAttributes} penAttributes - how the line should be drawn.
   * @param {number} x0 - the X coordinate of the beginning of the line.
   * @param {number} y0 - the Y coordinate of the beginning of the line.
   * @param {number} x1 - the X coordinate of the end of the line.
   * @param {number} y1 - the Y coordinate of the end of the line.
   */
  _drawLineOnBuffer(penAttributes, x0, y0, x1, y1) {
    const gl = this._renderer.gl;
    const currentShader = this._lineShader;
    this._renderer.enterDrawRegion(this._lineOnBufferDrawRegionId);

    // Premultiply pen color by pen transparency
    const penColor = penAttributes.color4f || DefaultPenAttributes.color4f;
    __premultipliedColor[0] = penColor[0] * penColor[3];
    __premultipliedColor[1] = penColor[1] * penColor[3];
    __premultipliedColor[2] = penColor[2] * penColor[3];
    __premultipliedColor[3] = penColor[3];

    // Fun fact: Doing this calculation in the shader has the potential to overflow the floating-point range.
    // 'mediump' precision is only required to have a range up to 2^14 (16384), so any lines longer than 2^7 (128)
    // can overflow that, because you're squaring the operands, and they could end up as "infinity".
    // Even GLSL's `length` function won't save us here:
    // https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es
    const lineDiffX = x1 - x0;
    const lineDiffY = y1 - y0;
    const lineLength = Math.sqrt(lineDiffX * lineDiffX + lineDiffY * lineDiffY);
    const uniforms = {
      u_lineColor: __premultipliedColor,
      u_lineThickness: penAttributes.diameter || DefaultPenAttributes.diameter,
      u_lineLength: lineLength,
      u_penPoints: [x0, -y0, lineDiffX, -lineDiffY]
    };
    twgl.setUniforms(currentShader, uniforms);
    twgl.drawBufferInfo(gl, this._lineBufferInfo, gl.TRIANGLES);
    this._silhouetteDirty = true;
  }

  /**
   * React to a change in the renderer's native size.
   * @param {object} event - The change event.
   */
  onNativeSizeChanged(event) {
    this._setCanvasSize(event.newSize);
  }

  /**
   * Set the size of the pen canvas.
   * @param {Array<int>} canvasSize - the new width and height for the canvas.
   * @private
   */
  _setCanvasSize(canvasSize) {
    const [width, height] = canvasSize;
    this._size = canvasSize;
    this._rotationCenter[0] = width / 2;
    this._rotationCenter[1] = height / 2;
    const gl = this._renderer.gl;
    this._texture = twgl.createTexture(gl, {
      mag: gl.NEAREST,
      min: gl.NEAREST,
      wrap: gl.CLAMP_TO_EDGE,
      width,
      height
    });
    const attachments = [{
      format: gl.RGBA,
      attachment: this._texture
    }];
    if (this._framebuffer) {
      twgl.resizeFramebufferInfo(gl, this._framebuffer, attachments, width, height);
    } else {
      this._framebuffer = twgl.createFramebufferInfo(gl, attachments, width, height);
    }
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this._silhouettePixels = new Uint8Array(Math.floor(width * height * 4));
    this._silhouetteImageData = new ImageData(width, height);
    this._silhouetteDirty = true;
  }

  /**
   * If there have been pen operations that have dirtied the canvas, update
   * now before someone wants to use our silhouette.
   */
  updateSilhouette() {
    if (this._silhouetteDirty) {
      this._renderer.enterDrawRegion(this._usePenBufferDrawRegionId);
      // Sample the framebuffer's pixels into the silhouette instance
      const gl = this._renderer.gl;
      gl.readPixels(0, 0, this._size[0], this._size[1], gl.RGBA, gl.UNSIGNED_BYTE, this._silhouettePixels);
      this._silhouetteImageData.data.set(this._silhouettePixels);
      this._silhouette.update(this._silhouetteImageData, true /* isPremultiplied */);
      this._silhouetteDirty = false;
    }
  }
}
module.exports = PenSkin;

/***/ }),

/***/ "./node_modules/scratch-render/src/Rectangle.js":
/*!******************************************************!*\
  !*** ./node_modules/scratch-render/src/Rectangle.js ***!
  \******************************************************/
/***/ ((module) => {

class Rectangle {
  /**
   * A utility for creating and comparing axis-aligned rectangles.
   * Rectangles are always initialized to the "largest possible rectangle";
   * use one of the init* methods below to set up a particular rectangle.
   * @constructor
   */
  constructor() {
    this.left = -Infinity;
    this.right = Infinity;
    this.bottom = -Infinity;
    this.top = Infinity;
  }

  /**
   * Initialize a Rectangle from given Scratch-coordinate bounds.
   * @param {number} left Left bound of the rectangle.
   * @param {number} right Right bound of the rectangle.
   * @param {number} bottom Bottom bound of the rectangle.
   * @param {number} top Top bound of the rectangle.
   */
  initFromBounds(left, right, bottom, top) {
    this.left = left;
    this.right = right;
    this.bottom = bottom;
    this.top = top;
  }

  /**
   * Initialize a Rectangle to the minimum AABB around a set of points.
   * @param {Array<Array<number>>} points Array of [x, y] points.
   */
  initFromPointsAABB(points) {
    this.left = Infinity;
    this.right = -Infinity;
    this.top = -Infinity;
    this.bottom = Infinity;
    for (let i = 0; i < points.length; i++) {
      const x = points[i][0];
      const y = points[i][1];
      if (x < this.left) {
        this.left = x;
      }
      if (x > this.right) {
        this.right = x;
      }
      if (y > this.top) {
        this.top = y;
      }
      if (y < this.bottom) {
        this.bottom = y;
      }
    }
  }

  /**
   * Initialize a Rectangle to a 1 unit square centered at 0 x 0 transformed
   * by a model matrix.
   * @param {Array.<number>} m A 4x4 matrix to transform the rectangle by.
   * @tutorial Rectangle-AABB-Matrix
   */
  initFromModelMatrix(m) {
    // In 2D space, we will soon use the 2x2 "top left" scale and rotation
    // submatrix, while we store and the 1x2 "top right" that position
    // vector.
    const m30 = m[3 * 4 + 0];
    const m31 = m[3 * 4 + 1];

    // "Transform" a (0.5, 0.5) vector by the scale and rotation matrix but
    // sum the absolute of each component instead of use the signed values.
    const x = Math.abs(0.5 * m[0 * 4 + 0]) + Math.abs(0.5 * m[1 * 4 + 0]);
    const y = Math.abs(0.5 * m[0 * 4 + 1]) + Math.abs(0.5 * m[1 * 4 + 1]);

    // And adding them to the position components initializes our Rectangle.
    this.left = -x + m30;
    this.right = x + m30;
    this.top = y + m31;
    this.bottom = -y + m31;
  }

  /**
   * Determine if this Rectangle intersects some other.
   * Note that this is a comparison assuming the Rectangle was
   * initialized with Scratch-space bounds or points.
   * @param {!Rectangle} other Rectangle to check if intersecting.
   * @return {boolean} True if this Rectangle intersects other.
   */
  intersects(other) {
    return this.left <= other.right && other.left <= this.right && this.top >= other.bottom && other.top >= this.bottom;
  }

  /**
   * Determine if this Rectangle fully contains some other.
   * Note that this is a comparison assuming the Rectangle was
   * initialized with Scratch-space bounds or points.
   * @param {!Rectangle} other Rectangle to check if fully contained.
   * @return {boolean} True if this Rectangle fully contains other.
   */
  contains(other) {
    return other.left > this.left && other.right < this.right && other.top < this.top && other.bottom > this.bottom;
  }

  /**
   * Clamp a Rectangle to bounds.
   * @param {number} left Left clamp.
   * @param {number} right Right clamp.
   * @param {number} bottom Bottom clamp.
   * @param {number} top Top clamp.
   */
  clamp(left, right, bottom, top) {
    this.left = Math.max(this.left, left);
    this.right = Math.min(this.right, right);
    this.bottom = Math.max(this.bottom, bottom);
    this.top = Math.min(this.top, top);
    this.left = Math.min(this.left, right);
    this.right = Math.max(this.right, left);
    this.bottom = Math.min(this.bottom, top);
    this.top = Math.max(this.top, bottom);
  }

  /**
   * Push out the Rectangle to integer bounds.
   */
  snapToInt() {
    this.left = Math.floor(this.left);
    this.right = Math.ceil(this.right);
    this.bottom = Math.floor(this.bottom);
    this.top = Math.ceil(this.top);
  }

  /**
   * Compute the intersection of two bounding Rectangles.
   * Could be an impossible box if they don't intersect.
   * @param {Rectangle} a One rectangle
   * @param {Rectangle} b Other rectangle
   * @param {?Rectangle} result A resulting storage rectangle  (safe to pass
   *                            a or b if you want to overwrite one)
   * @returns {Rectangle} resulting rectangle
   */
  static intersect(a, b) {
    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Rectangle();
    result.left = Math.max(a.left, b.left);
    result.right = Math.min(a.right, b.right);
    result.top = Math.min(a.top, b.top);
    result.bottom = Math.max(a.bottom, b.bottom);
    return result;
  }

  /**
   * Compute the union of two bounding Rectangles.
   * @param {Rectangle} a One rectangle
   * @param {Rectangle} b Other rectangle
   * @param {?Rectangle} result A resulting storage rectangle  (safe to pass
   *                            a or b if you want to overwrite one)
   * @returns {Rectangle} resulting rectangle
   */
  static union(a, b) {
    let result = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Rectangle();
    result.left = Math.min(a.left, b.left);
    result.right = Math.max(a.right, b.right);
    // Scratch Space - +y is up
    result.top = Math.max(a.top, b.top);
    result.bottom = Math.min(a.bottom, b.bottom);
    return result;
  }

  /**
   * Width of the Rectangle.
   * @return {number} Width of rectangle.
   */
  get width() {
    return Math.abs(this.left - this.right);
  }

  /**
   * Height of the Rectangle.
   * @return {number} Height of rectangle.
   */
  get height() {
    return Math.abs(this.top - this.bottom);
  }
}
module.exports = Rectangle;

/***/ }),

/***/ "./node_modules/scratch-render/src/RenderConstants.js":
/*!************************************************************!*\
  !*** ./node_modules/scratch-render/src/RenderConstants.js ***!
  \************************************************************/
/***/ ((module) => {

/** @module RenderConstants */

/**
 * Various constants meant for use throughout the renderer.
 * @enum
 */
module.exports = {
  /**
   * The ID value to use for "no item" or when an object has been disposed.
   * @const {int}
   */
  ID_NONE: -1,
  /**
   * Optimize for fewer than this number of Drawables sharing the same Skin.
   * Going above this may cause middleware warnings or a performance penalty but should otherwise behave correctly.
   * @const {int}
   */
  SKIN_SHARE_SOFT_LIMIT: 301,
  /**
   * @enum {string}
   */
  Events: {
    /**
     * NativeSizeChanged event
     *
     * @event RenderWebGL#event:NativeSizeChanged
     * @type {object}
     * @property {Array<int>} newSize - the new size of the renderer
     */
    NativeSizeChanged: 'NativeSizeChanged'
  }
};

/***/ }),

/***/ "./node_modules/scratch-render/src/RenderWebGL.js":
/*!********************************************************!*\
  !*** ./node_modules/scratch-render/src/RenderWebGL.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const hull = __webpack_require__(/*! hull.js */ "./node_modules/hull.js/src/hull.js");
const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const BitmapSkin = __webpack_require__(/*! ./BitmapSkin */ "./node_modules/scratch-render/src/BitmapSkin.js");
const Drawable = __webpack_require__(/*! ./Drawable */ "./node_modules/scratch-render/src/Drawable.js");
const Rectangle = __webpack_require__(/*! ./Rectangle */ "./node_modules/scratch-render/src/Rectangle.js");
const PenSkin = __webpack_require__(/*! ./PenSkin */ "./node_modules/scratch-render/src/PenSkin.js");
const RenderConstants = __webpack_require__(/*! ./RenderConstants */ "./node_modules/scratch-render/src/RenderConstants.js");
const ShaderManager = __webpack_require__(/*! ./ShaderManager */ "./node_modules/scratch-render/src/ShaderManager.js");
const SVGSkin = __webpack_require__(/*! ./SVGSkin */ "./node_modules/scratch-render/src/SVGSkin.js");
const TextBubbleSkin = __webpack_require__(/*! ./TextBubbleSkin */ "./node_modules/scratch-render/src/TextBubbleSkin.js");
const EffectTransform = __webpack_require__(/*! ./EffectTransform */ "./node_modules/scratch-render/src/EffectTransform.js");
const log = __webpack_require__(/*! ./util/log */ "./node_modules/scratch-render/src/util/log.js");
const __isTouchingDrawablesPoint = twgl.v3.create();
const __candidatesBounds = new Rectangle();
const __fenceBounds = new Rectangle();
const __touchingColor = new Uint8ClampedArray(4);
const __blendColor = new Uint8ClampedArray(4);

// More pixels than this and we give up to the GPU and take the cost of readPixels
// Width * Height * Number of drawables at location
const __cpuTouchingColorPixelCount = 4e4;

/**
 * @callback RenderWebGL#idFilterFunc
 * @param {int} drawableID The ID to filter.
 * @return {bool} True if the ID passes the filter, otherwise false.
 */

/**
 * Maximum touch size for a picking check.
 * @todo Figure out a reasonable max size. Maybe this should be configurable?
 * @type {Array<int>}
 * @memberof RenderWebGL
 */
const MAX_TOUCH_SIZE = [3, 3];

/**
 * Passed to the uniforms for mask in touching color
 */
const MASK_TOUCHING_COLOR_TOLERANCE = 2;

/**
 * Maximum number of pixels in either dimension of "extracted drawable" data
 * @type {int}
 */
const MAX_EXTRACTED_DRAWABLE_DIMENSION = 2048;

/**
 * Determines if the mask color is "close enough" (only test the 6 top bits for
 * each color).  These bit masks are what scratch 2 used to use, so we do the same.
 * @param {Uint8Array} a A color3b or color4b value.
 * @param {Uint8Array} b A color3b or color4b value.
 * @returns {boolean} If the colors match within the parameters.
 */
const maskMatches = (a, b) =>
// has some non-alpha component to test against
a[3] > 0 && (a[0] & 0b11111100) === (b[0] & 0b11111100) && (a[1] & 0b11111100) === (b[1] & 0b11111100) && (a[2] & 0b11111100) === (b[2] & 0b11111100);

/**
 * Determines if the given color is "close enough" (only test the 5 top bits for
 * red and green, 4 bits for blue).  These bit masks are what scratch 2 used to use,
 * so we do the same.
 * @param {Uint8Array} a A color3b or color4b value.
 * @param {Uint8Array} b A color3b or color4b value / or a larger array when used with offsets
 * @param {number} offset An offset into the `b` array, which lets you use a larger array to test
 *                  multiple values at the same time.
 * @returns {boolean} If the colors match within the parameters.
 */
const colorMatches = (a, b, offset) => (a[0] & 0b11111000) === (b[offset + 0] & 0b11111000) && (a[1] & 0b11111000) === (b[offset + 1] & 0b11111000) && (a[2] & 0b11110000) === (b[offset + 2] & 0b11110000);

/**
 * Sprite Fencing - The number of pixels a sprite is required to leave remaining
 * onscreen around the edge of the staging area.
 * @type {number}
 */
const FENCE_WIDTH = 15;
class RenderWebGL extends EventEmitter {
  /**
   * Check if this environment appears to support this renderer before attempting to create an instance.
   * Catching an exception from the constructor is also a valid way to test for (lack of) support.
   * @param {canvas} [optCanvas] - An optional canvas to use for the test. Otherwise a temporary canvas will be used.
   * @returns {boolean} - True if this environment appears to support this renderer, false otherwise.
   */
  static isSupported(optCanvas) {
    try {
      // Create the context the same way that the constructor will: attributes may make the difference.
      return !!RenderWebGL._getContext(optCanvas || document.createElement('canvas'));
    } catch (e) {
      return false;
    }
  }

  /**
   * Ask TWGL to create a rendering context with the attributes used by this renderer.
   * @param {canvas} canvas - attach the context to this canvas.
   * @returns {WebGLRenderingContext} - a TWGL rendering context (backed by either WebGL 1.0 or 2.0).
   * @private
   */
  static _getContext(canvas) {
    const contextAttribs = {
      alpha: false,
      stencil: true,
      antialias: false
    };
    // getWebGLContext = try WebGL 1.0 only
    // getContext = try WebGL 2.0 and if that doesn't work, try WebGL 1.0
    // getWebGLContext || getContext = try WebGL 1.0 and if that doesn't work, try WebGL 2.0
    return twgl.getWebGLContext(canvas, contextAttribs) || twgl.getContext(canvas, contextAttribs);
  }

  /**
   * Create a renderer for drawing Scratch sprites to a canvas using WebGL.
   * Coordinates will default to Scratch 2.0 values if unspecified.
   * The stage's "native" size will be calculated from the these coordinates.
   * For example, the defaults result in a native size of 480x360.
   * Queries such as "touching color?" will always execute at the native size.
   * @see RenderWebGL#setStageSize
   * @see RenderWebGL#resize
   * @param {canvas} canvas The canvas to draw onto.
   * @param {int} [xLeft=-240] The x-coordinate of the left edge.
   * @param {int} [xRight=240] The x-coordinate of the right edge.
   * @param {int} [yBottom=-180] The y-coordinate of the bottom edge.
   * @param {int} [yTop=180] The y-coordinate of the top edge.
   * @constructor
   * @listens RenderWebGL#event:NativeSizeChanged
   */
  constructor(canvas, xLeft, xRight, yBottom, yTop) {
    super();

    /** @type {WebGLRenderingContext} */
    const gl = this._gl = RenderWebGL._getContext(canvas);
    if (!gl) {
      throw new Error('Could not get WebGL context: this browser or environment may not support WebGL.');
    }

    /** @type {RenderWebGL.UseGpuModes} */
    this._useGpuMode = RenderWebGL.UseGpuModes.Automatic;

    /** @type {Drawable[]} */
    this._allDrawables = [];

    /** @type {Skin[]} */
    this._allSkins = [];

    /** @type {Array<int>} */
    this._drawList = [];

    // A list of layer group names in the order they should appear
    // from furthest back to furthest in front.
    /** @type {Array<String>} */
    this._groupOrdering = [];

    /**
     * @typedef LayerGroup
     * @property {int} groupIndex The relative position of this layer group in the group ordering
     * @property {int} drawListOffset The absolute position of this layer group in the draw list
     * This number gets updated as drawables get added to or deleted from the draw list.
     */

    // Map of group name to layer group
    /** @type {Object.<string, LayerGroup>} */
    this._layerGroups = {};

    /** @type {int} */
    this._nextDrawableId = RenderConstants.ID_NONE + 1;

    /** @type {int} */
    this._nextSkinId = RenderConstants.ID_NONE + 1;

    /** @type {module:twgl/m4.Mat4} */
    this._projection = twgl.m4.identity();

    /** @type {ShaderManager} */
    this._shaderManager = new ShaderManager(gl);

    /** @type {HTMLCanvasElement} */
    this._tempCanvas = document.createElement('canvas');

    /** @type {any} */
    this._regionId = null;

    /** @type {function} */
    this._exitRegion = null;

    /** @type {object} */
    this._backgroundDrawRegionId = {
      enter: () => this._enterDrawBackground(),
      exit: () => this._exitDrawBackground()
    };

    /** @type {Array.<snapshotCallback>} */
    this._snapshotCallbacks = [];

    /** @type {Array<number>} */
    // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor3b
    this._backgroundColor4f = [0, 0, 0, 1];

    /** @type {Uint8ClampedArray} */
    // Don't set this directly-- use setBackgroundColor so it stays in sync with _backgroundColor4f
    this._backgroundColor3b = new Uint8ClampedArray(3);
    this._createGeometry();
    this.on(RenderConstants.Events.NativeSizeChanged, this.onNativeSizeChanged);
    this.setBackgroundColor(1, 1, 1);
    this.setStageSize(xLeft || -240, xRight || 240, yBottom || -180, yTop || 180);
    this.resize(this._nativeSize[0], this._nativeSize[1]);
    gl.disable(gl.DEPTH_TEST);
    /** @todo disable when no partial transparency? */
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
  }

  /**
   * @returns {WebGLRenderingContext} the WebGL rendering context associated with this renderer.
   */
  get gl() {
    return this._gl;
  }

  /**
   * @returns {HTMLCanvasElement} the canvas of the WebGL rendering context associated with this renderer.
   */
  get canvas() {
    return this._gl && this._gl.canvas;
  }

  /**
   * Set the physical size of the stage in device-independent pixels.
   * This will be multiplied by the device's pixel ratio on high-DPI displays.
   * @param {int} pixelsWide The desired width in device-independent pixels.
   * @param {int} pixelsTall The desired height in device-independent pixels.
   */
  resize(pixelsWide, pixelsTall) {
    const {
      canvas
    } = this._gl;
    const pixelRatio = window.devicePixelRatio || 1;
    const newWidth = pixelsWide * pixelRatio;
    const newHeight = pixelsTall * pixelRatio;

    // Certain operations, such as moving the color picker, call `resize` once per frame, even though the canvas
    // size doesn't change. To avoid unnecessary canvas updates, check that we *really* need to resize the canvas.
    if (canvas.width !== newWidth || canvas.height !== newHeight) {
      canvas.width = newWidth;
      canvas.height = newHeight;
      // Resizing the canvas causes it to be cleared, so redraw it.
      this.draw();
    }
  }

  /**
   * Set the background color for the stage. The stage will be cleared with this
   * color each frame.
   * @param {number} red The red component for the background.
   * @param {number} green The green component for the background.
   * @param {number} blue The blue component for the background.
   */
  setBackgroundColor(red, green, blue) {
    this._backgroundColor4f[0] = red;
    this._backgroundColor4f[1] = green;
    this._backgroundColor4f[2] = blue;
    this._backgroundColor3b[0] = red * 255;
    this._backgroundColor3b[1] = green * 255;
    this._backgroundColor3b[2] = blue * 255;
  }

  /**
   * Tell the renderer to draw various debug information to the provided canvas
   * during certain operations.
   * @param {canvas} canvas The canvas to use for debug output.
   */
  setDebugCanvas(canvas) {
    this._debugCanvas = canvas;
  }

  /**
   * Control the use of the GPU or CPU paths in `isTouchingColor`.
   * @param {RenderWebGL.UseGpuModes} useGpuMode - automatically decide, force CPU, or force GPU.
   */
  setUseGpuMode(useGpuMode) {
    this._useGpuMode = useGpuMode;
  }

  /**
   * Set logical size of the stage in Scratch units.
   * @param {int} xLeft The left edge's x-coordinate. Scratch 2 uses -240.
   * @param {int} xRight The right edge's x-coordinate. Scratch 2 uses 240.
   * @param {int} yBottom The bottom edge's y-coordinate. Scratch 2 uses -180.
   * @param {int} yTop The top edge's y-coordinate. Scratch 2 uses 180.
   */
  setStageSize(xLeft, xRight, yBottom, yTop) {
    this._xLeft = xLeft;
    this._xRight = xRight;
    this._yBottom = yBottom;
    this._yTop = yTop;

    // swap yBottom & yTop to fit Scratch convention of +y=up
    this._projection = twgl.m4.ortho(xLeft, xRight, yBottom, yTop, -1, 1);
    this._setNativeSize(Math.abs(xRight - xLeft), Math.abs(yBottom - yTop));
  }

  /**
   * @return {Array<int>} the "native" size of the stage, which is used for pen, query renders, etc.
   */
  getNativeSize() {
    return [this._nativeSize[0], this._nativeSize[1]];
  }

  /**
   * Set the "native" size of the stage, which is used for pen, query renders, etc.
   * @param {int} width - the new width to set.
   * @param {int} height - the new height to set.
   * @private
   * @fires RenderWebGL#event:NativeSizeChanged
   */
  _setNativeSize(width, height) {
    this._nativeSize = [width, height];
    this.emit(RenderConstants.Events.NativeSizeChanged, {
      newSize: this._nativeSize
    });
  }

  /**
   * Create a new bitmap skin from a snapshot of the provided bitmap data.
   * @param {ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} bitmapData - new contents for this skin.
   * @param {!int} [costumeResolution=1] - The resolution to use for this bitmap.
   * @param {?Array<number>} [rotationCenter] Optional: rotation center of the skin. If not supplied, the center of
   * the skin will be used.
   * @returns {!int} the ID for the new skin.
   */
  createBitmapSkin(bitmapData, costumeResolution, rotationCenter) {
    const skinId = this._nextSkinId++;
    const newSkin = new BitmapSkin(skinId, this);
    newSkin.setBitmap(bitmapData, costumeResolution, rotationCenter);
    this._allSkins[skinId] = newSkin;
    return skinId;
  }

  /**
   * Create a new SVG skin.
   * @param {!string} svgData - new SVG to use.
   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the
   * skin will be used
   * @returns {!int} the ID for the new skin.
   */
  createSVGSkin(svgData, rotationCenter) {
    const skinId = this._nextSkinId++;
    const newSkin = new SVGSkin(skinId, this);
    newSkin.setSVG(svgData, rotationCenter);
    this._allSkins[skinId] = newSkin;
    return skinId;
  }

  /**
   * Create a new PenSkin - a skin which implements a Scratch pen layer.
   * @returns {!int} the ID for the new skin.
   */
  createPenSkin() {
    const skinId = this._nextSkinId++;
    const newSkin = new PenSkin(skinId, this);
    this._allSkins[skinId] = newSkin;
    return skinId;
  }

  /**
   * Create a new SVG skin using the text bubble svg creator. The rotation center
   * is always placed at the top left.
   * @param {!string} type - either "say" or "think".
   * @param {!string} text - the text for the bubble.
   * @param {!boolean} pointsLeft - which side the bubble is pointing.
   * @returns {!int} the ID for the new skin.
   */
  createTextSkin(type, text, pointsLeft) {
    const skinId = this._nextSkinId++;
    const newSkin = new TextBubbleSkin(skinId, this);
    newSkin.setTextBubble(type, text, pointsLeft);
    this._allSkins[skinId] = newSkin;
    return skinId;
  }

  /**
   * Update an existing SVG skin, or create an SVG skin if the previous skin was not SVG.
   * @param {!int} skinId the ID for the skin to change.
   * @param {!string} svgData - new SVG to use.
   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the
   * skin will be used
   */
  updateSVGSkin(skinId, svgData, rotationCenter) {
    if (this._allSkins[skinId] instanceof SVGSkin) {
      this._allSkins[skinId].setSVG(svgData, rotationCenter);
      return;
    }
    const newSkin = new SVGSkin(skinId, this);
    newSkin.setSVG(svgData, rotationCenter);
    this._reskin(skinId, newSkin);
  }

  /**
   * Update an existing bitmap skin, or create a bitmap skin if the previous skin was not bitmap.
   * @param {!int} skinId the ID for the skin to change.
   * @param {!ImageData|HTMLImageElement|HTMLCanvasElement|HTMLVideoElement} imgData - new contents for this skin.
   * @param {!number} bitmapResolution - the resolution scale for a bitmap costume.
   * @param {?Array<number>} rotationCenter Optional: rotation center of the skin. If not supplied, the center of the
   * skin will be used
   */
  updateBitmapSkin(skinId, imgData, bitmapResolution, rotationCenter) {
    if (this._allSkins[skinId] instanceof BitmapSkin) {
      this._allSkins[skinId].setBitmap(imgData, bitmapResolution, rotationCenter);
      return;
    }
    const newSkin = new BitmapSkin(skinId, this);
    newSkin.setBitmap(imgData, bitmapResolution, rotationCenter);
    this._reskin(skinId, newSkin);
  }
  _reskin(skinId, newSkin) {
    const oldSkin = this._allSkins[skinId];
    this._allSkins[skinId] = newSkin;

    // Tell drawables to update
    for (const drawable of this._allDrawables) {
      if (drawable && drawable.skin === oldSkin) {
        drawable.skin = newSkin;
      }
    }
    oldSkin.dispose();
  }

  /**
   * Update a skin using the text bubble svg creator.
   * @param {!int} skinId the ID for the skin to change.
   * @param {!string} type - either "say" or "think".
   * @param {!string} text - the text for the bubble.
   * @param {!boolean} pointsLeft - which side the bubble is pointing.
   */
  updateTextSkin(skinId, type, text, pointsLeft) {
    if (this._allSkins[skinId] instanceof TextBubbleSkin) {
      this._allSkins[skinId].setTextBubble(type, text, pointsLeft);
      return;
    }
    const newSkin = new TextBubbleSkin(skinId, this);
    newSkin.setTextBubble(type, text, pointsLeft);
    this._reskin(skinId, newSkin);
  }

  /**
   * Destroy an existing skin. Do not use the skin or its ID after calling this.
   * @param {!int} skinId - The ID of the skin to destroy.
   */
  destroySkin(skinId) {
    const oldSkin = this._allSkins[skinId];
    oldSkin.dispose();
    delete this._allSkins[skinId];
  }

  /**
   * Create a new Drawable and add it to the scene.
   * @param {string} group Layer group to add the drawable to
   * @returns {int} The ID of the new Drawable.
   */
  createDrawable(group) {
    if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {
      log.warn('Cannot create a drawable without a known layer group');
      return;
    }
    const drawableID = this._nextDrawableId++;
    const drawable = new Drawable(drawableID);
    this._allDrawables[drawableID] = drawable;
    this._addToDrawList(drawableID, group);
    drawable.skin = null;
    return drawableID;
  }

  /**
   * Set the layer group ordering for the renderer.
   * @param {Array<string>} groupOrdering The ordered array of layer group
   * names
   */
  setLayerGroupOrdering(groupOrdering) {
    this._groupOrdering = groupOrdering;
    for (let i = 0; i < this._groupOrdering.length; i++) {
      this._layerGroups[this._groupOrdering[i]] = {
        groupIndex: i,
        drawListOffset: 0
      };
    }
  }
  _addToDrawList(drawableID, group) {
    const currentLayerGroup = this._layerGroups[group];
    const currentGroupOrderingIndex = currentLayerGroup.groupIndex;
    const drawListOffset = this._endIndexForKnownLayerGroup(currentLayerGroup);
    this._drawList.splice(drawListOffset, 0, drawableID);
    this._updateOffsets('add', currentGroupOrderingIndex);
  }
  _updateOffsets(updateType, currentGroupOrderingIndex) {
    for (let i = currentGroupOrderingIndex + 1; i < this._groupOrdering.length; i++) {
      const laterGroupName = this._groupOrdering[i];
      if (updateType === 'add') {
        this._layerGroups[laterGroupName].drawListOffset++;
      } else if (updateType === 'delete') {
        this._layerGroups[laterGroupName].drawListOffset--;
      }
    }
  }
  get _visibleDrawList() {
    return this._drawList.filter(id => this._allDrawables[id]._visible);
  }

  // Given a layer group, return the index where it ends (non-inclusive),
  // e.g. the returned index does not have a drawable from this layer group in it)
  _endIndexForKnownLayerGroup(layerGroup) {
    const groupIndex = layerGroup.groupIndex;
    if (groupIndex === this._groupOrdering.length - 1) {
      return this._drawList.length;
    }
    return this._layerGroups[this._groupOrdering[groupIndex + 1]].drawListOffset;
  }

  /**
   * Destroy a Drawable, removing it from the scene.
   * @param {int} drawableID The ID of the Drawable to remove.
   * @param {string} group Group name that the drawable belongs to
   */
  destroyDrawable(drawableID, group) {
    if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {
      log.warn('Cannot destroy drawable without known layer group.');
      return;
    }
    const drawable = this._allDrawables[drawableID];
    drawable.dispose();
    delete this._allDrawables[drawableID];
    const currentLayerGroup = this._layerGroups[group];
    const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);
    let index = currentLayerGroup.drawListOffset;
    while (index < endIndex) {
      if (this._drawList[index] === drawableID) {
        break;
      }
      index++;
    }
    if (index < endIndex) {
      this._drawList.splice(index, 1);
      this._updateOffsets('delete', currentLayerGroup.groupIndex);
    } else {
      log.warn('Could not destroy drawable that could not be found in layer group.');
      return;
    }
  }

  /**
   * Returns the position of the given drawableID in the draw list. This is
   * the absolute position irrespective of layer group.
   * @param {number} drawableID The drawable ID to find.
   * @return {number} The postion of the given drawable ID.
   */
  getDrawableOrder(drawableID) {
    return this._drawList.indexOf(drawableID);
  }

  /**
   * Set a drawable's order in the drawable list (effectively, z/layer).
   * Can be used to move drawables to absolute positions in the list,
   * or relative to their current positions.
   * "go back N layers": setDrawableOrder(id, -N, true, 1); (assuming stage at 0).
   * "go to back": setDrawableOrder(id, 1); (assuming stage at 0).
   * "go to front": setDrawableOrder(id, Infinity);
   * @param {int} drawableID ID of Drawable to reorder.
   * @param {number} order New absolute order or relative order adjusment.
   * @param {string=} group Name of layer group drawable belongs to.
   * Reordering will not take place if drawable cannot be found within the bounds
   * of the layer group.
   * @param {boolean=} optIsRelative If set, `order` refers to a relative change.
   * @param {number=} optMin If set, order constrained to be at least `optMin`.
   * @return {?number} New order if changed, or null.
   */
  setDrawableOrder(drawableID, order, group, optIsRelative, optMin) {
    if (!group || !Object.prototype.hasOwnProperty.call(this._layerGroups, group)) {
      log.warn('Cannot set the order of a drawable without a known layer group.');
      return;
    }
    const currentLayerGroup = this._layerGroups[group];
    const startIndex = currentLayerGroup.drawListOffset;
    const endIndex = this._endIndexForKnownLayerGroup(currentLayerGroup);
    let oldIndex = startIndex;
    while (oldIndex < endIndex) {
      if (this._drawList[oldIndex] === drawableID) {
        break;
      }
      oldIndex++;
    }
    if (oldIndex < endIndex) {
      // Remove drawable from the list.
      if (order === 0) {
        return oldIndex;
      }
      const _ = this._drawList.splice(oldIndex, 1)[0];
      // Determine new index.
      let newIndex = order;
      if (optIsRelative) {
        newIndex += oldIndex;
      }
      const possibleMin = (optMin || 0) + startIndex;
      const min = possibleMin >= startIndex && possibleMin < endIndex ? possibleMin : startIndex;
      newIndex = Math.max(newIndex, min);
      newIndex = Math.min(newIndex, endIndex);

      // Insert at new index.
      this._drawList.splice(newIndex, 0, drawableID);
      return newIndex;
    }
    return null;
  }

  /**
   * Draw all current drawables and present the frame on the canvas.
   */
  draw() {
    this._doExitDrawRegion();
    const gl = this._gl;
    twgl.bindFramebufferInfo(gl, null);
    gl.viewport(0, 0, gl.canvas.width, gl.canvas.height);
    gl.clearColor(...this._backgroundColor4f);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, this._projection, {
      framebufferWidth: gl.canvas.width,
      framebufferHeight: gl.canvas.height
    });
    if (this._snapshotCallbacks.length > 0) {
      const snapshot = gl.canvas.toDataURL();
      this._snapshotCallbacks.forEach(cb => cb(snapshot));
      this._snapshotCallbacks = [];
    }
  }

  /**
   * Get the precise bounds for a Drawable.
   * @param {int} drawableID ID of Drawable to get bounds for.
   * @return {object} Bounds for a tight box around the Drawable.
   */
  getBounds(drawableID) {
    const drawable = this._allDrawables[drawableID];
    // Tell the Drawable about its updated convex hull, if necessary.
    if (drawable.needsConvexHullPoints()) {
      const points = this._getConvexHullPointsForDrawable(drawableID);
      drawable.setConvexHullPoints(points);
    }
    const bounds = drawable.getFastBounds();
    // In debug mode, draw the bounds.
    if (this._debugCanvas) {
      const gl = this._gl;
      this._debugCanvas.width = gl.canvas.width;
      this._debugCanvas.height = gl.canvas.height;
      const context = this._debugCanvas.getContext('2d');
      context.drawImage(gl.canvas, 0, 0);
      context.strokeStyle = '#FF0000';
      const pr = window.devicePixelRatio;
      context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));
    }
    return bounds;
  }

  /**
   * Get the precise bounds for a Drawable around the top slice.
   * Used for positioning speech bubbles more closely to the sprite.
   * @param {int} drawableID ID of Drawable to get bubble bounds for.
   * @return {object} Bounds for a tight box around the Drawable top slice.
   */
  getBoundsForBubble(drawableID) {
    const drawable = this._allDrawables[drawableID];
    // Tell the Drawable about its updated convex hull, if necessary.
    if (drawable.needsConvexHullPoints()) {
      const points = this._getConvexHullPointsForDrawable(drawableID);
      drawable.setConvexHullPoints(points);
    }
    const bounds = drawable.getBoundsForBubble();
    // In debug mode, draw the bounds.
    if (this._debugCanvas) {
      const gl = this._gl;
      this._debugCanvas.width = gl.canvas.width;
      this._debugCanvas.height = gl.canvas.height;
      const context = this._debugCanvas.getContext('2d');
      context.drawImage(gl.canvas, 0, 0);
      context.strokeStyle = '#FF0000';
      const pr = window.devicePixelRatio;
      context.strokeRect(pr * (bounds.left + this._nativeSize[0] / 2), pr * (-bounds.top + this._nativeSize[1] / 2), pr * (bounds.right - bounds.left), pr * (-bounds.bottom + bounds.top));
    }
    return bounds;
  }

  /**
   * Get the current skin (costume) size of a Drawable.
   * @param {int} drawableID The ID of the Drawable to measure.
   * @return {Array<number>} Skin size, width and height.
   */
  getCurrentSkinSize(drawableID) {
    const drawable = this._allDrawables[drawableID];
    return this.getSkinSize(drawable.skin.id);
  }

  /**
   * Get the size of a skin by ID.
   * @param {int} skinID The ID of the Skin to measure.
   * @return {Array<number>} Skin size, width and height.
   */
  getSkinSize(skinID) {
    const skin = this._allSkins[skinID];
    return skin.size;
  }

  /**
   * Get the rotation center of a skin by ID.
   * @param {int} skinID The ID of the Skin
   * @return {Array<number>} The rotationCenterX and rotationCenterY
   */
  getSkinRotationCenter(skinID) {
    const skin = this._allSkins[skinID];
    return skin.calculateRotationCenter();
  }

  /**
   * Check if a particular Drawable is touching a particular color.
   * Unlike touching drawable, if the "tester" is invisble, we will still test.
   * @param {int} drawableID The ID of the Drawable to check.
   * @param {Array<int>} color3b Test if the Drawable is touching this color.
   * @param {Array<int>} [mask3b] Optionally mask the check to this part of Drawable.
   * @returns {boolean} True iff the Drawable is touching the color.
   */
  isTouchingColor(drawableID, color3b, mask3b) {
    const candidates = this._candidatesTouching(drawableID, this._visibleDrawList);
    let bounds;
    if (colorMatches(color3b, this._backgroundColor3b, 0)) {
      // If the color we're checking for is the background color, don't confine the check to
      // candidate drawables' bounds--since the background spans the entire stage, we must check
      // everything that lies inside the drawable.
      bounds = this._touchingBounds(drawableID);
      // e.g. empty costume, or off the stage
      if (bounds === null) return false;
    } else if (candidates.length === 0) {
      // If not checking for the background color, we can return early if there are no candidate drawables.
      return false;
    } else {
      bounds = this._candidatesBounds(candidates);
    }
    const maxPixelsForCPU = this._getMaxPixelsForCPU();
    const debugCanvasContext = this._debugCanvas && this._debugCanvas.getContext('2d');
    if (debugCanvasContext) {
      this._debugCanvas.width = bounds.width;
      this._debugCanvas.height = bounds.height;
    }

    // if there are just too many pixels to CPU render efficiently, we need to let readPixels happen
    if (bounds.width * bounds.height * (candidates.length + 1) >= maxPixelsForCPU) {
      this._isTouchingColorGpuStart(drawableID, candidates.map(_ref => {
        let {
          id
        } = _ref;
        return id;
      }).reverse(), bounds, color3b, mask3b);
    }
    const drawable = this._allDrawables[drawableID];
    const point = __isTouchingDrawablesPoint;
    const color = __touchingColor;
    const hasMask = Boolean(mask3b);
    drawable.updateCPURenderAttributes();

    // Masked drawable ignores ghost effect
    const effectMask = ~ShaderManager.EFFECT_INFO.ghost.mask;

    // Scratch Space - +y is top
    for (let y = bounds.bottom; y <= bounds.top; y++) {
      if (bounds.width * (y - bounds.bottom) * (candidates.length + 1) >= maxPixelsForCPU) {
        return this._isTouchingColorGpuFin(bounds, color3b, y - bounds.bottom);
      }
      for (let x = bounds.left; x <= bounds.right; x++) {
        point[1] = y;
        point[0] = x;
        // if we use a mask, check our sample color...
        if (hasMask ? maskMatches(Drawable.sampleColor4b(point, drawable, color, effectMask), mask3b) : drawable.isTouching(point)) {
          RenderWebGL.sampleColor3b(point, candidates, color);
          if (debugCanvasContext) {
            debugCanvasContext.fillStyle = "rgb(".concat(color[0], ",").concat(color[1], ",").concat(color[2], ")");
            debugCanvasContext.fillRect(x - bounds.left, bounds.bottom - y, 1, 1);
          }
          // ...and the target color is drawn at this pixel
          if (colorMatches(color, color3b, 0)) {
            return true;
          }
        }
      }
    }
    return false;
  }
  _getMaxPixelsForCPU() {
    switch (this._useGpuMode) {
      case RenderWebGL.UseGpuModes.ForceCPU:
        return Infinity;
      case RenderWebGL.UseGpuModes.ForceGPU:
        return 0;
      case RenderWebGL.UseGpuModes.Automatic:
      default:
        return __cpuTouchingColorPixelCount;
    }
  }
  _enterDrawBackground() {
    const gl = this.gl;
    const currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);
    gl.disable(gl.BLEND);
    gl.useProgram(currentShader.program);
    twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);
  }
  _exitDrawBackground() {
    const gl = this.gl;
    gl.enable(gl.BLEND);
  }
  _isTouchingColorGpuStart(drawableID, candidateIDs, bounds, color3b, mask3b) {
    this._doExitDrawRegion();
    const gl = this._gl;
    twgl.bindFramebufferInfo(gl, this._queryBufferInfo);

    // Limit size of viewport to the bounds around the target Drawable,
    // and create the projection matrix for the draw.
    gl.viewport(0, 0, bounds.width, bounds.height);
    const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);

    // Clear the query buffer to fully transparent. This will be the color of pixels that fail the stencil test.
    gl.clearColor(0, 0, 0, 0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);
    let extraUniforms;
    if (mask3b) {
      extraUniforms = {
        u_colorMask: [mask3b[0] / 255, mask3b[1] / 255, mask3b[2] / 255],
        u_colorMaskTolerance: MASK_TOUCHING_COLOR_TOLERANCE / 255
      };
    }
    try {
      // Using the stencil buffer, mask out the drawing to either the drawable's alpha channel
      // or pixels of the drawable which match the mask color, depending on whether a mask color is given.
      // Masked-out pixels will not be checked.
      gl.enable(gl.STENCIL_TEST);
      gl.stencilFunc(gl.ALWAYS, 1, 1);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.REPLACE);
      gl.colorMask(false, false, false, false);
      this._drawThese([drawableID], mask3b ? ShaderManager.DRAW_MODE.colorMask : ShaderManager.DRAW_MODE.silhouette, projection, {
        extraUniforms,
        ignoreVisibility: true,
        // Touching color ignores sprite visibility,
        effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask
      });
      gl.stencilFunc(gl.EQUAL, 1, 1);
      gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
      gl.colorMask(true, true, true, true);

      // Draw the background as a quad. Drawing a background with gl.clear will not mask to the stenciled area.
      this.enterDrawRegion(this._backgroundDrawRegionId);
      const uniforms = {
        u_backgroundColor: this._backgroundColor4f
      };
      const currentShader = this._shaderManager.getShader(ShaderManager.DRAW_MODE.background, 0);
      twgl.setUniforms(currentShader, uniforms);
      twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);

      // Draw the candidate drawables on top of the background.
      this._drawThese(candidateIDs, ShaderManager.DRAW_MODE.default, projection, {
        idFilterFunc: testID => testID !== drawableID
      });
    } finally {
      gl.colorMask(true, true, true, true);
      gl.disable(gl.STENCIL_TEST);
      this._doExitDrawRegion();
    }
  }
  _isTouchingColorGpuFin(bounds, color3b, stop) {
    const gl = this._gl;
    const pixels = new Uint8Array(Math.floor(bounds.width * (bounds.height - stop) * 4));
    gl.readPixels(0, 0, bounds.width, bounds.height - stop, gl.RGBA, gl.UNSIGNED_BYTE, pixels);
    if (this._debugCanvas) {
      this._debugCanvas.width = bounds.width;
      this._debugCanvas.height = bounds.height;
      const context = this._debugCanvas.getContext('2d');
      const imageData = context.getImageData(0, 0, bounds.width, bounds.height - stop);
      imageData.data.set(pixels);
      context.putImageData(imageData, 0, 0);
    }
    for (let pixelBase = 0; pixelBase < pixels.length; pixelBase += 4) {
      // Transparent pixels are masked (either by the drawable's alpha channel or color mask).
      if (pixels[pixelBase + 3] !== 0 && colorMatches(color3b, pixels, pixelBase)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Check if a particular Drawable is touching any in a set of Drawables.
   * @param {int} drawableID The ID of the Drawable to check.
   * @param {?Array<int>} candidateIDs The Drawable IDs to check, otherwise all visible drawables in the renderer
   * @returns {boolean} True if the Drawable is touching one of candidateIDs.
   */
  isTouchingDrawables(drawableID) {
    let candidateIDs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this._drawList;
    const candidates = this._candidatesTouching(drawableID,
    // even if passed an invisible drawable, we will NEVER touch it!
    candidateIDs.filter(id => this._allDrawables[id]._visible));
    // if we are invisble we don't touch anything.
    if (candidates.length === 0 || !this._allDrawables[drawableID]._visible) {
      return false;
    }

    // Get the union of all the candidates intersections.
    const bounds = this._candidatesBounds(candidates);
    const drawable = this._allDrawables[drawableID];
    const point = __isTouchingDrawablesPoint;
    drawable.updateCPURenderAttributes();

    // This is an EXTREMELY brute force collision detector, but it is
    // still faster than asking the GPU to give us the pixels.
    for (let x = bounds.left; x <= bounds.right; x++) {
      // Scratch Space - +y is top
      point[0] = x;
      for (let y = bounds.bottom; y <= bounds.top; y++) {
        point[1] = y;
        if (drawable.isTouching(point)) {
          for (let index = 0; index < candidates.length; index++) {
            if (candidates[index].drawable.isTouching(point)) {
              return true;
            }
          }
        }
      }
    }
    return false;
  }

  /**
   * Convert a client based x/y position on the canvas to a Scratch 3 world space
   * Rectangle.  This creates recangles with a radius to cover selecting multiple
   * scratch pixels with touch / small render areas.
   *
   * @param {int} centerX The client x coordinate of the picking location.
   * @param {int} centerY The client y coordinate of the picking location.
   * @param {int} [width] The client width of the touch event (optional).
   * @param {int} [height] The client width of the touch event (optional).
   * @returns {Rectangle} Scratch world space rectangle, iterate bottom <= top,
   *                      left <= right.
   */
  clientSpaceToScratchBounds(centerX, centerY) {
    let width = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;
    let height = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;
    const gl = this._gl;
    const clientToScratchX = this._nativeSize[0] / gl.canvas.clientWidth;
    const clientToScratchY = this._nativeSize[1] / gl.canvas.clientHeight;
    width *= clientToScratchX;
    height *= clientToScratchY;
    width = Math.max(1, Math.min(Math.round(width), MAX_TOUCH_SIZE[0]));
    height = Math.max(1, Math.min(Math.round(height), MAX_TOUCH_SIZE[1]));
    const x = centerX * clientToScratchX - (width - 1) / 2;
    // + because scratch y is inverted
    const y = centerY * clientToScratchY + (height - 1) / 2;
    const xOfs = width % 2 ? 0 : -0.5;
    // y is offset +0.5
    const yOfs = height % 2 ? 0 : -0.5;
    const bounds = new Rectangle();
    bounds.initFromBounds(Math.floor(this._xLeft + x + xOfs), Math.floor(this._xLeft + x + xOfs + width - 1), Math.ceil(this._yTop - y + yOfs), Math.ceil(this._yTop - y + yOfs + height - 1));
    return bounds;
  }

  /**
   * Determine if the drawable is touching a client based x/y.  Helper method for sensing
   * touching mouse-pointer.  Ignores visibility.
   *
   * @param {int} drawableID The ID of the drawable to check.
   * @param {int} centerX The client x coordinate of the picking location.
   * @param {int} centerY The client y coordinate of the picking location.
   * @param {int} [touchWidth] The client width of the touch event (optional).
   * @param {int} [touchHeight] The client height of the touch event (optional).
   * @returns {boolean} If the drawable has any pixels that would draw in the touch area
   */
  drawableTouching(drawableID, centerX, centerY, touchWidth, touchHeight) {
    const drawable = this._allDrawables[drawableID];
    if (!drawable) {
      return false;
    }
    const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);
    const worldPos = twgl.v3.create();
    drawable.updateCPURenderAttributes();
    for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {
      for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {
        if (drawable.isTouching(worldPos)) {
          return true;
        }
      }
    }
    return false;
  }

  /**
   * Detect which sprite, if any, is at the given location.
   * This function will pick all drawables that are visible, unless specific
   * candidate drawable IDs are provided.  Used for determining what is clicked
   * or dragged.  Will not select hidden / ghosted sprites.
   *
   * @param {int} centerX The client x coordinate of the picking location.
   * @param {int} centerY The client y coordinate of the picking location.
   * @param {int} [touchWidth] The client width of the touch event (optional).
   * @param {int} [touchHeight] The client height of the touch event (optional).
   * @param {Array<int>} [candidateIDs] The Drawable IDs to pick from, otherwise all visible drawables.
   * @returns {int} The ID of the topmost Drawable under the picking location, or
   * RenderConstants.ID_NONE if there is no Drawable at that location.
   */
  pick(centerX, centerY, touchWidth, touchHeight, candidateIDs) {
    const bounds = this.clientSpaceToScratchBounds(centerX, centerY, touchWidth, touchHeight);
    if (bounds.left === -Infinity || bounds.bottom === -Infinity) {
      return false;
    }
    candidateIDs = (candidateIDs || this._drawList).filter(id => {
      const drawable = this._allDrawables[id];
      // default pick list ignores visible and ghosted sprites.
      if (drawable.getVisible() && drawable.getUniforms().u_ghost !== 0) {
        const drawableBounds = drawable.getFastBounds();
        const inRange = bounds.intersects(drawableBounds);
        if (!inRange) return false;
        drawable.updateCPURenderAttributes();
        return true;
      }
      return false;
    });
    if (candidateIDs.length === 0) {
      return false;
    }
    const hits = [];
    const worldPos = twgl.v3.create(0, 0, 0);
    // Iterate over the scratch pixels and check if any candidate can be
    // touched at that point.
    for (worldPos[1] = bounds.bottom; worldPos[1] <= bounds.top; worldPos[1]++) {
      for (worldPos[0] = bounds.left; worldPos[0] <= bounds.right; worldPos[0]++) {
        // Check candidates in the reverse order they would have been
        // drawn. This will determine what candiate's silhouette pixel
        // would have been drawn at the point.
        for (let d = candidateIDs.length - 1; d >= 0; d--) {
          const id = candidateIDs[d];
          const drawable = this._allDrawables[id];
          if (drawable.isTouching(worldPos)) {
            hits[id] = (hits[id] || 0) + 1;
            break;
          }
        }
      }
    }

    // Bias toward selecting anything over nothing
    hits[RenderConstants.ID_NONE] = 0;
    let hit = RenderConstants.ID_NONE;
    for (const hitID in hits) {
      if (Object.prototype.hasOwnProperty.call(hits, hitID) && hits[hitID] > hits[hit]) {
        hit = hitID;
      }
    }
    return Number(hit);
  }

  /**
   * @typedef DrawableExtraction
   * @property {ImageData} data Raw pixel data for the drawable
   * @property {number} x The x coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'
   * @property {number} y The y coordinate of the drawable's bounding box's top-left corner, in 'CSS pixels'
   * @property {number} width The drawable's bounding box width, in 'CSS pixels'
   * @property {number} height The drawable's bounding box height, in 'CSS pixels'
   */

  /**
   * Return a drawable's pixel data and bounds in screen space.
   * @param {int} drawableID The ID of the drawable to get pixel data for
   * @return {DrawableExtraction} Data about the picked drawable
   */
  extractDrawableScreenSpace(drawableID) {
    const drawable = this._allDrawables[drawableID];
    if (!drawable) throw new Error("Could not extract drawable with ID ".concat(drawableID, "; it does not exist"));
    this._doExitDrawRegion();
    const nativeCenterX = this._nativeSize[0] * 0.5;
    const nativeCenterY = this._nativeSize[1] * 0.5;
    const scratchBounds = drawable.getFastBounds();
    const canvas = this.canvas;
    // Ratio of the screen-space scale of the stage's canvas to the "native size" of the stage
    const scaleFactor = canvas.width / this._nativeSize[0];

    // Bounds of the extracted drawable, in "canvas pixel space"
    // (origin is 0, 0, destination is the canvas width, height).
    const canvasSpaceBounds = new Rectangle();
    canvasSpaceBounds.initFromBounds((scratchBounds.left + nativeCenterX) * scaleFactor, (scratchBounds.right + nativeCenterX) * scaleFactor,
    // in "canvas space", +y is down, but Rectangle methods assume bottom < top, so swap them
    (nativeCenterY - scratchBounds.top) * scaleFactor, (nativeCenterY - scratchBounds.bottom) * scaleFactor);
    canvasSpaceBounds.snapToInt();

    // undo the transformation to transform the bounds, snapped to "canvas-pixel space", back to "Scratch space"
    // We have to transform -> snap -> invert transform so that the "Scratch-space" bounds are snapped in
    // "canvas-pixel space".
    scratchBounds.initFromBounds(canvasSpaceBounds.left / scaleFactor - nativeCenterX, canvasSpaceBounds.right / scaleFactor - nativeCenterX, nativeCenterY - canvasSpaceBounds.top / scaleFactor, nativeCenterY - canvasSpaceBounds.bottom / scaleFactor);
    const gl = this._gl;

    // Set a reasonable max limit width and height for the bufferInfo bounds
    const maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
    const clampedWidth = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.width, maxTextureSize);
    const clampedHeight = Math.min(MAX_EXTRACTED_DRAWABLE_DIMENSION, canvasSpaceBounds.height, maxTextureSize);

    // Make a new bufferInfo since this._queryBufferInfo is limited to 480x360
    const bufferInfo = twgl.createFramebufferInfo(gl, [{
      format: gl.RGBA
    }], clampedWidth, clampedHeight);
    try {
      twgl.bindFramebufferInfo(gl, bufferInfo);

      // Limit size of viewport to the bounds around the target Drawable,
      // and create the projection matrix for the draw.
      gl.viewport(0, 0, clampedWidth, clampedHeight);
      const projection = twgl.m4.ortho(scratchBounds.left, scratchBounds.right, scratchBounds.top, scratchBounds.bottom, -1, 1);
      gl.clearColor(0, 0, 0, 0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      this._drawThese([drawableID], ShaderManager.DRAW_MODE.straightAlpha, projection, {
        // Don't apply the ghost effect. TODO: is this an intentional design decision?
        effectMask: ~ShaderManager.EFFECT_INFO.ghost.mask,
        // We're doing this in screen-space, so the framebuffer dimensions should be those of the canvas in
        // screen-space. This is used to ensure SVG skins are rendered at the proper resolution.
        framebufferWidth: canvas.width,
        framebufferHeight: canvas.height
      });
      const data = new Uint8Array(Math.floor(clampedWidth * clampedHeight * 4));
      gl.readPixels(0, 0, clampedWidth, clampedHeight, gl.RGBA, gl.UNSIGNED_BYTE, data);
      // readPixels can only read into a Uint8Array, but ImageData has to take a Uint8ClampedArray.
      // We can share the same underlying buffer between them to avoid having to copy any data.
      const imageData = new ImageData(new Uint8ClampedArray(data.buffer), clampedWidth, clampedHeight);

      // On high-DPI devices, the canvas' width (in canvas pixels) will be larger than its width in CSS pixels.
      // We want to return the CSS-space bounds,
      // so take into account the ratio between the canvas' pixel dimensions and its layout dimensions.
      // This is usually the same as 1 / window.devicePixelRatio, but if e.g. you zoom your browser window without
      // the canvas resizing, then it'll differ.
      const ratio = canvas.getBoundingClientRect().width / canvas.width;
      return {
        imageData,
        x: canvasSpaceBounds.left * ratio,
        y: canvasSpaceBounds.bottom * ratio,
        width: canvasSpaceBounds.width * ratio,
        height: canvasSpaceBounds.height * ratio
      };
    } finally {
      gl.deleteFramebuffer(bufferInfo.framebuffer);
    }
  }

  /**
   * @typedef ColorExtraction
   * @property {Uint8Array} data Raw pixel data for the drawable
   * @property {int} width Drawable bounding box width
   * @property {int} height Drawable bounding box height
   * @property {object} color Color object with RGBA properties at picked location
   */

  /**
   * Return drawable pixel data and color at a given position
   * @param {int} x The client x coordinate of the picking location.
   * @param {int} y The client y coordinate of the picking location.
   * @param {int} radius The client radius to extract pixels with.
   * @return {?ColorExtraction} Data about the picked color
   */
  extractColor(x, y, radius) {
    this._doExitDrawRegion();
    const scratchX = Math.round(this._nativeSize[0] * (x / this._gl.canvas.clientWidth - 0.5));
    const scratchY = Math.round(-this._nativeSize[1] * (y / this._gl.canvas.clientHeight - 0.5));
    const gl = this._gl;
    twgl.bindFramebufferInfo(gl, this._queryBufferInfo);
    const bounds = new Rectangle();
    bounds.initFromBounds(scratchX - radius, scratchX + radius, scratchY - radius, scratchY + radius);
    const pickX = scratchX - bounds.left;
    const pickY = bounds.top - scratchY;
    gl.viewport(0, 0, bounds.width, bounds.height);
    const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);
    gl.clearColor(...this._backgroundColor4f);
    gl.clear(gl.COLOR_BUFFER_BIT);
    this._drawThese(this._drawList, ShaderManager.DRAW_MODE.default, projection);
    const data = new Uint8Array(Math.floor(bounds.width * bounds.height * 4));
    gl.readPixels(0, 0, bounds.width, bounds.height, gl.RGBA, gl.UNSIGNED_BYTE, data);
    const pixelBase = Math.floor(4 * (pickY * bounds.width + pickX));
    const color = {
      r: data[pixelBase],
      g: data[pixelBase + 1],
      b: data[pixelBase + 2],
      a: data[pixelBase + 3]
    };
    if (this._debugCanvas) {
      this._debugCanvas.width = bounds.width;
      this._debugCanvas.height = bounds.height;
      const ctx = this._debugCanvas.getContext('2d');
      const imageData = ctx.createImageData(bounds.width, bounds.height);
      imageData.data.set(data);
      ctx.putImageData(imageData, 0, 0);
      ctx.strokeStyle = 'black';
      ctx.fillStyle = "rgba(".concat(color.r, ", ").concat(color.g, ", ").concat(color.b, ", ").concat(color.a, ")");
      ctx.rect(pickX - 4, pickY - 4, 8, 8);
      ctx.fill();
      ctx.stroke();
    }
    return {
      data: data,
      width: bounds.width,
      height: bounds.height,
      color: color
    };
  }

  /**
   * Get the candidate bounding box for a touching query.
   * @param {int} drawableID ID for drawable of query.
   * @return {?Rectangle} Rectangle bounds for touching query, or null.
   */
  _touchingBounds(drawableID) {
    const drawable = this._allDrawables[drawableID];

    /** @todo remove this once URL-based skin setting is removed. */
    if (!drawable.skin || !drawable.skin.getTexture([100, 100])) return null;
    const bounds = drawable.getFastBounds();

    // Limit queries to the stage size.
    bounds.clamp(this._xLeft, this._xRight, this._yBottom, this._yTop);

    // Use integer coordinates for queries - weird things happen
    // when you provide float width/heights to gl.viewport and projection.
    bounds.snapToInt();
    if (bounds.width === 0 || bounds.height === 0) {
      // No space to query.
      return null;
    }
    return bounds;
  }

  /**
   * Filter a list of candidates for a touching query into only those that
   * could possibly intersect the given bounds.
   * @param {int} drawableID - ID for drawable of query.
   * @param {Array<int>} candidateIDs - Candidates for touching query.
   * @return {?Array< {id, drawable, intersection} >} Filtered candidates with useful data.
   */
  _candidatesTouching(drawableID, candidateIDs) {
    const bounds = this._touchingBounds(drawableID);
    const result = [];
    if (bounds === null) {
      return result;
    }
    // iterate through the drawables list BACKWARDS - we want the top most item to be the first we check
    for (let index = candidateIDs.length - 1; index >= 0; index--) {
      const id = candidateIDs[index];
      if (id !== drawableID) {
        const drawable = this._allDrawables[id];
        // Text bubbles aren't considered in "touching" queries
        if (drawable.skin instanceof TextBubbleSkin) continue;
        if (drawable.skin && drawable._visible) {
          // Update the CPU position data
          drawable.updateCPURenderAttributes();
          const candidateBounds = drawable.getFastBounds();

          // Push bounds out to integers. If a drawable extends out into half a pixel, that half-pixel still
          // needs to be tested. Plus, in some areas we construct another rectangle from the union of these,
          // and iterate over its pixels (width * height). Turns out that doesn't work so well when the
          // width/height aren't integers.
          candidateBounds.snapToInt();
          if (bounds.intersects(candidateBounds)) {
            result.push({
              id,
              drawable,
              intersection: Rectangle.intersect(bounds, candidateBounds)
            });
          }
        }
      }
    }
    return result;
  }

  /**
   * Helper to get the union bounds from a set of candidates returned from the above method
   * @private
   * @param {Array<object>} candidates info from _candidatesTouching
   * @return {Rectangle} the outer bounding box union
   */
  _candidatesBounds(candidates) {
    return candidates.reduce((memo, _ref2) => {
      let {
        intersection
      } = _ref2;
      if (!memo) {
        return intersection;
      }
      // store the union of the two rectangles in our static rectangle instance
      return Rectangle.union(memo, intersection, __candidatesBounds);
    }, null);
  }

  /**
   * Update a drawable's skin.
   * @param {number} drawableID The drawable's id.
   * @param {number} skinId The skin to update to.
   */
  updateDrawableSkinId(drawableID, skinId) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.skin = this._allSkins[skinId];
  }

  /**
   * Update a drawable's position.
   * @param {number} drawableID The drawable's id.
   * @param {Array.<number>} position The new position.
   */
  updateDrawablePosition(drawableID, position) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updatePosition(position);
  }

  /**
   * Update a drawable's direction.
   * @param {number} drawableID The drawable's id.
   * @param {number} direction A new direction.
   */
  updateDrawableDirection(drawableID, direction) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updateDirection(direction);
  }

  /**
   * Update a drawable's scale.
   * @param {number} drawableID The drawable's id.
   * @param {Array.<number>} scale A new scale.
   */
  updateDrawableScale(drawableID, scale) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updateScale(scale);
  }

  /**
   * Update a drawable's direction and scale together.
   * @param {number} drawableID The drawable's id.
   * @param {number} direction A new direction.
   * @param {Array.<number>} scale A new scale.
   */
  updateDrawableDirectionScale(drawableID, direction, scale) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updateDirection(direction);
    drawable.updateScale(scale);
  }

  /**
   * Update a drawable's visibility.
   * @param {number} drawableID The drawable's id.
   * @param {boolean} visible Will the drawable be visible?
   */
  updateDrawableVisible(drawableID, visible) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updateVisible(visible);
  }

  /**
   * Update a drawable's visual effect.
   * @param {number} drawableID The drawable's id.
   * @param {string} effectName The effect to change.
   * @param {number} value A new effect value.
   */
  updateDrawableEffect(drawableID, effectName, value) {
    const drawable = this._allDrawables[drawableID];
    // TODO: https://github.com/LLK/scratch-vm/issues/2288
    if (!drawable) return;
    drawable.updateEffect(effectName, value);
  }

  /**
   * Update the position, direction, scale, or effect properties of this Drawable.
   * @deprecated Use specific updateDrawable* methods instead.
   * @param {int} drawableID The ID of the Drawable to update.
   * @param {object.<string,*>} properties The new property values to set.
   */
  updateDrawableProperties(drawableID, properties) {
    const drawable = this._allDrawables[drawableID];
    if (!drawable) {
      /**
       * @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.
       * Right now this happens so much on some projects that a warning or exception here can hang the browser.
       */
      return;
    }
    if ('skinId' in properties) {
      this.updateDrawableSkinId(drawableID, properties.skinId);
    }
    drawable.updateProperties(properties);
  }

  /**
   * Update the position object's x & y members to keep the drawable fenced in view.
   * @param {int} drawableID - The ID of the Drawable to update.
   * @param {Array.<number, number>} position to be fenced - An array of type [x, y]
   * @return {Array.<number, number>} The fenced position as an array [x, y]
   */
  getFencedPositionOfDrawable(drawableID, position) {
    let x = position[0];
    let y = position[1];
    const drawable = this._allDrawables[drawableID];
    if (!drawable) {
      // @todo(https://github.com/LLK/scratch-vm/issues/2288) fix whatever's wrong in the VM which causes this, then add a warning or throw here.
      // Right now this happens so much on some projects that a warning or exception here can hang the browser.
      return [x, y];
    }
    const dx = x - drawable._position[0];
    const dy = y - drawable._position[1];
    const aabb = drawable._skin.getFenceBounds(drawable, __fenceBounds);
    const inset = Math.floor(Math.min(aabb.width, aabb.height) / 2);
    const sx = this._xRight - Math.min(FENCE_WIDTH, inset);
    if (aabb.right + dx < -sx) {
      x = Math.ceil(drawable._position[0] - (sx + aabb.right));
    } else if (aabb.left + dx > sx) {
      x = Math.floor(drawable._position[0] + (sx - aabb.left));
    }
    const sy = this._yTop - Math.min(FENCE_WIDTH, inset);
    if (aabb.top + dy < -sy) {
      y = Math.ceil(drawable._position[1] - (sy + aabb.top));
    } else if (aabb.bottom + dy > sy) {
      y = Math.floor(drawable._position[1] + (sy - aabb.bottom));
    }
    return [x, y];
  }

  /**
   * Clear a pen layer.
   * @param {int} penSkinID - the unique ID of a Pen Skin.
   */
  penClear(penSkinID) {
    const skin = /** @type {PenSkin} */this._allSkins[penSkinID];
    skin.clear();
  }

  /**
   * Draw a point on a pen layer.
   * @param {int} penSkinID - the unique ID of a Pen Skin.
   * @param {PenAttributes} penAttributes - how the point should be drawn.
   * @param {number} x - the X coordinate of the point to draw.
   * @param {number} y - the Y coordinate of the point to draw.
   */
  penPoint(penSkinID, penAttributes, x, y) {
    const skin = /** @type {PenSkin} */this._allSkins[penSkinID];
    skin.drawPoint(penAttributes, x, y);
  }

  /**
   * Draw a line on a pen layer.
   * @param {int} penSkinID - the unique ID of a Pen Skin.
   * @param {PenAttributes} penAttributes - how the line should be drawn.
   * @param {number} x0 - the X coordinate of the beginning of the line.
   * @param {number} y0 - the Y coordinate of the beginning of the line.
   * @param {number} x1 - the X coordinate of the end of the line.
   * @param {number} y1 - the Y coordinate of the end of the line.
   */
  penLine(penSkinID, penAttributes, x0, y0, x1, y1) {
    const skin = /** @type {PenSkin} */this._allSkins[penSkinID];
    skin.drawLine(penAttributes, x0, y0, x1, y1);
  }

  /**
   * Stamp a Drawable onto a pen layer.
   * @param {int} penSkinID - the unique ID of a Pen Skin.
   * @param {int} stampID - the unique ID of the Drawable to use as the stamp.
   */
  penStamp(penSkinID, stampID) {
    const stampDrawable = this._allDrawables[stampID];
    if (!stampDrawable) {
      return;
    }
    const bounds = this._touchingBounds(stampID);
    if (!bounds) {
      return;
    }
    this._doExitDrawRegion();
    const skin = /** @type {PenSkin} */this._allSkins[penSkinID];
    const gl = this._gl;
    twgl.bindFramebufferInfo(gl, skin._framebuffer);

    // Limit size of viewport to the bounds around the stamp Drawable and create the projection matrix for the draw.
    gl.viewport(this._nativeSize[0] * 0.5 + bounds.left, this._nativeSize[1] * 0.5 - bounds.top, bounds.width, bounds.height);
    const projection = twgl.m4.ortho(bounds.left, bounds.right, bounds.top, bounds.bottom, -1, 1);

    // Draw the stamped sprite onto the PenSkin's framebuffer.
    this._drawThese([stampID], ShaderManager.DRAW_MODE.default, projection, {
      ignoreVisibility: true
    });
    skin._silhouetteDirty = true;
  }

  /* ******
   * Truly internal functions: these support the functions above.
   ********/

  /**
   * Build geometry (vertex and index) buffers.
   * @private
   */
  _createGeometry() {
    const quad = {
      a_position: {
        numComponents: 2,
        data: [-0.5, -0.5, 0.5, -0.5, -0.5, 0.5, -0.5, 0.5, 0.5, -0.5, 0.5, 0.5]
      },
      a_texCoord: {
        numComponents: 2,
        data: [1, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1]
      }
    };
    this._bufferInfo = twgl.createBufferInfoFromArrays(this._gl, quad);
  }

  /**
   * Respond to a change in the "native" rendering size. The native size is used by buffers which are fixed in size
   * regardless of the size of the main render target. This includes the buffers used for queries such as picking and
   * color-touching. The fixed size allows (more) consistent behavior across devices and presentation modes.
   * @param {object} event - The change event.
   * @private
   */
  onNativeSizeChanged(event) {
    const [width, height] = event.newSize;
    const gl = this._gl;
    const attachments = [{
      format: gl.RGBA
    }, {
      format: gl.DEPTH_STENCIL
    }];
    if (!this._pickBufferInfo) {
      this._pickBufferInfo = twgl.createFramebufferInfo(gl, attachments, MAX_TOUCH_SIZE[0], MAX_TOUCH_SIZE[1]);
    }

    /** @todo should we create this on demand to save memory? */
    // A 480x360 32-bpp buffer is 675 KiB.
    if (this._queryBufferInfo) {
      twgl.resizeFramebufferInfo(gl, this._queryBufferInfo, attachments, width, height);
    } else {
      this._queryBufferInfo = twgl.createFramebufferInfo(gl, attachments, width, height);
    }
  }

  /**
   * Enter a draw region.
   *
   * A draw region is where multiple draw operations are performed with the
   * same GL state. WebGL performs poorly when it changes state like blend
   * mode. Marking a collection of state values as a "region" the renderer
   * can skip superfluous extra state calls when it is already in that
   * region. Since one region may be entered from within another a exit
   * handle can also be registered that is called when a new region is about
   * to be entered to restore a common inbetween state.
   *
   * @param {any} regionId - id of the region to enter
   * @param {function} enter - handle to call when first entering a region
   * @param {function} exit - handle to call when leaving a region
   */
  enterDrawRegion(regionId) {
    let enter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : regionId.enter;
    let exit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : regionId.exit;
    if (this._regionId !== regionId) {
      this._doExitDrawRegion();
      this._regionId = regionId;
      enter();
      this._exitRegion = exit;
    }
  }

  /**
   * Forcefully exit the current region returning to a common inbetween GL
   * state.
   */
  _doExitDrawRegion() {
    if (this._exitRegion !== null) {
      this._exitRegion();
    }
    this._exitRegion = null;
    this._regionId = null;
  }

  /**
   * Draw a set of Drawables, by drawable ID
   * @param {Array<int>} drawables The Drawable IDs to draw, possibly this._drawList.
   * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.
   * @param {module:twgl/m4.Mat4} projection The projection matrix to use.
   * @param {object} [opts] Options for drawing
   * @param {idFilterFunc} opts.filter An optional filter function.
   * @param {object.<string,*>} opts.extraUniforms Extra uniforms for the shaders.
   * @param {int} opts.effectMask Bitmask for effects to allow
   * @param {boolean} opts.ignoreVisibility Draw all, despite visibility (e.g. stamping, touching color)
   * @param {int} opts.framebufferWidth The width of the framebuffer being drawn onto. Defaults to "native" width
   * @param {int} opts.framebufferHeight The height of the framebuffer being drawn onto. Defaults to "native" height
   * @private
   */
  _drawThese(drawables, drawMode, projection) {
    let opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};
    const gl = this._gl;
    let currentShader = null;
    const framebufferSpaceScaleDiffers = 'framebufferWidth' in opts && 'framebufferHeight' in opts && opts.framebufferWidth !== this._nativeSize[0] && opts.framebufferHeight !== this._nativeSize[1];
    const numDrawables = drawables.length;
    for (let drawableIndex = 0; drawableIndex < numDrawables; ++drawableIndex) {
      const drawableID = drawables[drawableIndex];

      // If we have a filter, check whether the ID fails
      if (opts.filter && !opts.filter(drawableID)) continue;
      const drawable = this._allDrawables[drawableID];
      /** @todo check if drawable is inside the viewport before anything else */

      // Hidden drawables (e.g., by a "hide" block) are not drawn unless
      // the ignoreVisibility flag is used (e.g. for stamping or touchingColor).
      if (!drawable.getVisible() && !opts.ignoreVisibility) continue;

      // drawableScale is the "framebuffer-pixel-space" scale of the drawable, as percentages of the drawable's
      // "native size" (so 100 = same as skin's "native size", 200 = twice "native size").
      // If the framebuffer dimensions are the same as the stage's "native" size, there's no need to calculate it.
      const drawableScale = framebufferSpaceScaleDiffers ? [drawable.scale[0] * opts.framebufferWidth / this._nativeSize[0], drawable.scale[1] * opts.framebufferHeight / this._nativeSize[1]] : drawable.scale;

      // If the skin or texture isn't ready yet, skip it.
      if (!drawable.skin || !drawable.skin.getTexture(drawableScale)) continue;
      const uniforms = {};
      let effectBits = drawable.enabledEffects;
      effectBits &= Object.prototype.hasOwnProperty.call(opts, 'effectMask') ? opts.effectMask : effectBits;
      const newShader = this._shaderManager.getShader(drawMode, effectBits);

      // Manually perform region check. Do not create functions inside a
      // loop.
      if (this._regionId !== newShader) {
        this._doExitDrawRegion();
        this._regionId = newShader;
        currentShader = newShader;
        gl.useProgram(currentShader.program);
        twgl.setBuffersAndAttributes(gl, currentShader, this._bufferInfo);
        Object.assign(uniforms, {
          u_projectionMatrix: projection
        });
      }
      Object.assign(uniforms, drawable.skin.getUniforms(drawableScale), drawable.getUniforms());

      // Apply extra uniforms after the Drawable's, to allow overwriting.
      if (opts.extraUniforms) {
        Object.assign(uniforms, opts.extraUniforms);
      }
      if (uniforms.u_skin) {
        twgl.setTextureParameters(gl, uniforms.u_skin, {
          minMag: drawable.skin.useNearest(drawableScale, drawable) ? gl.NEAREST : gl.LINEAR
        });
      }
      twgl.setUniforms(currentShader, uniforms);
      twgl.drawBufferInfo(gl, this._bufferInfo, gl.TRIANGLES);
    }
    this._regionId = null;
  }

  /**
   * Get the convex hull points for a particular Drawable.
   * To do this, calculate it based on the drawable's Silhouette.
   * @param {int} drawableID The Drawable IDs calculate convex hull for.
   * @return {Array<Array<number>>} points Convex hull points, as [[x, y], ...]
   */
  _getConvexHullPointsForDrawable(drawableID) {
    const drawable = this._allDrawables[drawableID];
    const [width, height] = drawable.skin.size;
    // No points in the hull if invisible or size is 0.
    if (!drawable.getVisible() || width === 0 || height === 0) {
      return [];
    }
    drawable.updateCPURenderAttributes();

    /**
     * Return the determinant of two vectors, the vector from A to B and the vector from A to C.
     *
     * The determinant is useful in this case to know if AC is counter-clockwise from AB.
     * A positive value means that AC is counter-clockwise from AB. A negative value means AC is clockwise from AB.
     *
     * @param {Float32Array} A A 2d vector in space.
     * @param {Float32Array} B A 2d vector in space.
     * @param {Float32Array} C A 2d vector in space.
     * @return {number} Greater than 0 if counter clockwise, less than if clockwise, 0 if all points are on a line.
     */
    const determinant = function determinant(A, B, C) {
      // AB = B - A
      // AC = C - A
      // det (AB BC) = AB0 * AC1 - AB1 * AC0
      return (B[0] - A[0]) * (C[1] - A[1]) - (B[1] - A[1]) * (C[0] - A[0]);
    };

    // This algorithm for calculating the convex hull somewhat resembles the monotone chain algorithm.
    // The main difference is that instead of sorting the points by x-coordinate, and y-coordinate in case of ties,
    // it goes through them by y-coordinate in the outer loop and x-coordinate in the inner loop.
    // This gives us "left" and "right" hulls, whereas the monotone chain algorithm gives "top" and "bottom" hulls.
    // Adapted from https://github.com/LLK/scratch-flash/blob/dcbeeb59d44c3be911545dfe54d46a32404f8e69/src/scratch/ScratchCostume.as#L369-L413

    const leftHull = [];
    const rightHull = [];

    // While convex hull algorithms usually push and pop values from the list of hull points,
    // here, we keep indices for the "last" point in each array. Any points past these indices are ignored.
    // This is functionally equivalent to pushing and popping from a "stack" of hull points.
    let leftEndPointIndex = -1;
    let rightEndPointIndex = -1;
    const _pixelPos = twgl.v3.create();
    const _effectPos = twgl.v3.create();
    let currentPoint;

    // *Not* Scratch Space-- +y is bottom
    // Loop over all rows of pixels, starting at the top
    for (let y = 0; y < height; y++) {
      _pixelPos[1] = y / height;

      // We start at the leftmost point, then go rightwards until we hit an opaque pixel
      let x = 0;
      for (; x < width; x++) {
        _pixelPos[0] = x / width;
        EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);
        if (drawable.skin.isTouchingLinear(_effectPos)) {
          currentPoint = [x, y];
          break;
        }
      }

      // If we managed to loop all the way through, there are no opaque pixels on this row. Go to the next one
      if (x >= width) {
        continue;
      }

      // Because leftEndPointIndex is initialized to -1, this is skipped for the first two rows.
      // It runs only when there are enough points in the left hull to make at least one line.
      // If appending the current point to the left hull makes a counter-clockwise turn,
      // we want to append the current point. Otherwise, we decrement the index of the "last" hull point until the
      // current point makes a counter-clockwise turn.
      // This decrementing has the same effect as popping from the point list, but is hopefully faster.
      while (leftEndPointIndex > 0) {
        if (determinant(leftHull[leftEndPointIndex], leftHull[leftEndPointIndex - 1], currentPoint) > 0) {
          break;
        } else {
          // leftHull.pop();
          --leftEndPointIndex;
        }
      }

      // This has the same effect as pushing to the point list.
      // This "list head pointer" coding style leaves excess points dangling at the end of the list,
      // but that doesn't matter; we simply won't copy them over to the final hull.

      // leftHull.push(currentPoint);
      leftHull[++leftEndPointIndex] = currentPoint;

      // Now we repeat the process for the right side, looking leftwards for a pixel.
      for (x = width - 1; x >= 0; x--) {
        _pixelPos[0] = x / width;
        EffectTransform.transformPoint(drawable, _pixelPos, _effectPos);
        if (drawable.skin.isTouchingLinear(_effectPos)) {
          currentPoint = [x, y];
          break;
        }
      }

      // Because we're coming at this from the right, it goes clockwise this time.
      while (rightEndPointIndex > 0) {
        if (determinant(rightHull[rightEndPointIndex], rightHull[rightEndPointIndex - 1], currentPoint) < 0) {
          break;
        } else {
          --rightEndPointIndex;
        }
      }
      rightHull[++rightEndPointIndex] = currentPoint;
    }

    // Start off "hullPoints" with the left hull points.
    const hullPoints = leftHull;
    // This is where we get rid of those dangling extra points.
    hullPoints.length = leftEndPointIndex + 1;
    // Add points from the right side in reverse order so all points are ordered clockwise.
    for (let j = rightEndPointIndex; j >= 0; --j) {
      hullPoints.push(rightHull[j]);
    }

    // Simplify boundary points using hull.js.
    // TODO: Remove this; this algorithm already generates convex hulls.
    return hull(hullPoints, Infinity);
  }

  /**
   * Sample a "final" color from an array of drawables at a given scratch space.
   * Will blend any alpha values with the drawables "below" it.
   * @param {twgl.v3} vec Scratch Vector Space to sample
   * @param {Array<Drawables>} drawables A list of drawables with the "top most"
   *              drawable at index 0
   * @param {Uint8ClampedArray} dst The color3b space to store the answer in.
   * @return {Uint8ClampedArray} The dst vector with everything blended down.
   */
  static sampleColor3b(vec, drawables, dst) {
    dst = dst || new Uint8ClampedArray(3);
    dst.fill(0);
    let blendAlpha = 1;
    for (let index = 0; blendAlpha !== 0 && index < drawables.length; index++) {
      /*
      if (left > vec[0] || right < vec[0] ||
          bottom > vec[1] || top < vec[0]) {
          continue;
      }
      */
      Drawable.sampleColor4b(vec, drawables[index].drawable, __blendColor);
      // Equivalent to gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA)
      dst[0] += __blendColor[0] * blendAlpha;
      dst[1] += __blendColor[1] * blendAlpha;
      dst[2] += __blendColor[2] * blendAlpha;
      blendAlpha *= 1 - __blendColor[3] / 255;
    }
    // Backdrop could be transparent, so we need to go to the "clear color" of the
    // draw scene (white) as a fallback if everything was alpha
    dst[0] += blendAlpha * 255;
    dst[1] += blendAlpha * 255;
    dst[2] += blendAlpha * 255;
    return dst;
  }

  /**
   * @callback RenderWebGL#snapshotCallback
   * @param {string} dataURI Data URI of the snapshot of the renderer
   */

  /**
   * @param {snapshotCallback} callback Function called in the next frame with the snapshot data
   */
  requestSnapshot(callback) {
    this._snapshotCallbacks.push(callback);
  }
}

// :3
RenderWebGL.prototype.canHazPixels = RenderWebGL.prototype.extractDrawableScreenSpace;

/**
 * Values for setUseGPU()
 * @enum {string}
 */
RenderWebGL.UseGpuModes = {
  /**
   * Heuristically decide whether to use the GPU path, the CPU path, or a dynamic mixture of the two.
   */
  Automatic: 'Automatic',
  /**
   * Always use the GPU path.
   */
  ForceGPU: 'ForceGPU',
  /**
   * Always use the CPU path.
   */
  ForceCPU: 'ForceCPU'
};
module.exports = RenderWebGL;

/***/ }),

/***/ "./node_modules/scratch-render/src/SVGSkin.js":
/*!****************************************************!*\
  !*** ./node_modules/scratch-render/src/SVGSkin.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const Skin = __webpack_require__(/*! ./Skin */ "./node_modules/scratch-render/src/Skin.js");
const {
  loadSvgString,
  serializeSvgToString
} = __webpack_require__(/*! scratch-svg-renderer */ "./node_modules/scratch-svg-renderer/src/index.js");
const ShaderManager = __webpack_require__(/*! ./ShaderManager */ "./node_modules/scratch-render/src/ShaderManager.js");
const MAX_TEXTURE_DIMENSION = 2048;

/**
 * All scaled renderings of the SVG are stored in an array. The 1.0 scale of
 * the SVG is stored at the 8th index. The smallest possible 1 / 256 scale
 * rendering is stored at the 0th index.
 * @const {number}
 */
const INDEX_OFFSET = 8;
class SVGSkin extends Skin {
  /**
   * Create a new SVG skin.
   * @param {!int} id - The ID for this Skin.
   * @param {!RenderWebGL} renderer - The renderer which will use this skin.
   * @constructor
   * @extends Skin
   */
  constructor(id, renderer) {
    super(id);

    /** @type {RenderWebGL} */
    this._renderer = renderer;

    /** @type {HTMLImageElement} */
    this._svgImage = document.createElement('img');

    /** @type {boolean} */
    this._svgImageLoaded = false;

    /** @type {Array<number>} */
    this._size = [0, 0];

    /** @type {HTMLCanvasElement} */
    this._canvas = document.createElement('canvas');

    /** @type {CanvasRenderingContext2D} */
    this._context = this._canvas.getContext('2d');

    /** @type {Array<WebGLTexture>} */
    this._scaledMIPs = [];

    /** @type {number} */
    this._largestMIPScale = 0;

    /**
    * Ratio of the size of the SVG and the max size of the WebGL texture
    * @type {Number}
    */
    this._maxTextureScale = 1;
  }

  /**
   * Dispose of this object. Do not use it after calling this method.
   */
  dispose() {
    this.resetMIPs();
    super.dispose();
  }

  /**
   * @return {Array<number>} the natural size, in Scratch units, of this skin.
   */
  get size() {
    return [this._size[0], this._size[1]];
  }
  useNearest(scale, drawable) {
    // If the effect bits for mosaic, pixelate, whirl, or fisheye are set, use linear
    if ((drawable.enabledEffects & (ShaderManager.EFFECT_INFO.fisheye.mask | ShaderManager.EFFECT_INFO.whirl.mask | ShaderManager.EFFECT_INFO.pixelate.mask | ShaderManager.EFFECT_INFO.mosaic.mask)) !== 0) {
      return false;
    }

    // We can't use nearest neighbor unless we are a multiple of 90 rotation
    if (drawable._direction % 90 !== 0) {
      return false;
    }

    // Because SVG skins' bounding boxes are currently not pixel-aligned, the idea here is to hide blurriness
    // by using nearest-neighbor scaling if one screen-space pixel is "close enough" to one texture pixel.
    // If the scale of the skin is very close to 100 (0.99999 variance is okay I guess)
    // TODO: Make this check more precise. We should use nearest if there's less than one pixel's difference
    // between the screen-space and texture-space sizes of the skin. Mipmaps make this harder because there are
    // multiple textures (and hence multiple texture spaces) and we need to know which one to choose.
    if (Math.abs(scale[0]) > 99 && Math.abs(scale[0]) < 101 && Math.abs(scale[1]) > 99 && Math.abs(scale[1]) < 101) {
      return true;
    }
    return false;
  }

  /**
   * Create a MIP for a given scale.
   * @param {number} scale - The relative size of the MIP
   * @return {SVGMIP} An object that handles creating and updating SVG textures.
   */
  createMIP(scale) {
    const [width, height] = this._size;
    this._canvas.width = width * scale;
    this._canvas.height = height * scale;
    if (this._canvas.width <= 0 || this._canvas.height <= 0 ||
    // Even if the canvas at the current scale has a nonzero size, the image's dimensions are floored
    // pre-scaling; e.g. if an image has a width of 0.4 and is being rendered at 3x scale, the canvas will have
    // a width of 1, but the image's width will be rounded down to 0 on some browsers (Firefox) prior to being
    // drawn at that scale, resulting in an IndexSizeError if we attempt to draw it.
    this._svgImage.naturalWidth <= 0 || this._svgImage.naturalHeight <= 0) return super.getTexture();
    this._context.clearRect(0, 0, this._canvas.width, this._canvas.height);
    this._context.setTransform(scale, 0, 0, scale, 0, 0);
    this._context.drawImage(this._svgImage, 0, 0);

    // Pull out the ImageData from the canvas. ImageData speeds up
    // updating Silhouette and is better handled by more browsers in
    // regards to memory.
    const textureData = this._context.getImageData(0, 0, this._canvas.width, this._canvas.height);
    const textureOptions = {
      auto: false,
      wrap: this._renderer.gl.CLAMP_TO_EDGE,
      src: textureData,
      premultiplyAlpha: true
    };
    const mip = twgl.createTexture(this._renderer.gl, textureOptions);

    // Check if this is the largest MIP created so far. Currently, silhouettes only get scaled up.
    if (this._largestMIPScale < scale) {
      this._silhouette.update(textureData);
      this._largestMIPScale = scale;
    }
    return mip;
  }
  updateSilhouette() {
    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [100, 100];
    // Ensure a silhouette exists.
    this.getTexture(scale);
  }

  /**
   * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.
   * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.
   */
  getTexture(scale) {
    // The texture only ever gets uniform scale. Take the larger of the two axes.
    const scaleMax = scale ? Math.max(Math.abs(scale[0]), Math.abs(scale[1])) : 100;
    const requestedScale = Math.min(scaleMax / 100, this._maxTextureScale);

    // Math.ceil(Math.log2(scale)) means we use the "1x" texture at (0.5, 1] scale,
    // the "2x" texture at (1, 2] scale, the "4x" texture at (2, 4] scale, etc.
    // This means that one texture pixel will always be between 0.5x and 1x the size of one rendered pixel,
    // but never bigger than one rendered pixel--this prevents blurriness from blowing up the texture too much.
    const mipLevel = Math.max(Math.ceil(Math.log2(requestedScale)) + INDEX_OFFSET, 0);
    // Can't use bitwise stuff here because we need to handle negative exponents
    const mipScale = Math.pow(2, mipLevel - INDEX_OFFSET);
    if (this._svgImageLoaded && !this._scaledMIPs[mipLevel]) {
      this._scaledMIPs[mipLevel] = this.createMIP(mipScale);
    }
    return this._scaledMIPs[mipLevel] || super.getTexture();
  }

  /**
   * Do a hard reset of the existing MIPs by deleting them.
   */
  resetMIPs() {
    this._scaledMIPs.forEach(oldMIP => this._renderer.gl.deleteTexture(oldMIP));
    this._scaledMIPs.length = 0;
    this._largestMIPScale = 0;
  }

  /**
   * Set the contents of this skin to a snapshot of the provided SVG data.
   * @param {string} svgData - new SVG to use.
   * @param {Array<number>} [rotationCenter] - Optional rotation center for the SVG. If not supplied, it will be
   * calculated from the bounding box
   * @fires Skin.event:WasAltered
   */
  setSVG(svgData, rotationCenter) {
    const svgTag = loadSvgString(svgData);
    const svgText = serializeSvgToString(svgTag, true /* shouldInjectFonts */);
    this._svgImageLoaded = false;
    const {
      x,
      y,
      width,
      height
    } = svgTag.viewBox.baseVal;
    // While we're setting the size before the image is loaded, this doesn't cause the skin to appear with the wrong
    // size for a few frames while the new image is loading, because we don't emit the `WasAltered` event, telling
    // drawables using this skin to update, until the image is loaded.
    // We need to do this because the VM reads the skin's `size` directly after calling `setSVG`.
    // TODO: return a Promise so that the VM can read the skin's `size` after the image is loaded.
    this._size[0] = width;
    this._size[1] = height;

    // If there is another load already in progress, replace the old onload to effectively cancel the old load
    this._svgImage.onload = () => {
      if (width === 0 || height === 0) {
        super.setEmptyImageData();
        return;
      }
      const maxDimension = Math.ceil(Math.max(width, height));
      let testScale = 2;
      for (testScale; maxDimension * testScale <= MAX_TEXTURE_DIMENSION; testScale *= 2) {
        this._maxTextureScale = testScale;
      }
      this.resetMIPs();
      if (typeof rotationCenter === 'undefined') rotationCenter = this.calculateRotationCenter();
      // Compensate for viewbox offset.
      // See https://github.com/LLK/scratch-render/pull/90.
      this._rotationCenter[0] = rotationCenter[0] - x;
      this._rotationCenter[1] = rotationCenter[1] - y;
      this._svgImageLoaded = true;
      this.emit(Skin.Events.WasAltered);
    };
    this._svgImage.src = "data:image/svg+xml;utf8,".concat(encodeURIComponent(svgText));
  }
}
module.exports = SVGSkin;

/***/ }),

/***/ "./node_modules/scratch-render/src/ShaderManager.js":
/*!**********************************************************!*\
  !*** ./node_modules/scratch-render/src/ShaderManager.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
class ShaderManager {
  /**
   * @param {WebGLRenderingContext} gl WebGL rendering context to create shaders for
   * @constructor
   */
  constructor(gl) {
    this._gl = gl;

    /**
     * The cache of all shaders compiled so far, filled on demand.
     * @type {Object<ShaderManager.DRAW_MODE, Array<ProgramInfo>>}
     * @private
     */
    this._shaderCache = {};
    for (const modeName in ShaderManager.DRAW_MODE) {
      if (Object.prototype.hasOwnProperty.call(ShaderManager.DRAW_MODE, modeName)) {
        this._shaderCache[modeName] = [];
      }
    }
  }

  /**
   * Fetch the shader for a particular set of active effects.
   * Build the shader if necessary.
   * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.
   * @param {int} effectBits Bitmask representing the enabled effects.
   * @returns {ProgramInfo} The shader's program info.
   */
  getShader(drawMode, effectBits) {
    const cache = this._shaderCache[drawMode];
    if (drawMode === ShaderManager.DRAW_MODE.silhouette) {
      // Silhouette mode isn't affected by these effects.
      effectBits &= ~(ShaderManager.EFFECT_INFO.color.mask | ShaderManager.EFFECT_INFO.brightness.mask);
    }
    let shader = cache[effectBits];
    if (!shader) {
      shader = cache[effectBits] = this._buildShader(drawMode, effectBits);
    }
    return shader;
  }

  /**
   * Build the shader for a particular set of active effects.
   * @param {ShaderManager.DRAW_MODE} drawMode Draw normally, silhouette, etc.
   * @param {int} effectBits Bitmask representing the enabled effects.
   * @returns {ProgramInfo} The new shader's program info.
   * @private
   */
  _buildShader(drawMode, effectBits) {
    const numEffects = ShaderManager.EFFECTS.length;
    const defines = ["#define DRAW_MODE_".concat(drawMode)];
    for (let index = 0; index < numEffects; ++index) {
      if ((effectBits & 1 << index) !== 0) {
        defines.push("#define ENABLE_".concat(ShaderManager.EFFECTS[index]));
      }
    }
    const definesText = "".concat(defines.join('\n'), "\n");

    /* eslint-disable global-require */
    const vsFullText = definesText + __webpack_require__(/*! raw-loader!./shaders/sprite.vert */ "./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.vert");
    const fsFullText = definesText + __webpack_require__(/*! raw-loader!./shaders/sprite.frag */ "./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.frag");
    /* eslint-enable global-require */

    return twgl.createProgramInfo(this._gl, [vsFullText, fsFullText]);
  }
}

/**
 * @typedef {object} ShaderManager.Effect
 * @prop {int} mask - The bit in 'effectBits' representing the effect.
 * @prop {function} converter - A conversion function which takes a Scratch value (generally in the range
 *   0..100 or -100..100) and maps it to a value useful to the shader. This
 *   mapping may not be reversible.
 * @prop {boolean} shapeChanges - Whether the effect could change the drawn shape.
 */

/**
 * Mapping of each effect name to info about that effect.
 * @enum {ShaderManager.Effect}
 */
ShaderManager.EFFECT_INFO = {
  /** Color effect */
  color: {
    uniformName: 'u_color',
    mask: 1 << 0,
    converter: x => x / 200 % 1,
    shapeChanges: false
  },
  /** Fisheye effect */
  fisheye: {
    uniformName: 'u_fisheye',
    mask: 1 << 1,
    converter: x => Math.max(0, (x + 100) / 100),
    shapeChanges: true
  },
  /** Whirl effect */
  whirl: {
    uniformName: 'u_whirl',
    mask: 1 << 2,
    converter: x => -x * Math.PI / 180,
    shapeChanges: true
  },
  /** Pixelate effect */
  pixelate: {
    uniformName: 'u_pixelate',
    mask: 1 << 3,
    converter: x => Math.abs(x) / 10,
    shapeChanges: true
  },
  /** Mosaic effect */
  mosaic: {
    uniformName: 'u_mosaic',
    mask: 1 << 4,
    converter: x => {
      x = Math.round((Math.abs(x) + 10) / 10);
      /** @todo cap by Math.min(srcWidth, srcHeight) */
      return Math.max(1, Math.min(x, 512));
    },
    shapeChanges: true
  },
  /** Brightness effect */
  brightness: {
    uniformName: 'u_brightness',
    mask: 1 << 5,
    converter: x => Math.max(-100, Math.min(x, 100)) / 100,
    shapeChanges: false
  },
  /** Ghost effect */
  ghost: {
    uniformName: 'u_ghost',
    mask: 1 << 6,
    converter: x => 1 - Math.max(0, Math.min(x, 100)) / 100,
    shapeChanges: false
  }
};

/**
 * The name of each supported effect.
 * @type {Array}
 */
ShaderManager.EFFECTS = Object.keys(ShaderManager.EFFECT_INFO);

/**
 * The available draw modes.
 * @readonly
 * @enum {string}
 */
ShaderManager.DRAW_MODE = {
  /**
   * Draw normally. Its output will use premultiplied alpha.
   */
  default: 'default',
  /**
   * Draw with non-premultiplied alpha. Useful for reading pixels from GL into an ImageData object.
   */
  straightAlpha: 'straightAlpha',
  /**
   * Draw a silhouette using a solid color.
   */
  silhouette: 'silhouette',
  /**
   * Draw only the parts of the drawable which match a particular color.
   */
  colorMask: 'colorMask',
  /**
   * Draw a line with caps.
   */
  line: 'line',
  /**
   * Draw the background in a certain color. Must sometimes be used instead of gl.clear.
   */
  background: 'background'
};
module.exports = ShaderManager;

/***/ }),

/***/ "./node_modules/scratch-render/src/Silhouette.js":
/*!*******************************************************!*\
  !*** ./node_modules/scratch-render/src/Silhouette.js ***!
  \*******************************************************/
/***/ ((module) => {

/**
 * @fileoverview
 * A representation of a Skin's silhouette that can test if a point on the skin
 * renders a pixel where it is drawn.
 */

/**
 * <canvas> element used to update Silhouette data from skin bitmap data.
 * @type {CanvasElement}
 */
let __SilhouetteUpdateCanvas;

// Optimized Math.min and Math.max for integers;
// taken from https://web.archive.org/web/20190716181049/http://guihaire.com/code/?p=549
const intMin = (i, j) => j ^ (i ^ j) & i - j >> 31;
const intMax = (i, j) => i ^ (i ^ j) & i - j >> 31;

/**
 * Internal helper function (in hopes that compiler can inline).  Get a pixel
 * from silhouette data, or 0 if outside it's bounds.
 * @private
 * @param {Silhouette} silhouette - has data width and height
 * @param {number} x - x
 * @param {number} y - y
 * @return {number} Alpha value for x/y position
 */
const getPoint = (_ref, x, y) => {
  let {
    _width: width,
    _height: height,
    _colorData: data
  } = _ref;
  // 0 if outside bounds, otherwise read from data.
  if (x >= width || y >= height || x < 0 || y < 0) {
    return 0;
  }
  return data[(y * width + x) * 4 + 3];
};

/**
 * Memory buffers for doing 4 corner sampling for linear interpolation
 */
const __cornerWork = [new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4), new Uint8ClampedArray(4)];

/**
 * Get the color from a given silhouette at an x/y local texture position.
 * Multiply color values by alpha for proper blending.
 * @param {Silhouette} $0 The silhouette to sample.
 * @param {number} x X position of texture [0, width).
 * @param {number} y Y position of texture [0, height).
 * @param {Uint8ClampedArray} dst A color 4b space.
 * @return {Uint8ClampedArray} The dst vector.
 */
const getColor4b = (_ref2, x, y, dst) => {
  let {
    _width: width,
    _height: height,
    _colorData: data
  } = _ref2;
  // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.
  // (See github.com/LLK/scratch-render/blob/954cfff02b08069a082cbedd415c1fecd9b1e4fb/src/BitmapSkin.js#L88)
  x = intMax(0, intMin(x, width - 1));
  y = intMax(0, intMin(y, height - 1));

  // 0 if outside bounds, otherwise read from data.
  if (x >= width || y >= height || x < 0 || y < 0) {
    return dst.fill(0);
  }
  const offset = (y * width + x) * 4;
  // premultiply alpha
  const alpha = data[offset + 3] / 255;
  dst[0] = data[offset] * alpha;
  dst[1] = data[offset + 1] * alpha;
  dst[2] = data[offset + 2] * alpha;
  dst[3] = data[offset + 3];
  return dst;
};

/**
 * Get the color from a given silhouette at an x/y local texture position.
 * Do not multiply color values by alpha, as it has already been done.
 * @param {Silhouette} $0 The silhouette to sample.
 * @param {number} x X position of texture [0, width).
 * @param {number} y Y position of texture [0, height).
 * @param {Uint8ClampedArray} dst A color 4b space.
 * @return {Uint8ClampedArray} The dst vector.
 */
const getPremultipliedColor4b = (_ref3, x, y, dst) => {
  let {
    _width: width,
    _height: height,
    _colorData: data
  } = _ref3;
  // Clamp coords to edge, matching GL_CLAMP_TO_EDGE.
  x = intMax(0, intMin(x, width - 1));
  y = intMax(0, intMin(y, height - 1));
  const offset = (y * width + x) * 4;
  dst[0] = data[offset];
  dst[1] = data[offset + 1];
  dst[2] = data[offset + 2];
  dst[3] = data[offset + 3];
  return dst;
};
class Silhouette {
  constructor() {
    /**
     * The width of the data representing the current skin data.
     * @type {number}
     */
    this._width = 0;

    /**
     * The height of the data representing the current skin date.
     * @type {number}
     */
    this._height = 0;

    /**
     * The data representing a skin's silhouette shape.
     * @type {Uint8ClampedArray}
     */
    this._colorData = null;

    // By default, silhouettes are assumed not to contain premultiplied image data,
    // so when we get a color, we want to multiply it by its alpha channel.
    // Point `_getColor` to the version of the function that multiplies.
    this._getColor = getColor4b;
    this.colorAtNearest = this.colorAtLinear = (_, dst) => dst.fill(0);
  }

  /**
   * Update this silhouette with the bitmapData for a skin.
   * @param {ImageData|HTMLCanvasElement|HTMLImageElement} bitmapData An image, canvas or other element that the skin
   * @param {boolean} isPremultiplied True if the source bitmap data comes premultiplied (e.g. from readPixels).
   * rendering can be queried from.
   */
  update(bitmapData) {
    let isPremultiplied = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    let imageData;
    if (bitmapData instanceof ImageData) {
      // If handed ImageData directly, use it directly.
      imageData = bitmapData;
      this._width = bitmapData.width;
      this._height = bitmapData.height;
    } else {
      // Draw about anything else to our update canvas and poll image data
      // from that.
      const canvas = Silhouette._updateCanvas();
      const width = this._width = canvas.width = bitmapData.width;
      const height = this._height = canvas.height = bitmapData.height;
      const ctx = canvas.getContext('2d');
      if (!(width && height)) {
        return;
      }
      ctx.clearRect(0, 0, width, height);
      ctx.drawImage(bitmapData, 0, 0, width, height);
      imageData = ctx.getImageData(0, 0, width, height);
    }
    if (isPremultiplied) {
      this._getColor = getPremultipliedColor4b;
    } else {
      this._getColor = getColor4b;
    }
    this._colorData = imageData.data;
    // delete our custom overriden "uninitalized" color functions
    // let the prototype work for itself
    delete this.colorAtNearest;
    delete this.colorAtLinear;
  }

  /**
   * Sample a color from the silhouette at a given local position using
   * "nearest neighbor"
   * @param {twgl.v3} vec [x,y] texture space (0-1)
   * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)
   * @returns {Uint8ClampedArray} dst
   */
  colorAtNearest(vec, dst) {
    return this._getColor(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1)), dst);
  }

  /**
   * Sample a color from the silhouette at a given local position using
   * "linear interpolation"
   * @param {twgl.v3} vec [x,y] texture space (0-1)
   * @param {Uint8ClampedArray} dst The memory buffer to store the value in. (4 bytes)
   * @returns {Uint8ClampedArray} dst
   */
  colorAtLinear(vec, dst) {
    const x = vec[0] * (this._width - 1);
    const y = vec[1] * (this._height - 1);
    const x1D = x % 1;
    const y1D = y % 1;
    const x0D = 1 - x1D;
    const y0D = 1 - y1D;
    const xFloor = Math.floor(x);
    const yFloor = Math.floor(y);
    const x0y0 = this._getColor(this, xFloor, yFloor, __cornerWork[0]);
    const x1y0 = this._getColor(this, xFloor + 1, yFloor, __cornerWork[1]);
    const x0y1 = this._getColor(this, xFloor, yFloor + 1, __cornerWork[2]);
    const x1y1 = this._getColor(this, xFloor + 1, yFloor + 1, __cornerWork[3]);
    dst[0] = x0y0[0] * x0D * y0D + x0y1[0] * x0D * y1D + x1y0[0] * x1D * y0D + x1y1[0] * x1D * y1D;
    dst[1] = x0y0[1] * x0D * y0D + x0y1[1] * x0D * y1D + x1y0[1] * x1D * y0D + x1y1[1] * x1D * y1D;
    dst[2] = x0y0[2] * x0D * y0D + x0y1[2] * x0D * y1D + x1y0[2] * x1D * y0D + x1y1[2] * x1D * y1D;
    dst[3] = x0y0[3] * x0D * y0D + x0y1[3] * x0D * y1D + x1y0[3] * x1D * y0D + x1y1[3] * x1D * y1D;
    return dst;
  }

  /**
   * Test if texture coordinate touches the silhouette using nearest neighbor.
   * @param {twgl.v3} vec A texture coordinate.
   * @return {boolean} If the nearest pixel has an alpha value.
   */
  isTouchingNearest(vec) {
    if (!this._colorData) return;
    return getPoint(this, Math.floor(vec[0] * (this._width - 1)), Math.floor(vec[1] * (this._height - 1))) > 0;
  }

  /**
   * Test to see if any of the 4 pixels used in the linear interpolate touch
   * the silhouette.
   * @param {twgl.v3} vec A texture coordinate.
   * @return {boolean} Any of the pixels have some alpha.
   */
  isTouchingLinear(vec) {
    if (!this._colorData) return;
    const x = Math.floor(vec[0] * (this._width - 1));
    const y = Math.floor(vec[1] * (this._height - 1));
    return getPoint(this, x, y) > 0 || getPoint(this, x + 1, y) > 0 || getPoint(this, x, y + 1) > 0 || getPoint(this, x + 1, y + 1) > 0;
  }

  /**
   * Get the canvas element reused by Silhouettes to update their data with.
   * @private
   * @return {CanvasElement} A canvas to draw bitmap data to.
   */
  static _updateCanvas() {
    if (typeof __SilhouetteUpdateCanvas === 'undefined') {
      __SilhouetteUpdateCanvas = document.createElement('canvas');
    }
    return __SilhouetteUpdateCanvas;
  }
}
module.exports = Silhouette;

/***/ }),

/***/ "./node_modules/scratch-render/src/Skin.js":
/*!*************************************************!*\
  !*** ./node_modules/scratch-render/src/Skin.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const EventEmitter = __webpack_require__(/*! events */ "./node_modules/events/events.js");
const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const RenderConstants = __webpack_require__(/*! ./RenderConstants */ "./node_modules/scratch-render/src/RenderConstants.js");
const Silhouette = __webpack_require__(/*! ./Silhouette */ "./node_modules/scratch-render/src/Silhouette.js");
class Skin extends EventEmitter {
  /**
   * Create a Skin, which stores and/or generates textures for use in rendering.
   * @param {int} id - The unique ID for this Skin.
   * @constructor
   */
  constructor(id) {
    super();

    /** @type {int} */
    this._id = id;

    /** @type {Vec3} */
    this._rotationCenter = twgl.v3.create(0, 0);

    /** @type {WebGLTexture} */
    this._texture = null;

    /**
     * The uniforms to be used by the vertex and pixel shaders.
     * Some of these are used by other parts of the renderer as well.
     * @type {Object.<string,*>}
     * @private
     */
    this._uniforms = {
      /**
       * The nominal (not necessarily current) size of the current skin.
       * @type {Array<number>}
       */
      u_skinSize: [0, 0],
      /**
       * The actual WebGL texture object for the skin.
       * @type {WebGLTexture}
       */
      u_skin: null
    };

    /**
     * A silhouette to store touching data, skins are responsible for keeping it up to date.
     * @private
     */
    this._silhouette = new Silhouette();
    this.setMaxListeners(RenderConstants.SKIN_SHARE_SOFT_LIMIT);
  }

  /**
   * Dispose of this object. Do not use it after calling this method.
   */
  dispose() {
    this._id = RenderConstants.ID_NONE;
  }

  /**
   * @return {int} the unique ID for this Skin.
   */
  get id() {
    return this._id;
  }

  /**
   * @returns {Vec3} the origin, in object space, about which this Skin should rotate.
   */
  get rotationCenter() {
    return this._rotationCenter;
  }

  /**
   * @abstract
   * @return {Array<number>} the "native" size, in texels, of this skin.
   */
  get size() {
    return [0, 0];
  }

  /**
   * Should this skin's texture be filtered with nearest-neighbor or linear interpolation at the given scale?
   * @param {?Array<Number>} scale The screen-space X and Y scaling factors at which this skin's texture will be
   * displayed, as percentages (100 means 1 "native size" unit is 1 screen pixel; 200 means 2 screen pixels, etc).
   * @param {Drawable} drawable The drawable that this skin's texture will be applied to.
   * @return {boolean} True if this skin's texture, as returned by {@link getTexture}, should be filtered with
   * nearest-neighbor interpolation.
   */
  // eslint-disable-next-line no-unused-vars
  useNearest(scale, drawable) {
    return true;
  }

  /**
   * Get the center of the current bounding box
   * @return {Array<number>} the center of the current bounding box
   */
  calculateRotationCenter() {
    return [this.size[0] / 2, this.size[1] / 2];
  }

  /**
   * @abstract
   * @param {Array<number>} scale - The scaling factors to be used.
   * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given size.
   */
  // eslint-disable-next-line no-unused-vars
  getTexture(scale) {
    return this._emptyImageTexture;
  }

  /**
   * Get the bounds of the drawable for determining its fenced position.
   * @param {Array<number>} drawable - The Drawable instance this skin is using.
   * @param {?Rectangle} result - Optional destination for bounds calculation.
   * @return {!Rectangle} The drawable's bounds. For compatibility with Scratch 2, we always use getAABB.
   */
  getFenceBounds(drawable, result) {
    return drawable.getAABB(result);
  }

  /**
   * Update and returns the uniforms for this skin.
   * @param {Array<number>} scale - The scaling factors to be used.
   * @returns {object.<string, *>} the shader uniforms to be used when rendering with this Skin.
   */
  getUniforms(scale) {
    this._uniforms.u_skin = this.getTexture(scale);
    this._uniforms.u_skinSize = this.size;
    return this._uniforms;
  }

  /**
   * If the skin defers silhouette operations until the last possible minute,
   * this will be called before isTouching uses the silhouette.
   * @abstract
   */
  updateSilhouette() {}

  /**
   * Set this skin's texture to the given image.
   * @param {ImageData|HTMLCanvasElement} textureData - The canvas or image data to set the texture to.
   */
  _setTexture(textureData) {
    const gl = this._renderer.gl;
    gl.bindTexture(gl.TEXTURE_2D, this._texture);
    // Premultiplied alpha is necessary for proper blending.
    // See http://www.realtimerendering.com/blog/gpus-prefer-premultiplication/
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, true);
    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureData);
    gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
    this._silhouette.update(textureData);
  }

  /**
   * Set the contents of this skin to an empty skin.
   * @fires Skin.event:WasAltered
   */
  setEmptyImageData() {
    // Free up the current reference to the _texture
    this._texture = null;
    if (!this._emptyImageData) {
      // Create a transparent pixel
      this._emptyImageData = new ImageData(1, 1);

      // Create a new texture and update the silhouette
      const gl = this._renderer.gl;
      const textureOptions = {
        auto: true,
        wrap: gl.CLAMP_TO_EDGE,
        src: this._emptyImageData
      };

      // Note: we're using _emptyImageTexture here instead of _texture
      // so that we can cache this empty texture for later use as needed.
      // this._texture can get modified by other skins (e.g. BitmapSkin
      // and SVGSkin, so we can't use that same field for caching)
      this._emptyImageTexture = twgl.createTexture(gl, textureOptions);
    }
    this._rotationCenter[0] = 0;
    this._rotationCenter[1] = 0;
    this._silhouette.update(this._emptyImageData);
    this.emit(Skin.Events.WasAltered);
  }

  /**
   * Does this point touch an opaque or translucent point on this skin?
   * Nearest Neighbor version
   * The caller is responsible for ensuring this skin's silhouette is up-to-date.
   * @see updateSilhouette
   * @see Drawable.updateCPURenderAttributes
   * @param {twgl.v3} vec A texture coordinate.
   * @return {boolean} Did it touch?
   */
  isTouchingNearest(vec) {
    return this._silhouette.isTouchingNearest(vec);
  }

  /**
   * Does this point touch an opaque or translucent point on this skin?
   * Linear Interpolation version
   * The caller is responsible for ensuring this skin's silhouette is up-to-date.
   * @see updateSilhouette
   * @see Drawable.updateCPURenderAttributes
   * @param {twgl.v3} vec A texture coordinate.
   * @return {boolean} Did it touch?
   */
  isTouchingLinear(vec) {
    return this._silhouette.isTouchingLinear(vec);
  }
}

/**
 * These are the events which can be emitted by instances of this class.
 * @enum {string}
 */
Skin.Events = {
  /**
   * Emitted when anything about the Skin has been altered, such as the appearance or rotation center.
   * @event Skin.event:WasAltered
   */
  WasAltered: 'WasAltered'
};
module.exports = Skin;

/***/ }),

/***/ "./node_modules/scratch-render/src/TextBubbleSkin.js":
/*!***********************************************************!*\
  !*** ./node_modules/scratch-render/src/TextBubbleSkin.js ***!
  \***********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const twgl = __webpack_require__(/*! twgl.js */ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js");
const TextWrapper = __webpack_require__(/*! ./util/text-wrapper */ "./node_modules/scratch-render/src/util/text-wrapper.js");
const CanvasMeasurementProvider = __webpack_require__(/*! ./util/canvas-measurement-provider */ "./node_modules/scratch-render/src/util/canvas-measurement-provider.js");
const Skin = __webpack_require__(/*! ./Skin */ "./node_modules/scratch-render/src/Skin.js");
const BubbleStyle = {
  MAX_LINE_WIDTH: 170,
  // Maximum width, in Scratch pixels, of a single line of text

  MIN_WIDTH: 50,
  // Minimum width, in Scratch pixels, of a text bubble
  STROKE_WIDTH: 4,
  // Thickness of the stroke around the bubble. Only half's visible because it's drawn under the fill
  PADDING: 10,
  // Padding around the text area
  CORNER_RADIUS: 16,
  // Radius of the rounded corners
  TAIL_HEIGHT: 12,
  // Height of the speech bubble's "tail". Probably should be a constant.

  FONT: 'Helvetica',
  // Font to render the text with
  FONT_SIZE: 14,
  // Font size, in Scratch pixels
  FONT_HEIGHT_RATIO: 0.9,
  // Height, in Scratch pixels, of the text, as a proportion of the font's size
  LINE_HEIGHT: 16,
  // Spacing between each line of text

  COLORS: {
    BUBBLE_FILL: 'white',
    BUBBLE_STROKE: 'rgba(0, 0, 0, 0.15)',
    TEXT_FILL: '#575E75'
  }
};
class TextBubbleSkin extends Skin {
  /**
   * Create a new text bubble skin.
   * @param {!int} id - The ID for this Skin.
   * @param {!RenderWebGL} renderer - The renderer which will use this skin.
   * @constructor
   * @extends Skin
   */
  constructor(id, renderer) {
    super(id);

    /** @type {RenderWebGL} */
    this._renderer = renderer;

    /** @type {HTMLCanvasElement} */
    this._canvas = document.createElement('canvas');

    /** @type {Array<number>} */
    this._size = [0, 0];

    /** @type {number} */
    this._renderedScale = 0;

    /** @type {Array<string>} */
    this._lines = [];

    /** @type {object} */
    this._textAreaSize = {
      width: 0,
      height: 0
    };

    /** @type {string} */
    this._bubbleType = '';

    /** @type {boolean} */
    this._pointsLeft = false;

    /** @type {boolean} */
    this._textDirty = true;

    /** @type {boolean} */
    this._textureDirty = true;
    this.measurementProvider = new CanvasMeasurementProvider(this._canvas.getContext('2d'));
    this.textWrapper = new TextWrapper(this.measurementProvider);
    this._restyleCanvas();
  }

  /**
   * Dispose of this object. Do not use it after calling this method.
   */
  dispose() {
    if (this._texture) {
      this._renderer.gl.deleteTexture(this._texture);
      this._texture = null;
    }
    this._canvas = null;
    super.dispose();
  }

  /**
   * @return {Array<number>} the dimensions, in Scratch units, of this skin.
   */
  get size() {
    if (this._textDirty) {
      this._reflowLines();
    }
    return this._size;
  }

  /**
   * Set parameters for this text bubble.
   * @param {!string} type - either "say" or "think".
   * @param {!string} text - the text for the bubble.
   * @param {!boolean} pointsLeft - which side the bubble is pointing.
   */
  setTextBubble(type, text, pointsLeft) {
    this._text = text;
    this._bubbleType = type;
    this._pointsLeft = pointsLeft;
    this._textDirty = true;
    this._textureDirty = true;
    this.emit(Skin.Events.WasAltered);
  }

  /**
   * Re-style the canvas after resizing it. This is necessary to ensure proper text measurement.
   */
  _restyleCanvas() {
    this._canvas.getContext('2d').font = "".concat(BubbleStyle.FONT_SIZE, "px ").concat(BubbleStyle.FONT, ", sans-serif");
  }

  /**
   * Update the array of wrapped lines and the text dimensions.
   */
  _reflowLines() {
    this._lines = this.textWrapper.wrapText(BubbleStyle.MAX_LINE_WIDTH, this._text);

    // Measure width of longest line to avoid extra-wide bubbles
    let longestLineWidth = 0;
    for (const line of this._lines) {
      longestLineWidth = Math.max(longestLineWidth, this.measurementProvider.measureText(line));
    }

    // Calculate the canvas-space sizes of the padded text area and full text bubble
    const paddedWidth = Math.max(longestLineWidth, BubbleStyle.MIN_WIDTH) + BubbleStyle.PADDING * 2;
    const paddedHeight = BubbleStyle.LINE_HEIGHT * this._lines.length + BubbleStyle.PADDING * 2;
    this._textAreaSize.width = paddedWidth;
    this._textAreaSize.height = paddedHeight;
    this._size[0] = paddedWidth + BubbleStyle.STROKE_WIDTH;
    this._size[1] = paddedHeight + BubbleStyle.STROKE_WIDTH + BubbleStyle.TAIL_HEIGHT;
    this._textDirty = false;
  }

  /**
   * Render this text bubble at a certain scale, using the current parameters, to the canvas.
   * @param {number} scale The scale to render the bubble at
   */
  _renderTextBubble(scale) {
    const ctx = this._canvas.getContext('2d');
    if (this._textDirty) {
      this._reflowLines();
    }

    // Calculate the canvas-space sizes of the padded text area and full text bubble
    const paddedWidth = this._textAreaSize.width;
    const paddedHeight = this._textAreaSize.height;

    // Resize the canvas to the correct screen-space size
    this._canvas.width = Math.ceil(this._size[0] * scale);
    this._canvas.height = Math.ceil(this._size[1] * scale);
    this._restyleCanvas();

    // Reset the transform before clearing to ensure 100% clearage
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);
    ctx.scale(scale, scale);
    ctx.translate(BubbleStyle.STROKE_WIDTH * 0.5, BubbleStyle.STROKE_WIDTH * 0.5);

    // If the text bubble points leftward, flip the canvas
    ctx.save();
    if (this._pointsLeft) {
      ctx.scale(-1, 1);
      ctx.translate(-paddedWidth, 0);
    }

    // Draw the bubble's rounded borders
    ctx.beginPath();
    ctx.moveTo(BubbleStyle.CORNER_RADIUS, paddedHeight);
    ctx.arcTo(0, paddedHeight, 0, paddedHeight - BubbleStyle.CORNER_RADIUS, BubbleStyle.CORNER_RADIUS);
    ctx.arcTo(0, 0, paddedWidth, 0, BubbleStyle.CORNER_RADIUS);
    ctx.arcTo(paddedWidth, 0, paddedWidth, paddedHeight, BubbleStyle.CORNER_RADIUS);
    ctx.arcTo(paddedWidth, paddedHeight, paddedWidth - BubbleStyle.CORNER_RADIUS, paddedHeight, BubbleStyle.CORNER_RADIUS);

    // Translate the canvas so we don't have to do a bunch of width/height arithmetic
    ctx.save();
    ctx.translate(paddedWidth - BubbleStyle.CORNER_RADIUS, paddedHeight);

    // Draw the bubble's "tail"
    if (this._bubbleType === 'say') {
      // For a speech bubble, draw one swoopy thing
      ctx.bezierCurveTo(0, 4, 4, 8, 4, 10);
      ctx.arcTo(4, 12, 2, 12, 2);
      ctx.bezierCurveTo(-1, 12, -11, 8, -16, 0);
      ctx.closePath();
    } else {
      // For a thinking bubble, draw a partial circle attached to the bubble...
      ctx.arc(-16, 0, 4, 0, Math.PI);
      ctx.closePath();

      // and two circles detached from it
      ctx.moveTo(-7, 7.25);
      ctx.arc(-9.25, 7.25, 2.25, 0, Math.PI * 2);
      ctx.moveTo(0, 9.5);
      ctx.arc(-1.5, 9.5, 1.5, 0, Math.PI * 2);
    }

    // Un-translate the canvas and fill + stroke the text bubble
    ctx.restore();
    ctx.fillStyle = BubbleStyle.COLORS.BUBBLE_FILL;
    ctx.strokeStyle = BubbleStyle.COLORS.BUBBLE_STROKE;
    ctx.lineWidth = BubbleStyle.STROKE_WIDTH;
    ctx.stroke();
    ctx.fill();

    // Un-flip the canvas if it was flipped
    ctx.restore();

    // Draw each line of text
    ctx.fillStyle = BubbleStyle.COLORS.TEXT_FILL;
    ctx.font = "".concat(BubbleStyle.FONT_SIZE, "px ").concat(BubbleStyle.FONT, ", sans-serif");
    const lines = this._lines;
    for (let lineNumber = 0; lineNumber < lines.length; lineNumber++) {
      const line = lines[lineNumber];
      ctx.fillText(line, BubbleStyle.PADDING, BubbleStyle.PADDING + BubbleStyle.LINE_HEIGHT * lineNumber + BubbleStyle.FONT_HEIGHT_RATIO * BubbleStyle.FONT_SIZE);
    }
    this._renderedScale = scale;
  }
  updateSilhouette() {
    let scale = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [100, 100];
    // Ensure a silhouette exists.
    this.getTexture(scale);
  }

  /**
   * @param {Array<number>} scale - The scaling factors to be used, each in the [0,100] range.
   * @return {WebGLTexture} The GL texture representation of this skin when drawing at the given scale.
   */
  getTexture(scale) {
    // The texture only ever gets uniform scale. Take the larger of the two axes.
    const scaleMax = scale ? Math.max(Math.abs(scale[0]), Math.abs(scale[1])) : 100;
    const requestedScale = scaleMax / 100;

    // If we already rendered the text bubble at this scale, we can skip re-rendering it.
    if (this._textureDirty || this._renderedScale !== requestedScale) {
      this._renderTextBubble(requestedScale);
      this._textureDirty = false;
      const context = this._canvas.getContext('2d');
      const textureData = context.getImageData(0, 0, this._canvas.width, this._canvas.height);
      const gl = this._renderer.gl;
      if (this._texture === null) {
        const textureOptions = {
          auto: false,
          wrap: gl.CLAMP_TO_EDGE
        };
        this._texture = twgl.createTexture(gl, textureOptions);
      }
      this._setTexture(textureData);
    }
    return this._texture;
  }
}
module.exports = TextBubbleSkin;

/***/ }),

/***/ "./node_modules/scratch-render/src/util/canvas-measurement-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/scratch-render/src/util/canvas-measurement-provider.js ***!
  \*****************************************************************************/
/***/ ((module) => {

class CanvasMeasurementProvider {
  /**
   * @param {CanvasRenderingContext2D} ctx - provides a canvas rendering context
   * with 'font' set to the text style of the text to be wrapped.
   */
  constructor(ctx) {
    this._ctx = ctx;
    this._cache = {};
  }

  // We don't need to set up or tear down anything here. Should these be removed altogether?

  /**
   * Called by the TextWrapper before a batch of zero or more calls to measureText().
   */
  beginMeasurementSession() {}

  /**
   * Called by the TextWrapper after a batch of zero or more calls to measureText().
   */
  endMeasurementSession() {}

  /**
   * Measure a whole string as one unit.
   * @param {string} text - the text to measure.
   * @returns {number} - the length of the string.
   */
  measureText(text) {
    if (!this._cache[text]) {
      this._cache[text] = this._ctx.measureText(text).width;
    }
    return this._cache[text];
  }
}
module.exports = CanvasMeasurementProvider;

/***/ }),

/***/ "./node_modules/scratch-render/src/util/color-conversions.js":
/*!*******************************************************************!*\
  !*** ./node_modules/scratch-render/src/util/color-conversions.js ***!
  \*******************************************************************/
/***/ ((module) => {

/**
 * Converts an RGB color value to HSV. Conversion formula
 * adapted from http://lolengine.net/blog/2013/01/13/fast-rgb-to-hsv.
 * Assumes r, g, and b are in the range [0, 255] and
 * returns h, s, and v in the range [0, 1].
 *
 * @param   {Array<number>} rgb   The RGB color value
 * @param   {number}        rgb.r The red color value
 * @param   {number}        rgb.g The green color value
 * @param   {number}        rgb.b The blue color value
 * @param   {Array<number>} dst   The array to store the HSV values in
 * @return  {Array<number>}       The `dst` array passed in
 */
const rgbToHsv = (_ref, dst) => {
  let [r, g, b] = _ref;
  let K = 0.0;
  r /= 255;
  g /= 255;
  b /= 255;
  let tmp = 0;
  if (g < b) {
    tmp = g;
    g = b;
    b = tmp;
    K = -1;
  }
  if (r < g) {
    tmp = r;
    r = g;
    g = tmp;
    K = -2 / 6 - K;
  }
  const chroma = r - Math.min(g, b);
  const h = Math.abs(K + (g - b) / (6 * chroma + Number.EPSILON));
  const s = chroma / (r + Number.EPSILON);
  const v = r;
  dst[0] = h;
  dst[1] = s;
  dst[2] = v;
  return dst;
};

/**
 * Converts an HSV color value to RGB. Conversion formula
 * adapted from https://gist.github.com/mjackson/5311256.
 * Assumes h, s, and v are contained in the set [0, 1] and
 * returns r, g, and b in the set [0, 255].
 *
 * @param   {Array<number>}                hsv The HSV color value
 * @param   {number}                       hsv.h     The hue
 * @param   {number}                       hsv.s     The saturation
 * @param   {number}                       hsv.v     The value
 * @param   {Uint8Array|Uint8ClampedArray} dst The array to store the RGB values in
 * @return  {Uint8Array|Uint8ClampedArray}     The `dst` array passed in
 */
const hsvToRgb = (_ref2, dst) => {
  let [h, s, v] = _ref2;
  if (s === 0) {
    dst[0] = dst[1] = dst[2] = v * 255 + 0.5;
    return dst;
  }

  // keep hue in [0,1) so the `switch(i)` below only needs 6 cases (0-5)
  h %= 1;
  const i = h * 6 | 0;
  const f = h * 6 - i;
  const p = v * (1 - s);
  const q = v * (1 - s * f);
  const t = v * (1 - s * (1 - f));
  let r = 0;
  let g = 0;
  let b = 0;
  switch (i) {
    case 0:
      r = v;
      g = t;
      b = p;
      break;
    case 1:
      r = q;
      g = v;
      b = p;
      break;
    case 2:
      r = p;
      g = v;
      b = t;
      break;
    case 3:
      r = p;
      g = q;
      b = v;
      break;
    case 4:
      r = t;
      g = p;
      b = v;
      break;
    case 5:
      r = v;
      g = p;
      b = q;
      break;
  }

  // Add 0.5 in order to round. Setting integer TypedArray elements implicitly floors.
  dst[0] = r * 255 + 0.5;
  dst[1] = g * 255 + 0.5;
  dst[2] = b * 255 + 0.5;
  return dst;
};
module.exports = {
  rgbToHsv,
  hsvToRgb
};

/***/ }),

/***/ "./node_modules/scratch-render/src/util/log.js":
/*!*****************************************************!*\
  !*** ./node_modules/scratch-render/src/util/log.js ***!
  \*****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const minilog = __webpack_require__(/*! minilog */ "./node_modules/minilog/lib/web/index.js");
minilog.enable();
module.exports = minilog('scratch-render');

/***/ }),

/***/ "./node_modules/scratch-render/src/util/text-wrapper.js":
/*!**************************************************************!*\
  !*** ./node_modules/scratch-render/src/util/text-wrapper.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const LineBreaker = __webpack_require__(/*! !ify-loader!linebreak */ "./node_modules/ify-loader/index.js!./node_modules/linebreak/src/linebreaker.js");
const GraphemeBreaker = __webpack_require__(/*! !ify-loader!grapheme-breaker */ "./node_modules/ify-loader/index.js!./node_modules/grapheme-breaker/src/GraphemeBreaker.js");

/**
 * Tell this text wrapper to use a specific measurement provider.
 * @typedef {object} MeasurementProvider - the new measurement provider.
 * @property {Function} beginMeasurementSession - this will be called before a batch of measurements are made.
 *      Optionally, this function may return an object to be provided to the endMeasurementSession function.
 * @property {Function} measureText - this will be called each time a piece of text must be measured.
 * @property {Function} endMeasurementSession - this will be called after a batch of measurements is finished.
 *      It will be passed whatever value beginMeasurementSession returned, if any.
 */

/**
 * Utility to wrap text across several lines, respecting Unicode grapheme clusters and, when possible, Unicode line
 * break opportunities.
 * Reference material:
 * - Unicode Standard Annex #14: http://unicode.org/reports/tr14/
 * - Unicode Standard Annex #29: http://unicode.org/reports/tr29/
 * - "JavaScript has a Unicode problem" by Mathias Bynens: https://mathiasbynens.be/notes/javascript-unicode
 */
class TextWrapper {
  /**
   * Construct a text wrapper which will measure text using the specified measurement provider.
   * @param {MeasurementProvider} measurementProvider - a helper object to provide text measurement services.
   */
  constructor(measurementProvider) {
    this._measurementProvider = measurementProvider;
    this._cache = {};
  }

  /**
   * Wrap the provided text into lines restricted to a maximum width. See Unicode Standard Annex (UAX) #14.
   * @param {number} maxWidth - the maximum allowed width of a line.
   * @param {string} text - the text to be wrapped. Will be split on whitespace.
   * @returns {Array.<string>} an array containing the wrapped lines of text.
   */
  wrapText(maxWidth, text) {
    // Normalize to canonical composition (see Unicode Standard Annex (UAX) #15)
    text = text.normalize();
    const cacheKey = "".concat(maxWidth, "-").concat(text);
    if (this._cache[cacheKey]) {
      return this._cache[cacheKey];
    }
    const measurementSession = this._measurementProvider.beginMeasurementSession();
    const breaker = new LineBreaker(text);
    let lastPosition = 0;
    let nextBreak;
    let currentLine = null;
    const lines = [];
    while (nextBreak = breaker.nextBreak()) {
      const word = text.slice(lastPosition, nextBreak.position).replace(/\n+$/, '');
      let proposedLine = (currentLine || '').concat(word);
      let proposedLineWidth = this._measurementProvider.measureText(proposedLine);
      if (proposedLineWidth > maxWidth) {
        // The next word won't fit on this line. Will it fit on a line by itself?
        const wordWidth = this._measurementProvider.measureText(word);
        if (wordWidth > maxWidth) {
          // The next word can't even fit on a line by itself. Consume it one grapheme cluster at a time.
          let lastCluster = 0;
          let nextCluster;
          while (lastCluster !== (nextCluster = GraphemeBreaker.nextBreak(word, lastCluster))) {
            const cluster = word.substring(lastCluster, nextCluster);
            proposedLine = (currentLine || '').concat(cluster);
            proposedLineWidth = this._measurementProvider.measureText(proposedLine);
            if (currentLine === null || proposedLineWidth <= maxWidth) {
              // first cluster of a new line or the cluster fits
              currentLine = proposedLine;
            } else {
              // no more can fit
              lines.push(currentLine);
              currentLine = cluster;
            }
            lastCluster = nextCluster;
          }
        } else {
          // The next word can fit on the next line. Finish the current line and move on.
          if (currentLine !== null) lines.push(currentLine);
          currentLine = word;
        }
      } else {
        // The next word fits on this line. Just keep going.
        currentLine = proposedLine;
      }

      // Did we find a \n or similar?
      if (nextBreak.required) {
        if (currentLine !== null) lines.push(currentLine);
        currentLine = null;
      }
      lastPosition = nextBreak.position;
    }
    currentLine = currentLine || '';
    if (currentLine.length > 0 || lines.length === 0) {
      lines.push(currentLine);
    }
    this._cache[cacheKey] = lines;
    this._measurementProvider.endMeasurementSession(measurementSession);
    return lines;
  }
}
module.exports = TextWrapper;

/***/ }),

/***/ "./node_modules/scratch-storage/dist/web/scratch-storage.js":
/*!******************************************************************!*\
  !*** ./node_modules/scratch-storage/dist/web/scratch-storage.js ***!
  \******************************************************************/
/***/ ((module) => {

(function webpackUniversalModuleDefinition(root, factory) {
  if (true) module.exports = factory();else {}
})(window, function () {
  return /******/function (modules) {
    // webpackBootstrap
    /******/ // The module cache
    /******/
    var installedModules = {};
    /******/
    /******/ // The require function
    /******/
    function __nested_webpack_require_573__(moduleId) {
      /******/
      /******/ // Check if module is in cache
      /******/if (installedModules[moduleId]) {
        /******/return installedModules[moduleId].exports;
        /******/
      }
      /******/ // Create a new module (and put it into the cache)
      /******/
      var module = installedModules[moduleId] = {
        /******/i: moduleId,
        /******/l: false,
        /******/exports: {}
        /******/
      };
      /******/
      /******/ // Execute the module function
      /******/
      modules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_573__);
      /******/
      /******/ // Flag the module as loaded
      /******/
      module.l = true;
      /******/
      /******/ // Return the exports of the module
      /******/
      return module.exports;
      /******/
    }
    /******/
    /******/
    /******/ // expose the modules object (__webpack_modules__)
    /******/
    __nested_webpack_require_573__.m = modules;
    /******/
    /******/ // expose the module cache
    /******/
    __nested_webpack_require_573__.c = installedModules;
    /******/
    /******/ // define getter function for harmony exports
    /******/
    __nested_webpack_require_573__.d = function (exports, name, getter) {
      /******/if (!__nested_webpack_require_573__.o(exports, name)) {
        /******/Object.defineProperty(exports, name, {
          enumerable: true,
          get: getter
        });
        /******/
      }
      /******/
    };
    /******/
    /******/ // define __esModule on exports
    /******/
    __nested_webpack_require_573__.r = function (exports) {
      /******/if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
        /******/Object.defineProperty(exports, Symbol.toStringTag, {
          value: 'Module'
        });
        /******/
      }
      /******/
      Object.defineProperty(exports, '__esModule', {
        value: true
      });
      /******/
    };
    /******/
    /******/ // create a fake namespace object
    /******/ // mode & 1: value is a module id, require it
    /******/ // mode & 2: merge all properties of value into the ns
    /******/ // mode & 4: return value when already ns object
    /******/ // mode & 8|1: behave like require
    /******/
    __nested_webpack_require_573__.t = function (value, mode) {
      /******/if (mode & 1) value = __nested_webpack_require_573__(value);
      /******/
      if (mode & 8) return value;
      /******/
      if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
      /******/
      var ns = Object.create(null);
      /******/
      __nested_webpack_require_573__.r(ns);
      /******/
      Object.defineProperty(ns, 'default', {
        enumerable: true,
        value: value
      });
      /******/
      if (mode & 2 && typeof value != 'string') for (var key in value) __nested_webpack_require_573__.d(ns, key, function (key) {
        return value[key];
      }.bind(null, key));
      /******/
      return ns;
      /******/
    };
    /******/
    /******/ // getDefaultExport function for compatibility with non-harmony modules
    /******/
    __nested_webpack_require_573__.n = function (module) {
      /******/var getter = module && module.__esModule ? /******/function getDefault() {
        return module['default'];
      } : /******/function getModuleExports() {
        return module;
      };
      /******/
      __nested_webpack_require_573__.d(getter, 'a', getter);
      /******/
      return getter;
      /******/
    };
    /******/
    /******/ // Object.prototype.hasOwnProperty.call
    /******/
    __nested_webpack_require_573__.o = function (object, property) {
      return Object.prototype.hasOwnProperty.call(object, property);
    };
    /******/
    /******/ // __webpack_public_path__
    /******/
    __nested_webpack_require_573__.p = "";
    /******/
    /******/
    /******/ // Load entry module and return exports
    /******/
    return __nested_webpack_require_573__(__nested_webpack_require_573__.s = "./src/index.js");
    /******/
  }
  /************************************************************************/
  /******/({
    /***/"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js": (
    /*!*****************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/arrayLikeToArray.js ***!
      \*****************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_arrayLikeToArrayJs(module, exports) {
      function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      module.exports = _arrayLikeToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/arrayWithHoles.js": (
    /*!***************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/arrayWithHoles.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_arrayWithHolesJs(module, exports) {
      function _arrayWithHoles(r) {
        if (Array.isArray(r)) return r;
      }
      module.exports = _arrayWithHoles, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/assertThisInitialized.js": (
    /*!**********************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/assertThisInitialized.js ***!
      \**********************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_assertThisInitializedJs(module, exports) {
      function _assertThisInitialized(e) {
        if (void 0 === e) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        return e;
      }
      module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/classCallCheck.js": (
    /*!***************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/classCallCheck.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_classCallCheckJs(module, exports) {
      function _classCallCheck(a, n) {
        if (!(a instanceof n)) throw new TypeError("Cannot call a class as a function");
      }
      module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/createClass.js": (
    /*!************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/createClass.js ***!
      \************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_createClassJs(module, exports, __nested_webpack_require_7889__) {
      var toPropertyKey = __nested_webpack_require_7889__( /*! ./toPropertyKey.js */"./node_modules/@babel/runtime/helpers/toPropertyKey.js");
      function _defineProperties(e, r) {
        for (var t = 0; t < r.length; t++) {
          var o = r[t];
          o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, toPropertyKey(o.key), o);
        }
      }
      function _createClass(e, r, t) {
        return r && _defineProperties(e.prototype, r), t && _defineProperties(e, t), Object.defineProperty(e, "prototype", {
          writable: !1
        }), e;
      }
      module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/getPrototypeOf.js": (
    /*!***************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/getPrototypeOf.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_getPrototypeOfJs(module, exports) {
      function _getPrototypeOf(t) {
        return (module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function (t) {
          return t.__proto__ || Object.getPrototypeOf(t);
        }, module.exports.__esModule = true, module.exports["default"] = module.exports), _getPrototypeOf(t);
      }
      module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/inherits.js": (
    /*!*********************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/inherits.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_inheritsJs(module, exports, __nested_webpack_require_9945__) {
      var setPrototypeOf = __nested_webpack_require_9945__( /*! ./setPrototypeOf.js */"./node_modules/@babel/runtime/helpers/setPrototypeOf.js");
      function _inherits(t, e) {
        if ("function" != typeof e && null !== e) throw new TypeError("Super expression must either be null or a function");
        t.prototype = Object.create(e && e.prototype, {
          constructor: {
            value: t,
            writable: !0,
            configurable: !0
          }
        }), Object.defineProperty(t, "prototype", {
          writable: !1
        }), e && setPrototypeOf(t, e);
      }
      module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js": (
    /*!*********************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js ***!
      \*********************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_iterableToArrayLimitJs(module, exports) {
      function _iterableToArrayLimit(r, l) {
        var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (null != t) {
          var e,
            n,
            i,
            u,
            a = [],
            f = !0,
            o = !1;
          try {
            if (i = (t = t.call(r)).next, 0 === l) {
              if (Object(t) !== t) return;
              f = !1;
            } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = !0);
          } catch (r) {
            o = !0, n = r;
          } finally {
            try {
              if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
            } finally {
              if (o) throw n;
            }
          }
          return a;
        }
      }
      module.exports = _iterableToArrayLimit, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/nonIterableRest.js": (
    /*!****************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/nonIterableRest.js ***!
      \****************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_nonIterableRestJs(module, exports) {
      function _nonIterableRest() {
        throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
      }
      module.exports = _nonIterableRest, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js": (
    /*!************************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/objectWithoutProperties.js ***!
      \************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_objectWithoutPropertiesJs(module, exports, __nested_webpack_require_13351__) {
      var objectWithoutPropertiesLoose = __nested_webpack_require_13351__( /*! ./objectWithoutPropertiesLoose.js */"./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js");
      function _objectWithoutProperties(e, t) {
        if (null == e) return {};
        var o,
          r,
          i = objectWithoutPropertiesLoose(e, t);
        if (Object.getOwnPropertySymbols) {
          var s = Object.getOwnPropertySymbols(e);
          for (r = 0; r < s.length; r++) o = s[r], t.includes(o) || {}.propertyIsEnumerable.call(e, o) && (i[o] = e[o]);
        }
        return i;
      }
      module.exports = _objectWithoutProperties, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js": (
    /*!*****************************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/objectWithoutPropertiesLoose.js ***!
      \*****************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_objectWithoutPropertiesLooseJs(module, exports) {
      function _objectWithoutPropertiesLoose(r, e) {
        if (null == r) return {};
        var t = {};
        for (var n in r) if ({}.hasOwnProperty.call(r, n)) {
          if (e.includes(n)) continue;
          t[n] = r[n];
        }
        return t;
      }
      module.exports = _objectWithoutPropertiesLoose, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js": (
    /*!**************************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js ***!
      \**************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_possibleConstructorReturnJs(module, exports, __nested_webpack_require_15488__) {
      var _typeof = __nested_webpack_require_15488__( /*! ./typeof.js */"./node_modules/@babel/runtime/helpers/typeof.js")["default"];
      var assertThisInitialized = __nested_webpack_require_15488__( /*! ./assertThisInitialized.js */"./node_modules/@babel/runtime/helpers/assertThisInitialized.js");
      function _possibleConstructorReturn(t, e) {
        if (e && ("object" == _typeof(e) || "function" == typeof e)) return e;
        if (void 0 !== e) throw new TypeError("Derived constructors may only return object or undefined");
        return assertThisInitialized(t);
      }
      module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/readOnlyError.js": (
    /*!**************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/readOnlyError.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_readOnlyErrorJs(module, exports) {
      function _readOnlyError(r) {
        throw new TypeError('"' + r + '" is read-only');
      }
      module.exports = _readOnlyError, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/setPrototypeOf.js": (
    /*!***************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/setPrototypeOf.js ***!
      \***************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_setPrototypeOfJs(module, exports) {
      function _setPrototypeOf(t, e) {
        return (module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function (t, e) {
          return t.__proto__ = e, t;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports), _setPrototypeOf(t, e);
      }
      module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/slicedToArray.js": (
    /*!**************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/slicedToArray.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_slicedToArrayJs(module, exports, __nested_webpack_require_18163__) {
      var arrayWithHoles = __nested_webpack_require_18163__( /*! ./arrayWithHoles.js */"./node_modules/@babel/runtime/helpers/arrayWithHoles.js");
      var iterableToArrayLimit = __nested_webpack_require_18163__( /*! ./iterableToArrayLimit.js */"./node_modules/@babel/runtime/helpers/iterableToArrayLimit.js");
      var unsupportedIterableToArray = __nested_webpack_require_18163__( /*! ./unsupportedIterableToArray.js */"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js");
      var nonIterableRest = __nested_webpack_require_18163__( /*! ./nonIterableRest.js */"./node_modules/@babel/runtime/helpers/nonIterableRest.js");
      function _slicedToArray(r, e) {
        return arrayWithHoles(r) || iterableToArrayLimit(r, e) || unsupportedIterableToArray(r, e) || nonIterableRest();
      }
      module.exports = _slicedToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/toPrimitive.js": (
    /*!************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/toPrimitive.js ***!
      \************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_toPrimitiveJs(module, exports, __nested_webpack_require_19485__) {
      var _typeof = __nested_webpack_require_19485__( /*! ./typeof.js */"./node_modules/@babel/runtime/helpers/typeof.js")["default"];
      function toPrimitive(t, r) {
        if ("object" != _typeof(t) || !t) return t;
        var e = t[Symbol.toPrimitive];
        if (void 0 !== e) {
          var i = e.call(t, r || "default");
          if ("object" != _typeof(i)) return i;
          throw new TypeError("@@toPrimitive must return a primitive value.");
        }
        return ("string" === r ? String : Number)(t);
      }
      module.exports = toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/toPropertyKey.js": (
    /*!**************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/toPropertyKey.js ***!
      \**************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_toPropertyKeyJs(module, exports, __nested_webpack_require_20574__) {
      var _typeof = __nested_webpack_require_20574__( /*! ./typeof.js */"./node_modules/@babel/runtime/helpers/typeof.js")["default"];
      var toPrimitive = __nested_webpack_require_20574__( /*! ./toPrimitive.js */"./node_modules/@babel/runtime/helpers/toPrimitive.js");
      function toPropertyKey(t) {
        var i = toPrimitive(t, "string");
        return "symbol" == _typeof(i) ? i : i + "";
      }
      module.exports = toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/typeof.js": (
    /*!*******************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/typeof.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_typeofJs(module, exports) {
      function _typeof(o) {
        "@babel/helpers - typeof";

        return (module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) {
          return typeof o;
        } : function (o) {
          return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports), _typeof(o);
      }
      module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js": (
    /*!***************************************************************************!*\
      !*** ./node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js ***!
      \***************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_Babel_runtime_helpers_unsupportedIterableToArrayJs(module, exports, __nested_webpack_require_22583__) {
      var arrayLikeToArray = __nested_webpack_require_22583__( /*! ./arrayLikeToArray.js */"./node_modules/@babel/runtime/helpers/arrayLikeToArray.js");
      function _unsupportedIterableToArray(r, a) {
        if (r) {
          if ("string" == typeof r) return arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? arrayLikeToArray(r, a) : void 0;
        }
      }
      module.exports = _unsupportedIterableToArray, module.exports.__esModule = true, module.exports["default"] = module.exports;

      /***/
    }),
    /***/"./node_modules/arraybuffer-loader/lib/to-array-buffer.js": (
    /*!****************************************************************!*\
      !*** ./node_modules/arraybuffer-loader/lib/to-array-buffer.js ***!
      \****************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_arraybufferLoader_lib_toArrayBufferJs(module, exports, __nested_webpack_require_23751__) {
      "use strict";

      /* WEBPACK VAR INJECTION */
      (function (Buffer) {
        module.exports = function (base64Data) {
          var isBrowser = typeof window !== 'undefined' && typeof window.atob === 'function';
          var binary = isBrowser ? window.atob(base64Data) : Buffer.from(base64Data, 'base64').toString('binary');
          var bytes = new Uint8Array(binary.length);
          for (var i = 0; i < binary.length; ++i) {
            bytes[i] = binary.charCodeAt(i);
          }
          return bytes.buffer;
        };

        /* WEBPACK VAR INJECTION */
      }).call(this, __nested_webpack_require_23751__( /*! ./../../buffer/index.js */"./node_modules/buffer/index.js").Buffer);

      /***/
    }),
    /***/"./node_modules/base64-js/index.js": (
    /*!*****************************************!*\
      !*** ./node_modules/base64-js/index.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/
    function _node_modules_base64Js_indexJs(module, exports, __webpack_require__) {
      "use strict";

      exports.byteLength = byteLength;
      exports.toByteArray = toByteArray;
      exports.fromByteArray = fromByteArray;
      var lookup = [];
      var revLookup = [];
      var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
      var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
      for (var i = 0, len = code.length; i < len; ++i) {
        lookup[i] = code[i];
        revLookup[code.charCodeAt(i)] = i;
      }

      // Support decoding URL-safe base64 strings, as Node.js does.
      // See: https://en.wikipedia.org/wiki/Base64#URL_applications
      revLookup['-'.charCodeAt(0)] = 62;
      revLookup['_'.charCodeAt(0)] = 63;
      function getLens(b64) {
        var len = b64.length;
        if (len % 4 > 0) {
          throw new Error('Invalid string. Length must be a multiple of 4');
        }

        // Trim off extra bytes after placeholder bytes are found
        // See: https://github.com/beatgammit/base64-js/issues/42
        var validLen = b64.indexOf('=');
        if (validLen === -1) validLen = len;
        var placeHoldersLen = validLen === len ? 0 : 4 - validLen % 4;
        return [validLen, placeHoldersLen];
      }

      // base64 is 4/3 + up to two characters of the original data
      function byteLength(b64) {
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function _byteLength(b64, validLen, placeHoldersLen) {
        return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
      }
      function toByteArray(b64) {
        var tmp;
        var lens = getLens(b64);
        var validLen = lens[0];
        var placeHoldersLen = lens[1];
        var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
        var curByte = 0;

        // if there are placeholders, only get up to the last complete 4 chars
        var len = placeHoldersLen > 0 ? validLen - 4 : validLen;
        var i;
        for (i = 0; i < len; i += 4) {
          tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
          arr[curByte++] = tmp >> 16 & 0xFF;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 2) {
          tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
          arr[curByte++] = tmp & 0xFF;
        }
        if (placeHoldersLen === 1) {
          tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
          arr[curByte++] = tmp >> 8 & 0xFF;
          arr[curByte++] = tmp & 0xFF;
        }
        return arr;
      }
      function tripletToBase64(num) {
        return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
      }
      function encodeChunk(uint8, start, end) {
        var tmp;
        var output = [];
        for (var i = start; i < end; i += 3) {
          tmp = (uint8[i] << 16 & 0xFF0000) + (uint8[i + 1] << 8 & 0xFF00) + (uint8[i + 2] & 0xFF);
          output.push(tripletToBase64(tmp));
        }
        return output.join('');
      }
      function fromByteArray(uint8) {
        var tmp;
        var len = uint8.length;
        var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes
        var parts = [];
        var maxChunkLength = 16383; // must be multiple of 3

        // go through the array every three bytes, we'll deal with trailing stuff later
        for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
          parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
        }

        // pad the end with zeros, but make sure to not forget the extra bytes
        if (extraBytes === 1) {
          tmp = uint8[len - 1];
          parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 0x3F] + '==');
        } else if (extraBytes === 2) {
          tmp = (uint8[len - 2] << 8) + uint8[len - 1];
          parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 0x3F] + lookup[tmp << 2 & 0x3F] + '=');
        }
        return parts.join('');
      }

      /***/
    }),
    /***/"./node_modules/buffer/index.js": (
    /*!**************************************!*\
      !*** ./node_modules/buffer/index.js ***!
      \**************************************/
    /*! no static exports found */
    /***/
    function _node_modules_buffer_indexJs(module, exports, __nested_webpack_require_29483__) {
      "use strict";

      /* WEBPACK VAR INJECTION */
      (function (global) {
        /*!
        * The buffer module from node.js, for the browser.
        *
        * @author   Feross Aboukhadijeh <http://feross.org>
        * @license  MIT
        */
        /* eslint-disable no-proto */

        var base64 = __nested_webpack_require_29483__( /*! base64-js */"./node_modules/base64-js/index.js");
        var ieee754 = __nested_webpack_require_29483__( /*! ieee754 */"./node_modules/ieee754/index.js");
        var isArray = __nested_webpack_require_29483__( /*! isarray */"./node_modules/buffer/node_modules/isarray/index.js");
        exports.Buffer = Buffer;
        exports.SlowBuffer = SlowBuffer;
        exports.INSPECT_MAX_BYTES = 50;

        /**
         * If `Buffer.TYPED_ARRAY_SUPPORT`:
         *   === true    Use Uint8Array implementation (fastest)
         *   === false   Use Object implementation (most compatible, even IE6)
         *
         * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
         * Opera 11.6+, iOS 4.2+.
         *
         * Due to various browser bugs, sometimes the Object implementation will be used even
         * when the browser supports typed arrays.
         *
         * Note:
         *
         *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
         *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
         *
         *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
         *
         *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
         *     incorrect length in some situations.
        
         * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
         * get the Object implementation, which is slower but behaves correctly.
         */
        Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined ? global.TYPED_ARRAY_SUPPORT : typedArraySupport();

        /*
         * Export kMaxLength after typed array support is determined.
         */
        exports.kMaxLength = kMaxLength();
        function typedArraySupport() {
          try {
            var arr = new Uint8Array(1);
            arr.__proto__ = {
              __proto__: Uint8Array.prototype,
              foo: function foo() {
                return 42;
              }
            };
            return arr.foo() === 42 &&
            // typed array instances can be augmented
            typeof arr.subarray === 'function' &&
            // chrome 9-10 lack `subarray`
            arr.subarray(1, 1).byteLength === 0; // ie10 has broken `subarray`
          } catch (e) {
            return false;
          }
        }
        function kMaxLength() {
          return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
        }
        function createBuffer(that, length) {
          if (kMaxLength() < length) {
            throw new RangeError('Invalid typed array length');
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = new Uint8Array(length);
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            if (that === null) {
              that = new Buffer(length);
            }
            that.length = length;
          }
          return that;
        }

        /**
         * The Buffer constructor returns instances of `Uint8Array` that have their
         * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
         * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
         * and the `Uint8Array` methods. Square bracket notation works as expected -- it
         * returns a single octet.
         *
         * The `Uint8Array` prototype remains unmodified.
         */

        function Buffer(arg, encodingOrOffset, length) {
          if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
            return new Buffer(arg, encodingOrOffset, length);
          }

          // Common case.
          if (typeof arg === 'number') {
            if (typeof encodingOrOffset === 'string') {
              throw new Error('If encoding is specified then the first argument must be a string');
            }
            return allocUnsafe(this, arg);
          }
          return from(this, arg, encodingOrOffset, length);
        }
        Buffer.poolSize = 8192; // not used by this implementation

        // TODO: Legacy, not needed anymore. Remove in next major version.
        Buffer._augment = function (arr) {
          arr.__proto__ = Buffer.prototype;
          return arr;
        };
        function from(that, value, encodingOrOffset, length) {
          if (typeof value === 'number') {
            throw new TypeError('"value" argument must not be a number');
          }
          if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
            return fromArrayBuffer(that, value, encodingOrOffset, length);
          }
          if (typeof value === 'string') {
            return fromString(that, value, encodingOrOffset);
          }
          return fromObject(that, value);
        }

        /**
         * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
         * if value is a number.
         * Buffer.from(str[, encoding])
         * Buffer.from(array)
         * Buffer.from(buffer)
         * Buffer.from(arrayBuffer[, byteOffset[, length]])
         **/
        Buffer.from = function (value, encodingOrOffset, length) {
          return from(null, value, encodingOrOffset, length);
        };
        if (Buffer.TYPED_ARRAY_SUPPORT) {
          Buffer.prototype.__proto__ = Uint8Array.prototype;
          Buffer.__proto__ = Uint8Array;
          if (typeof Symbol !== 'undefined' && Symbol.species && Buffer[Symbol.species] === Buffer) {
            // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
            Object.defineProperty(Buffer, Symbol.species, {
              value: null,
              configurable: true
            });
          }
        }
        function assertSize(size) {
          if (typeof size !== 'number') {
            throw new TypeError('"size" argument must be a number');
          } else if (size < 0) {
            throw new RangeError('"size" argument must not be negative');
          }
        }
        function alloc(that, size, fill, encoding) {
          assertSize(size);
          if (size <= 0) {
            return createBuffer(that, size);
          }
          if (fill !== undefined) {
            // Only pay attention to encoding if it's a string. This
            // prevents accidentally sending in a number that would
            // be interpretted as a start offset.
            return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
          }
          return createBuffer(that, size);
        }

        /**
         * Creates a new filled Buffer instance.
         * alloc(size[, fill[, encoding]])
         **/
        Buffer.alloc = function (size, fill, encoding) {
          return alloc(null, size, fill, encoding);
        };
        function allocUnsafe(that, size) {
          assertSize(size);
          that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) {
            for (var i = 0; i < size; ++i) {
              that[i] = 0;
            }
          }
          return that;
        }

        /**
         * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
         * */
        Buffer.allocUnsafe = function (size) {
          return allocUnsafe(null, size);
        };
        /**
         * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
         */
        Buffer.allocUnsafeSlow = function (size) {
          return allocUnsafe(null, size);
        };
        function fromString(that, string, encoding) {
          if (typeof encoding !== 'string' || encoding === '') {
            encoding = 'utf8';
          }
          if (!Buffer.isEncoding(encoding)) {
            throw new TypeError('"encoding" must be a valid string encoding');
          }
          var length = byteLength(string, encoding) | 0;
          that = createBuffer(that, length);
          var actual = that.write(string, encoding);
          if (actual !== length) {
            // Writing a hex string, for example, that contains invalid characters will
            // cause everything after the first invalid character to be ignored. (e.g.
            // 'abxxcd' will be treated as 'ab')
            that = that.slice(0, actual);
          }
          return that;
        }
        function fromArrayLike(that, array) {
          var length = array.length < 0 ? 0 : checked(array.length) | 0;
          that = createBuffer(that, length);
          for (var i = 0; i < length; i += 1) {
            that[i] = array[i] & 255;
          }
          return that;
        }
        function fromArrayBuffer(that, array, byteOffset, length) {
          array.byteLength; // this throws if `array` is not a valid ArrayBuffer

          if (byteOffset < 0 || array.byteLength < byteOffset) {
            throw new RangeError('\'offset\' is out of bounds');
          }
          if (array.byteLength < byteOffset + (length || 0)) {
            throw new RangeError('\'length\' is out of bounds');
          }
          if (byteOffset === undefined && length === undefined) {
            array = new Uint8Array(array);
          } else if (length === undefined) {
            array = new Uint8Array(array, byteOffset);
          } else {
            array = new Uint8Array(array, byteOffset, length);
          }
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            // Return an augmented `Uint8Array` instance, for best performance
            that = array;
            that.__proto__ = Buffer.prototype;
          } else {
            // Fallback: Return an object instance of the Buffer class
            that = fromArrayLike(that, array);
          }
          return that;
        }
        function fromObject(that, obj) {
          if (Buffer.isBuffer(obj)) {
            var len = checked(obj.length) | 0;
            that = createBuffer(that, len);
            if (that.length === 0) {
              return that;
            }
            obj.copy(that, 0, 0, len);
            return that;
          }
          if (obj) {
            if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
              if (typeof obj.length !== 'number' || isnan(obj.length)) {
                return createBuffer(that, 0);
              }
              return fromArrayLike(that, obj);
            }
            if (obj.type === 'Buffer' && isArray(obj.data)) {
              return fromArrayLike(that, obj.data);
            }
          }
          throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
        }
        function checked(length) {
          // Note: cannot use `length < kMaxLength()` here because that fails when
          // length is NaN (which is otherwise coerced to zero.)
          if (length >= kMaxLength()) {
            throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
          }
          return length | 0;
        }
        function SlowBuffer(length) {
          if (+length != length) {
            // eslint-disable-line eqeqeq
            length = 0;
          }
          return Buffer.alloc(+length);
        }
        Buffer.isBuffer = function isBuffer(b) {
          return !!(b != null && b._isBuffer);
        };
        Buffer.compare = function compare(a, b) {
          if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
            throw new TypeError('Arguments must be Buffers');
          }
          if (a === b) return 0;
          var x = a.length;
          var y = b.length;
          for (var i = 0, len = Math.min(x, y); i < len; ++i) {
            if (a[i] !== b[i]) {
              x = a[i];
              y = b[i];
              break;
            }
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };
        Buffer.isEncoding = function isEncoding(encoding) {
          switch (String(encoding).toLowerCase()) {
            case 'hex':
            case 'utf8':
            case 'utf-8':
            case 'ascii':
            case 'latin1':
            case 'binary':
            case 'base64':
            case 'ucs2':
            case 'ucs-2':
            case 'utf16le':
            case 'utf-16le':
              return true;
            default:
              return false;
          }
        };
        Buffer.concat = function concat(list, length) {
          if (!isArray(list)) {
            throw new TypeError('"list" argument must be an Array of Buffers');
          }
          if (list.length === 0) {
            return Buffer.alloc(0);
          }
          var i;
          if (length === undefined) {
            length = 0;
            for (i = 0; i < list.length; ++i) {
              length += list[i].length;
            }
          }
          var buffer = Buffer.allocUnsafe(length);
          var pos = 0;
          for (i = 0; i < list.length; ++i) {
            var buf = list[i];
            if (!Buffer.isBuffer(buf)) {
              throw new TypeError('"list" argument must be an Array of Buffers');
            }
            buf.copy(buffer, pos);
            pos += buf.length;
          }
          return buffer;
        };
        function byteLength(string, encoding) {
          if (Buffer.isBuffer(string)) {
            return string.length;
          }
          if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
            return string.byteLength;
          }
          if (typeof string !== 'string') {
            string = '' + string;
          }
          var len = string.length;
          if (len === 0) return 0;

          // Use a for loop to avoid recursion
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case 'ascii':
              case 'latin1':
              case 'binary':
                return len;
              case 'utf8':
              case 'utf-8':
              case undefined:
                return utf8ToBytes(string).length;
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return len * 2;
              case 'hex':
                return len >>> 1;
              case 'base64':
                return base64ToBytes(string).length;
              default:
                if (loweredCase) return utf8ToBytes(string).length; // assume utf8
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        }
        Buffer.byteLength = byteLength;
        function slowToString(encoding, start, end) {
          var loweredCase = false;

          // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
          // property of a typed array.

          // This behaves neither like String nor Uint8Array in that we set start/end
          // to their upper/lower bounds if the value passed is out of range.
          // undefined is handled specially as per ECMA-262 6th Edition,
          // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
          if (start === undefined || start < 0) {
            start = 0;
          }
          // Return early if start > this.length. Done here to prevent potential uint32
          // coercion fail below.
          if (start > this.length) {
            return '';
          }
          if (end === undefined || end > this.length) {
            end = this.length;
          }
          if (end <= 0) {
            return '';
          }

          // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
          end >>>= 0;
          start >>>= 0;
          if (end <= start) {
            return '';
          }
          if (!encoding) encoding = 'utf8';
          while (true) {
            switch (encoding) {
              case 'hex':
                return hexSlice(this, start, end);
              case 'utf8':
              case 'utf-8':
                return utf8Slice(this, start, end);
              case 'ascii':
                return asciiSlice(this, start, end);
              case 'latin1':
              case 'binary':
                return latin1Slice(this, start, end);
              case 'base64':
                return base64Slice(this, start, end);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return utf16leSlice(this, start, end);
              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = (encoding + '').toLowerCase();
                loweredCase = true;
            }
          }
        }

        // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
        // Buffer instances.
        Buffer.prototype._isBuffer = true;
        function swap(b, n, m) {
          var i = b[n];
          b[n] = b[m];
          b[m] = i;
        }
        Buffer.prototype.swap16 = function swap16() {
          var len = this.length;
          if (len % 2 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 16-bits');
          }
          for (var i = 0; i < len; i += 2) {
            swap(this, i, i + 1);
          }
          return this;
        };
        Buffer.prototype.swap32 = function swap32() {
          var len = this.length;
          if (len % 4 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 32-bits');
          }
          for (var i = 0; i < len; i += 4) {
            swap(this, i, i + 3);
            swap(this, i + 1, i + 2);
          }
          return this;
        };
        Buffer.prototype.swap64 = function swap64() {
          var len = this.length;
          if (len % 8 !== 0) {
            throw new RangeError('Buffer size must be a multiple of 64-bits');
          }
          for (var i = 0; i < len; i += 8) {
            swap(this, i, i + 7);
            swap(this, i + 1, i + 6);
            swap(this, i + 2, i + 5);
            swap(this, i + 3, i + 4);
          }
          return this;
        };
        Buffer.prototype.toString = function toString() {
          var length = this.length | 0;
          if (length === 0) return '';
          if (arguments.length === 0) return utf8Slice(this, 0, length);
          return slowToString.apply(this, arguments);
        };
        Buffer.prototype.equals = function equals(b) {
          if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer');
          if (this === b) return true;
          return Buffer.compare(this, b) === 0;
        };
        Buffer.prototype.inspect = function inspect() {
          var str = '';
          var max = exports.INSPECT_MAX_BYTES;
          if (this.length > 0) {
            str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
            if (this.length > max) str += ' ... ';
          }
          return '<Buffer ' + str + '>';
        };
        Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
          if (!Buffer.isBuffer(target)) {
            throw new TypeError('Argument must be a Buffer');
          }
          if (start === undefined) {
            start = 0;
          }
          if (end === undefined) {
            end = target ? target.length : 0;
          }
          if (thisStart === undefined) {
            thisStart = 0;
          }
          if (thisEnd === undefined) {
            thisEnd = this.length;
          }
          if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
            throw new RangeError('out of range index');
          }
          if (thisStart >= thisEnd && start >= end) {
            return 0;
          }
          if (thisStart >= thisEnd) {
            return -1;
          }
          if (start >= end) {
            return 1;
          }
          start >>>= 0;
          end >>>= 0;
          thisStart >>>= 0;
          thisEnd >>>= 0;
          if (this === target) return 0;
          var x = thisEnd - thisStart;
          var y = end - start;
          var len = Math.min(x, y);
          var thisCopy = this.slice(thisStart, thisEnd);
          var targetCopy = target.slice(start, end);
          for (var i = 0; i < len; ++i) {
            if (thisCopy[i] !== targetCopy[i]) {
              x = thisCopy[i];
              y = targetCopy[i];
              break;
            }
          }
          if (x < y) return -1;
          if (y < x) return 1;
          return 0;
        };

        // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
        // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
        //
        // Arguments:
        // - buffer - a Buffer to search
        // - val - a string, Buffer, or number
        // - byteOffset - an index into `buffer`; will be clamped to an int32
        // - encoding - an optional encoding, relevant is val is a string
        // - dir - true for indexOf, false for lastIndexOf
        function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
          // Empty buffer means no match
          if (buffer.length === 0) return -1;

          // Normalize byteOffset
          if (typeof byteOffset === 'string') {
            encoding = byteOffset;
            byteOffset = 0;
          } else if (byteOffset > 0x7fffffff) {
            byteOffset = 0x7fffffff;
          } else if (byteOffset < -0x80000000) {
            byteOffset = -0x80000000;
          }
          byteOffset = +byteOffset; // Coerce to Number.
          if (isNaN(byteOffset)) {
            // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
            byteOffset = dir ? 0 : buffer.length - 1;
          }

          // Normalize byteOffset: negative offsets start from the end of the buffer
          if (byteOffset < 0) byteOffset = buffer.length + byteOffset;
          if (byteOffset >= buffer.length) {
            if (dir) return -1;else byteOffset = buffer.length - 1;
          } else if (byteOffset < 0) {
            if (dir) byteOffset = 0;else return -1;
          }

          // Normalize val
          if (typeof val === 'string') {
            val = Buffer.from(val, encoding);
          }

          // Finally, search either indexOf (if dir is true) or lastIndexOf
          if (Buffer.isBuffer(val)) {
            // Special case: looking for empty string/buffer always fails
            if (val.length === 0) {
              return -1;
            }
            return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
          } else if (typeof val === 'number') {
            val = val & 0xFF; // Search for a byte value [0-255]
            if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
              if (dir) {
                return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
              } else {
                return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
              }
            }
            return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
          }
          throw new TypeError('val must be string, number or Buffer');
        }
        function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
          var indexSize = 1;
          var arrLength = arr.length;
          var valLength = val.length;
          if (encoding !== undefined) {
            encoding = String(encoding).toLowerCase();
            if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
              if (arr.length < 2 || val.length < 2) {
                return -1;
              }
              indexSize = 2;
              arrLength /= 2;
              valLength /= 2;
              byteOffset /= 2;
            }
          }
          function read(buf, i) {
            if (indexSize === 1) {
              return buf[i];
            } else {
              return buf.readUInt16BE(i * indexSize);
            }
          }
          var i;
          if (dir) {
            var foundIndex = -1;
            for (i = byteOffset; i < arrLength; i++) {
              if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
                if (foundIndex === -1) foundIndex = i;
                if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
              } else {
                if (foundIndex !== -1) i -= i - foundIndex;
                foundIndex = -1;
              }
            }
          } else {
            if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;
            for (i = byteOffset; i >= 0; i--) {
              var found = true;
              for (var j = 0; j < valLength; j++) {
                if (read(arr, i + j) !== read(val, j)) {
                  found = false;
                  break;
                }
              }
              if (found) return i;
            }
          }
          return -1;
        }
        Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
          return this.indexOf(val, byteOffset, encoding) !== -1;
        };
        Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
        };
        Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
          return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
        };
        function hexWrite(buf, string, offset, length) {
          offset = Number(offset) || 0;
          var remaining = buf.length - offset;
          if (!length) {
            length = remaining;
          } else {
            length = Number(length);
            if (length > remaining) {
              length = remaining;
            }
          }

          // must be an even number of digits
          var strLen = string.length;
          if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');
          if (length > strLen / 2) {
            length = strLen / 2;
          }
          for (var i = 0; i < length; ++i) {
            var parsed = parseInt(string.substr(i * 2, 2), 16);
            if (isNaN(parsed)) return i;
            buf[offset + i] = parsed;
          }
          return i;
        }
        function utf8Write(buf, string, offset, length) {
          return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
        }
        function asciiWrite(buf, string, offset, length) {
          return blitBuffer(asciiToBytes(string), buf, offset, length);
        }
        function latin1Write(buf, string, offset, length) {
          return asciiWrite(buf, string, offset, length);
        }
        function base64Write(buf, string, offset, length) {
          return blitBuffer(base64ToBytes(string), buf, offset, length);
        }
        function ucs2Write(buf, string, offset, length) {
          return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
        }
        Buffer.prototype.write = function write(string, offset, length, encoding) {
          // Buffer#write(string)
          if (offset === undefined) {
            encoding = 'utf8';
            length = this.length;
            offset = 0;
            // Buffer#write(string, encoding)
          } else if (length === undefined && typeof offset === 'string') {
            encoding = offset;
            length = this.length;
            offset = 0;
            // Buffer#write(string, offset[, length][, encoding])
          } else if (isFinite(offset)) {
            offset = offset | 0;
            if (isFinite(length)) {
              length = length | 0;
              if (encoding === undefined) encoding = 'utf8';
            } else {
              encoding = length;
              length = undefined;
            }
            // legacy write(string, encoding, offset, length) - remove in v0.13
          } else {
            throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
          }
          var remaining = this.length - offset;
          if (length === undefined || length > remaining) length = remaining;
          if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
            throw new RangeError('Attempt to write outside buffer bounds');
          }
          if (!encoding) encoding = 'utf8';
          var loweredCase = false;
          for (;;) {
            switch (encoding) {
              case 'hex':
                return hexWrite(this, string, offset, length);
              case 'utf8':
              case 'utf-8':
                return utf8Write(this, string, offset, length);
              case 'ascii':
                return asciiWrite(this, string, offset, length);
              case 'latin1':
              case 'binary':
                return latin1Write(this, string, offset, length);
              case 'base64':
                // Warning: maxLength not taken into account in base64Write
                return base64Write(this, string, offset, length);
              case 'ucs2':
              case 'ucs-2':
              case 'utf16le':
              case 'utf-16le':
                return ucs2Write(this, string, offset, length);
              default:
                if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
                encoding = ('' + encoding).toLowerCase();
                loweredCase = true;
            }
          }
        };
        Buffer.prototype.toJSON = function toJSON() {
          return {
            type: 'Buffer',
            data: Array.prototype.slice.call(this._arr || this, 0)
          };
        };
        function base64Slice(buf, start, end) {
          if (start === 0 && end === buf.length) {
            return base64.fromByteArray(buf);
          } else {
            return base64.fromByteArray(buf.slice(start, end));
          }
        }
        function utf8Slice(buf, start, end) {
          end = Math.min(buf.length, end);
          var res = [];
          var i = start;
          while (i < end) {
            var firstByte = buf[i];
            var codePoint = null;
            var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;
            if (i + bytesPerSequence <= end) {
              var secondByte, thirdByte, fourthByte, tempCodePoint;
              switch (bytesPerSequence) {
                case 1:
                  if (firstByte < 0x80) {
                    codePoint = firstByte;
                  }
                  break;
                case 2:
                  secondByte = buf[i + 1];
                  if ((secondByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;
                    if (tempCodePoint > 0x7F) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 3:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;
                    if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                      codePoint = tempCodePoint;
                    }
                  }
                  break;
                case 4:
                  secondByte = buf[i + 1];
                  thirdByte = buf[i + 2];
                  fourthByte = buf[i + 3];
                  if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
                    tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;
                    if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                      codePoint = tempCodePoint;
                    }
                  }
              }
            }
            if (codePoint === null) {
              // we did not generate a valid codePoint so insert a
              // replacement char (U+FFFD) and advance only 1 byte
              codePoint = 0xFFFD;
              bytesPerSequence = 1;
            } else if (codePoint > 0xFFFF) {
              // encode to utf16 (surrogate pair dance)
              codePoint -= 0x10000;
              res.push(codePoint >>> 10 & 0x3FF | 0xD800);
              codePoint = 0xDC00 | codePoint & 0x3FF;
            }
            res.push(codePoint);
            i += bytesPerSequence;
          }
          return decodeCodePointsArray(res);
        }

        // Based on http://stackoverflow.com/a/22747272/680742, the browser with
        // the lowest limit is Chrome, with 0x10000 args.
        // We go 1 magnitude less, for safety
        var MAX_ARGUMENTS_LENGTH = 0x1000;
        function decodeCodePointsArray(codePoints) {
          var len = codePoints.length;
          if (len <= MAX_ARGUMENTS_LENGTH) {
            return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
          }

          // Decode in chunks to avoid "call stack size exceeded".
          var res = '';
          var i = 0;
          while (i < len) {
            res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
          }
          return res;
        }
        function asciiSlice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i] & 0x7F);
          }
          return ret;
        }
        function latin1Slice(buf, start, end) {
          var ret = '';
          end = Math.min(buf.length, end);
          for (var i = start; i < end; ++i) {
            ret += String.fromCharCode(buf[i]);
          }
          return ret;
        }
        function hexSlice(buf, start, end) {
          var len = buf.length;
          if (!start || start < 0) start = 0;
          if (!end || end < 0 || end > len) end = len;
          var out = '';
          for (var i = start; i < end; ++i) {
            out += toHex(buf[i]);
          }
          return out;
        }
        function utf16leSlice(buf, start, end) {
          var bytes = buf.slice(start, end);
          var res = '';
          for (var i = 0; i < bytes.length; i += 2) {
            res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
          }
          return res;
        }
        Buffer.prototype.slice = function slice(start, end) {
          var len = this.length;
          start = ~~start;
          end = end === undefined ? len : ~~end;
          if (start < 0) {
            start += len;
            if (start < 0) start = 0;
          } else if (start > len) {
            start = len;
          }
          if (end < 0) {
            end += len;
            if (end < 0) end = 0;
          } else if (end > len) {
            end = len;
          }
          if (end < start) end = start;
          var newBuf;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            newBuf = this.subarray(start, end);
            newBuf.__proto__ = Buffer.prototype;
          } else {
            var sliceLen = end - start;
            newBuf = new Buffer(sliceLen, undefined);
            for (var i = 0; i < sliceLen; ++i) {
              newBuf[i] = this[i + start];
            }
          }
          return newBuf;
        };

        /*
         * Need to make sure that buffer isn't trying to write out of bounds.
         */
        function checkOffset(offset, ext, length) {
          if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
          if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
        }
        Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }
          return val;
        };
        Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            checkOffset(offset, byteLength, this.length);
          }
          var val = this[offset + --byteLength];
          var mul = 1;
          while (byteLength > 0 && (mul *= 0x100)) {
            val += this[offset + --byteLength] * mul;
          }
          return val;
        };
        Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          return this[offset];
        };
        Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] | this[offset + 1] << 8;
        };
        Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          return this[offset] << 8 | this[offset + 1];
        };
        Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
        };
        Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
        };
        Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var val = this[offset];
          var mul = 1;
          var i = 0;
          while (++i < byteLength && (mul *= 0x100)) {
            val += this[offset + i] * mul;
          }
          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };
        Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) checkOffset(offset, byteLength, this.length);
          var i = byteLength;
          var mul = 1;
          var val = this[offset + --i];
          while (i > 0 && (mul *= 0x100)) {
            val += this[offset + --i] * mul;
          }
          mul *= 0x80;
          if (val >= mul) val -= Math.pow(2, 8 * byteLength);
          return val;
        };
        Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 1, this.length);
          if (!(this[offset] & 0x80)) return this[offset];
          return (0xff - this[offset] + 1) * -1;
        };
        Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset] | this[offset + 1] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };
        Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 2, this.length);
          var val = this[offset + 1] | this[offset] << 8;
          return val & 0x8000 ? val | 0xFFFF0000 : val;
        };
        Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
        };
        Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
        };
        Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, true, 23, 4);
        };
        Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 4, this.length);
          return ieee754.read(this, offset, false, 23, 4);
        };
        Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, true, 52, 8);
        };
        Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
          if (!noAssert) checkOffset(offset, 8, this.length);
          return ieee754.read(this, offset, false, 52, 8);
        };
        function checkInt(buf, value, offset, ext, max, min) {
          if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
          if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
        }
        Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }
          var mul = 1;
          var i = 0;
          this[offset] = value & 0xFF;
          while (++i < byteLength && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          byteLength = byteLength | 0;
          if (!noAssert) {
            var maxBytes = Math.pow(2, 8 * byteLength) - 1;
            checkInt(this, value, offset, byteLength, maxBytes, 0);
          }
          var i = byteLength - 1;
          var mul = 1;
          this[offset + i] = value & 0xFF;
          while (--i >= 0 && (mul *= 0x100)) {
            this[offset + i] = value / mul & 0xFF;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          this[offset] = value & 0xff;
          return offset + 1;
        };
        function objectWriteUInt16(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
            buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
          }
        }
        Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        function objectWriteUInt32(buf, value, offset, littleEndian) {
          if (value < 0) value = 0xffffffff + value + 1;
          for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
            buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
          }
        }
        Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset + 3] = value >>> 24;
            this[offset + 2] = value >>> 16;
            this[offset + 1] = value >>> 8;
            this[offset] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }
          var i = 0;
          var mul = 1;
          var sub = 0;
          this[offset] = value & 0xFF;
          while (++i < byteLength && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) {
            var limit = Math.pow(2, 8 * byteLength - 1);
            checkInt(this, value, offset, byteLength, limit - 1, -limit);
          }
          var i = byteLength - 1;
          var mul = 1;
          var sub = 0;
          this[offset + i] = value & 0xFF;
          while (--i >= 0 && (mul *= 0x100)) {
            if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
              sub = 1;
            }
            this[offset + i] = (value / mul >> 0) - sub & 0xFF;
          }
          return offset + byteLength;
        };
        Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
          if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
          if (value < 0) value = 0xff + value + 1;
          this[offset] = value & 0xff;
          return offset + 1;
        };
        Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
          } else {
            objectWriteUInt16(this, value, offset, true);
          }
          return offset + 2;
        };
        Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 8;
            this[offset + 1] = value & 0xff;
          } else {
            objectWriteUInt16(this, value, offset, false);
          }
          return offset + 2;
        };
        Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value & 0xff;
            this[offset + 1] = value >>> 8;
            this[offset + 2] = value >>> 16;
            this[offset + 3] = value >>> 24;
          } else {
            objectWriteUInt32(this, value, offset, true);
          }
          return offset + 4;
        };
        Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
          value = +value;
          offset = offset | 0;
          if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
          if (value < 0) value = 0xffffffff + value + 1;
          if (Buffer.TYPED_ARRAY_SUPPORT) {
            this[offset] = value >>> 24;
            this[offset + 1] = value >>> 16;
            this[offset + 2] = value >>> 8;
            this[offset + 3] = value & 0xff;
          } else {
            objectWriteUInt32(this, value, offset, false);
          }
          return offset + 4;
        };
        function checkIEEE754(buf, value, offset, ext, max, min) {
          if (offset + ext > buf.length) throw new RangeError('Index out of range');
          if (offset < 0) throw new RangeError('Index out of range');
        }
        function writeFloat(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38);
          }
          ieee754.write(buf, value, offset, littleEndian, 23, 4);
          return offset + 4;
        }
        Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
          return writeFloat(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
          return writeFloat(this, value, offset, false, noAssert);
        };
        function writeDouble(buf, value, offset, littleEndian, noAssert) {
          if (!noAssert) {
            checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308);
          }
          ieee754.write(buf, value, offset, littleEndian, 52, 8);
          return offset + 8;
        }
        Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
          return writeDouble(this, value, offset, true, noAssert);
        };
        Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
          return writeDouble(this, value, offset, false, noAssert);
        };

        // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
        Buffer.prototype.copy = function copy(target, targetStart, start, end) {
          if (!start) start = 0;
          if (!end && end !== 0) end = this.length;
          if (targetStart >= target.length) targetStart = target.length;
          if (!targetStart) targetStart = 0;
          if (end > 0 && end < start) end = start;

          // Copy 0 bytes; we're done
          if (end === start) return 0;
          if (target.length === 0 || this.length === 0) return 0;

          // Fatal error conditions
          if (targetStart < 0) {
            throw new RangeError('targetStart out of bounds');
          }
          if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
          if (end < 0) throw new RangeError('sourceEnd out of bounds');

          // Are we oob?
          if (end > this.length) end = this.length;
          if (target.length - targetStart < end - start) {
            end = target.length - targetStart + start;
          }
          var len = end - start;
          var i;
          if (this === target && start < targetStart && targetStart < end) {
            // descending copy from end
            for (i = len - 1; i >= 0; --i) {
              target[i + targetStart] = this[i + start];
            }
          } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
            // ascending copy from start
            for (i = 0; i < len; ++i) {
              target[i + targetStart] = this[i + start];
            }
          } else {
            Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
          }
          return len;
        };

        // Usage:
        //    buffer.fill(number[, offset[, end]])
        //    buffer.fill(buffer[, offset[, end]])
        //    buffer.fill(string[, offset[, end]][, encoding])
        Buffer.prototype.fill = function fill(val, start, end, encoding) {
          // Handle string cases:
          if (typeof val === 'string') {
            if (typeof start === 'string') {
              encoding = start;
              start = 0;
              end = this.length;
            } else if (typeof end === 'string') {
              encoding = end;
              end = this.length;
            }
            if (val.length === 1) {
              var code = val.charCodeAt(0);
              if (code < 256) {
                val = code;
              }
            }
            if (encoding !== undefined && typeof encoding !== 'string') {
              throw new TypeError('encoding must be a string');
            }
            if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
              throw new TypeError('Unknown encoding: ' + encoding);
            }
          } else if (typeof val === 'number') {
            val = val & 255;
          }

          // Invalid ranges are not set to a default, so can range check early.
          if (start < 0 || this.length < start || this.length < end) {
            throw new RangeError('Out of range index');
          }
          if (end <= start) {
            return this;
          }
          start = start >>> 0;
          end = end === undefined ? this.length : end >>> 0;
          if (!val) val = 0;
          var i;
          if (typeof val === 'number') {
            for (i = start; i < end; ++i) {
              this[i] = val;
            }
          } else {
            var bytes = Buffer.isBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
            var len = bytes.length;
            for (i = 0; i < end - start; ++i) {
              this[i + start] = bytes[i % len];
            }
          }
          return this;
        };

        // HELPER FUNCTIONS
        // ================

        var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;
        function base64clean(str) {
          // Node strips out invalid characters like \n and \t from the string, base64-js does not
          str = stringtrim(str).replace(INVALID_BASE64_RE, '');
          // Node converts strings with length < 2 to ''
          if (str.length < 2) return '';
          // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
          while (str.length % 4 !== 0) {
            str = str + '=';
          }
          return str;
        }
        function stringtrim(str) {
          if (str.trim) return str.trim();
          return str.replace(/^\s+|\s+$/g, '');
        }
        function toHex(n) {
          if (n < 16) return '0' + n.toString(16);
          return n.toString(16);
        }
        function utf8ToBytes(string, units) {
          units = units || Infinity;
          var codePoint;
          var length = string.length;
          var leadSurrogate = null;
          var bytes = [];
          for (var i = 0; i < length; ++i) {
            codePoint = string.charCodeAt(i);

            // is surrogate component
            if (codePoint > 0xD7FF && codePoint < 0xE000) {
              // last char was a lead
              if (!leadSurrogate) {
                // no lead yet
                if (codePoint > 0xDBFF) {
                  // unexpected trail
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                } else if (i + 1 === length) {
                  // unpaired lead
                  if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                  continue;
                }

                // valid lead
                leadSurrogate = codePoint;
                continue;
              }

              // 2 leads in a row
              if (codePoint < 0xDC00) {
                if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
                leadSurrogate = codePoint;
                continue;
              }

              // valid surrogate pair
              codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
            } else if (leadSurrogate) {
              // valid bmp char, but last char was a lead
              if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            }
            leadSurrogate = null;

            // encode utf8
            if (codePoint < 0x80) {
              if ((units -= 1) < 0) break;
              bytes.push(codePoint);
            } else if (codePoint < 0x800) {
              if ((units -= 2) < 0) break;
              bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x10000) {
              if ((units -= 3) < 0) break;
              bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else if (codePoint < 0x110000) {
              if ((units -= 4) < 0) break;
              bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
            } else {
              throw new Error('Invalid code point');
            }
          }
          return bytes;
        }
        function asciiToBytes(str) {
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            // Node's code seems to be doing this and not & 0x7F..
            byteArray.push(str.charCodeAt(i) & 0xFF);
          }
          return byteArray;
        }
        function utf16leToBytes(str, units) {
          var c, hi, lo;
          var byteArray = [];
          for (var i = 0; i < str.length; ++i) {
            if ((units -= 2) < 0) break;
            c = str.charCodeAt(i);
            hi = c >> 8;
            lo = c % 256;
            byteArray.push(lo);
            byteArray.push(hi);
          }
          return byteArray;
        }
        function base64ToBytes(str) {
          return base64.toByteArray(base64clean(str));
        }
        function blitBuffer(src, dst, offset, length) {
          for (var i = 0; i < length; ++i) {
            if (i + offset >= dst.length || i >= src.length) break;
            dst[i + offset] = src[i];
          }
          return i;
        }
        function isnan(val) {
          return val !== val; // eslint-disable-line no-self-compare
        }

        /* WEBPACK VAR INJECTION */
      }).call(this, __nested_webpack_require_29483__( /*! ./../webpack/buildin/global.js */"./node_modules/webpack/buildin/global.js"));

      /***/
    }),
    /***/"./node_modules/buffer/node_modules/isarray/index.js": (
    /*!***********************************************************!*\
      !*** ./node_modules/buffer/node_modules/isarray/index.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_buffer_node_modules_isarray_indexJs(module, exports) {
      var toString = {}.toString;
      module.exports = Array.isArray || function (arr) {
        return toString.call(arr) == '[object Array]';
      };

      /***/
    }),
    /***/"./node_modules/cross-fetch/dist/browser-ponyfill.js": (
    /*!***********************************************************!*\
      !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!
      \***********************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_crossFetch_dist_browserPonyfillJs(module, exports) {
      var global = typeof self !== 'undefined' ? self : this;
      var __self__ = function () {
        function F() {
          this.fetch = false;
          this.DOMException = global.DOMException;
        }
        F.prototype = global;
        return new F();
      }();
      (function (self) {
        var irrelevant = function (exports) {
          var support = {
            searchParams: 'URLSearchParams' in self,
            iterable: 'Symbol' in self && 'iterator' in Symbol,
            blob: 'FileReader' in self && 'Blob' in self && function () {
              try {
                new Blob();
                return true;
              } catch (e) {
                return false;
              }
            }(),
            formData: 'FormData' in self,
            arrayBuffer: 'ArrayBuffer' in self
          };
          function isDataView(obj) {
            return obj && DataView.prototype.isPrototypeOf(obj);
          }
          if (support.arrayBuffer) {
            var viewClasses = ['[object Int8Array]', '[object Uint8Array]', '[object Uint8ClampedArray]', '[object Int16Array]', '[object Uint16Array]', '[object Int32Array]', '[object Uint32Array]', '[object Float32Array]', '[object Float64Array]'];
            var isArrayBufferView = ArrayBuffer.isView || function (obj) {
              return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1;
            };
          }
          function normalizeName(name) {
            if (typeof name !== 'string') {
              name = String(name);
            }
            if (/[^a-z0-9\-#$%&'*+.^_`|~]/i.test(name)) {
              throw new TypeError('Invalid character in header field name');
            }
            return name.toLowerCase();
          }
          function normalizeValue(value) {
            if (typeof value !== 'string') {
              value = String(value);
            }
            return value;
          }

          // Build a destructive iterator for the value list
          function iteratorFor(items) {
            var iterator = {
              next: function next() {
                var value = items.shift();
                return {
                  done: value === undefined,
                  value: value
                };
              }
            };
            if (support.iterable) {
              iterator[Symbol.iterator] = function () {
                return iterator;
              };
            }
            return iterator;
          }
          function Headers(headers) {
            this.map = {};
            if (headers instanceof Headers) {
              headers.forEach(function (value, name) {
                this.append(name, value);
              }, this);
            } else if (Array.isArray(headers)) {
              headers.forEach(function (header) {
                this.append(header[0], header[1]);
              }, this);
            } else if (headers) {
              Object.getOwnPropertyNames(headers).forEach(function (name) {
                this.append(name, headers[name]);
              }, this);
            }
          }
          Headers.prototype.append = function (name, value) {
            name = normalizeName(name);
            value = normalizeValue(value);
            var oldValue = this.map[name];
            this.map[name] = oldValue ? oldValue + ', ' + value : value;
          };
          Headers.prototype['delete'] = function (name) {
            delete this.map[normalizeName(name)];
          };
          Headers.prototype.get = function (name) {
            name = normalizeName(name);
            return this.has(name) ? this.map[name] : null;
          };
          Headers.prototype.has = function (name) {
            return this.map.hasOwnProperty(normalizeName(name));
          };
          Headers.prototype.set = function (name, value) {
            this.map[normalizeName(name)] = normalizeValue(value);
          };
          Headers.prototype.forEach = function (callback, thisArg) {
            for (var name in this.map) {
              if (this.map.hasOwnProperty(name)) {
                callback.call(thisArg, this.map[name], name, this);
              }
            }
          };
          Headers.prototype.keys = function () {
            var items = [];
            this.forEach(function (value, name) {
              items.push(name);
            });
            return iteratorFor(items);
          };
          Headers.prototype.values = function () {
            var items = [];
            this.forEach(function (value) {
              items.push(value);
            });
            return iteratorFor(items);
          };
          Headers.prototype.entries = function () {
            var items = [];
            this.forEach(function (value, name) {
              items.push([name, value]);
            });
            return iteratorFor(items);
          };
          if (support.iterable) {
            Headers.prototype[Symbol.iterator] = Headers.prototype.entries;
          }
          function consumed(body) {
            if (body.bodyUsed) {
              return Promise.reject(new TypeError('Already read'));
            }
            body.bodyUsed = true;
          }
          function fileReaderReady(reader) {
            return new Promise(function (resolve, reject) {
              reader.onload = function () {
                resolve(reader.result);
              };
              reader.onerror = function () {
                reject(reader.error);
              };
            });
          }
          function readBlobAsArrayBuffer(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsArrayBuffer(blob);
            return promise;
          }
          function readBlobAsText(blob) {
            var reader = new FileReader();
            var promise = fileReaderReady(reader);
            reader.readAsText(blob);
            return promise;
          }
          function readArrayBufferAsText(buf) {
            var view = new Uint8Array(buf);
            var chars = new Array(view.length);
            for (var i = 0; i < view.length; i++) {
              chars[i] = String.fromCharCode(view[i]);
            }
            return chars.join('');
          }
          function bufferClone(buf) {
            if (buf.slice) {
              return buf.slice(0);
            } else {
              var view = new Uint8Array(buf.byteLength);
              view.set(new Uint8Array(buf));
              return view.buffer;
            }
          }
          function Body() {
            this.bodyUsed = false;
            this._initBody = function (body) {
              this._bodyInit = body;
              if (!body) {
                this._bodyText = '';
              } else if (typeof body === 'string') {
                this._bodyText = body;
              } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {
                this._bodyBlob = body;
              } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {
                this._bodyFormData = body;
              } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                this._bodyText = body.toString();
              } else if (support.arrayBuffer && support.blob && isDataView(body)) {
                this._bodyArrayBuffer = bufferClone(body.buffer);
                // IE 10-11 can't handle a DataView body.
                this._bodyInit = new Blob([this._bodyArrayBuffer]);
              } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {
                this._bodyArrayBuffer = bufferClone(body);
              } else {
                this._bodyText = body = Object.prototype.toString.call(body);
              }
              if (!this.headers.get('content-type')) {
                if (typeof body === 'string') {
                  this.headers.set('content-type', 'text/plain;charset=UTF-8');
                } else if (this._bodyBlob && this._bodyBlob.type) {
                  this.headers.set('content-type', this._bodyBlob.type);
                } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {
                  this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');
                }
              }
            };
            if (support.blob) {
              this.blob = function () {
                var rejected = consumed(this);
                if (rejected) {
                  return rejected;
                }
                if (this._bodyBlob) {
                  return Promise.resolve(this._bodyBlob);
                } else if (this._bodyArrayBuffer) {
                  return Promise.resolve(new Blob([this._bodyArrayBuffer]));
                } else if (this._bodyFormData) {
                  throw new Error('could not read FormData body as blob');
                } else {
                  return Promise.resolve(new Blob([this._bodyText]));
                }
              };
              this.arrayBuffer = function () {
                if (this._bodyArrayBuffer) {
                  return consumed(this) || Promise.resolve(this._bodyArrayBuffer);
                } else {
                  return this.blob().then(readBlobAsArrayBuffer);
                }
              };
            }
            this.text = function () {
              var rejected = consumed(this);
              if (rejected) {
                return rejected;
              }
              if (this._bodyBlob) {
                return readBlobAsText(this._bodyBlob);
              } else if (this._bodyArrayBuffer) {
                return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer));
              } else if (this._bodyFormData) {
                throw new Error('could not read FormData body as text');
              } else {
                return Promise.resolve(this._bodyText);
              }
            };
            if (support.formData) {
              this.formData = function () {
                return this.text().then(decode);
              };
            }
            this.json = function () {
              return this.text().then(JSON.parse);
            };
            return this;
          }

          // HTTP methods whose capitalization should be normalized
          var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];
          function normalizeMethod(method) {
            var upcased = method.toUpperCase();
            return methods.indexOf(upcased) > -1 ? upcased : method;
          }
          function Request(input, options) {
            options = options || {};
            var body = options.body;
            if (input instanceof Request) {
              if (input.bodyUsed) {
                throw new TypeError('Already read');
              }
              this.url = input.url;
              this.credentials = input.credentials;
              if (!options.headers) {
                this.headers = new Headers(input.headers);
              }
              this.method = input.method;
              this.mode = input.mode;
              this.signal = input.signal;
              if (!body && input._bodyInit != null) {
                body = input._bodyInit;
                input.bodyUsed = true;
              }
            } else {
              this.url = String(input);
            }
            this.credentials = options.credentials || this.credentials || 'same-origin';
            if (options.headers || !this.headers) {
              this.headers = new Headers(options.headers);
            }
            this.method = normalizeMethod(options.method || this.method || 'GET');
            this.mode = options.mode || this.mode || null;
            this.signal = options.signal || this.signal;
            this.referrer = null;
            if ((this.method === 'GET' || this.method === 'HEAD') && body) {
              throw new TypeError('Body not allowed for GET or HEAD requests');
            }
            this._initBody(body);
          }
          Request.prototype.clone = function () {
            return new Request(this, {
              body: this._bodyInit
            });
          };
          function decode(body) {
            var form = new FormData();
            body.trim().split('&').forEach(function (bytes) {
              if (bytes) {
                var split = bytes.split('=');
                var name = split.shift().replace(/\+/g, ' ');
                var value = split.join('=').replace(/\+/g, ' ');
                form.append(decodeURIComponent(name), decodeURIComponent(value));
              }
            });
            return form;
          }
          function parseHeaders(rawHeaders) {
            var headers = new Headers();
            // Replace instances of \r\n and \n followed by at least one space or horizontal tab with a space
            // https://tools.ietf.org/html/rfc7230#section-3.2
            var preProcessedHeaders = rawHeaders.replace(/\r?\n[\t ]+/g, ' ');
            preProcessedHeaders.split(/\r?\n/).forEach(function (line) {
              var parts = line.split(':');
              var key = parts.shift().trim();
              if (key) {
                var value = parts.join(':').trim();
                headers.append(key, value);
              }
            });
            return headers;
          }
          Body.call(Request.prototype);
          function Response(bodyInit, options) {
            if (!options) {
              options = {};
            }
            this.type = 'default';
            this.status = options.status === undefined ? 200 : options.status;
            this.ok = this.status >= 200 && this.status < 300;
            this.statusText = 'statusText' in options ? options.statusText : 'OK';
            this.headers = new Headers(options.headers);
            this.url = options.url || '';
            this._initBody(bodyInit);
          }
          Body.call(Response.prototype);
          Response.prototype.clone = function () {
            return new Response(this._bodyInit, {
              status: this.status,
              statusText: this.statusText,
              headers: new Headers(this.headers),
              url: this.url
            });
          };
          Response.error = function () {
            var response = new Response(null, {
              status: 0,
              statusText: ''
            });
            response.type = 'error';
            return response;
          };
          var redirectStatuses = [301, 302, 303, 307, 308];
          Response.redirect = function (url, status) {
            if (redirectStatuses.indexOf(status) === -1) {
              throw new RangeError('Invalid status code');
            }
            return new Response(null, {
              status: status,
              headers: {
                location: url
              }
            });
          };
          exports.DOMException = self.DOMException;
          try {
            new exports.DOMException();
          } catch (err) {
            exports.DOMException = function (message, name) {
              this.message = message;
              this.name = name;
              var error = Error(message);
              this.stack = error.stack;
            };
            exports.DOMException.prototype = Object.create(Error.prototype);
            exports.DOMException.prototype.constructor = exports.DOMException;
          }
          function fetch(input, init) {
            return new Promise(function (resolve, reject) {
              var request = new Request(input, init);
              if (request.signal && request.signal.aborted) {
                return reject(new exports.DOMException('Aborted', 'AbortError'));
              }
              var xhr = new XMLHttpRequest();
              function abortXhr() {
                xhr.abort();
              }
              xhr.onload = function () {
                var options = {
                  status: xhr.status,
                  statusText: xhr.statusText,
                  headers: parseHeaders(xhr.getAllResponseHeaders() || '')
                };
                options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');
                var body = 'response' in xhr ? xhr.response : xhr.responseText;
                resolve(new Response(body, options));
              };
              xhr.onerror = function () {
                reject(new TypeError('Network request failed'));
              };
              xhr.ontimeout = function () {
                reject(new TypeError('Network request failed'));
              };
              xhr.onabort = function () {
                reject(new exports.DOMException('Aborted', 'AbortError'));
              };
              xhr.open(request.method, request.url, true);
              if (request.credentials === 'include') {
                xhr.withCredentials = true;
              } else if (request.credentials === 'omit') {
                xhr.withCredentials = false;
              }
              if ('responseType' in xhr && support.blob) {
                xhr.responseType = 'blob';
              }
              request.headers.forEach(function (value, name) {
                xhr.setRequestHeader(name, value);
              });
              if (request.signal) {
                request.signal.addEventListener('abort', abortXhr);
                xhr.onreadystatechange = function () {
                  // DONE (success or failure)
                  if (xhr.readyState === 4) {
                    request.signal.removeEventListener('abort', abortXhr);
                  }
                };
              }
              xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);
            });
          }
          fetch.polyfill = true;
          if (!self.fetch) {
            self.fetch = fetch;
            self.Headers = Headers;
            self.Request = Request;
            self.Response = Response;
          }
          exports.Headers = Headers;
          exports.Request = Request;
          exports.Response = Response;
          exports.fetch = fetch;
          Object.defineProperty(exports, '__esModule', {
            value: true
          });
          return exports;
        }({});
      })(__self__);
      __self__.fetch.ponyfill = true;
      // Remove "polyfill" property added by whatwg-fetch
      delete __self__.fetch.polyfill;
      // Choose between native implementation (global) or custom implementation (__self__)
      // var ctx = global.fetch ? global : __self__;
      var ctx = __self__; // this line disable service worker support temporarily
      exports = ctx.fetch; // To enable: import fetch from 'cross-fetch'
      exports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.
      exports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'
      exports.Headers = ctx.Headers;
      exports.Request = ctx.Request;
      exports.Response = ctx.Response;
      module.exports = exports;

      /***/
    }),
    /***/"./node_modules/fastestsmallesttextencoderdecoder/EncoderDecoderTogether.min.js": (
    /*!**************************************************************************************!*\
      !*** ./node_modules/fastestsmallesttextencoderdecoder/EncoderDecoderTogether.min.js ***!
      \**************************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_fastestsmallesttextencoderdecoder_EncoderDecoderTogetherMinJs(module, exports, __nested_webpack_require_111098__) {
      "use strict";

      /* WEBPACK VAR INJECTION */
      (function (global) {
        (function (r) {
          function x() {}
          function y() {}
          var z = String.fromCharCode,
            v = {}.toString,
            A = v.call(r.SharedArrayBuffer),
            B = v(),
            q = r.Uint8Array,
            t = q || Array,
            w = q ? ArrayBuffer : t,
            C = w.isView || function (g) {
              return g && "length" in g;
            },
            D = v.call(w.prototype);
          w = y.prototype;
          var E = r.TextEncoder,
            a = new (q ? Uint16Array : t)(32);
          x.prototype.decode = function (g) {
            if (!C(g)) {
              var l = v.call(g);
              if (l !== D && l !== A && l !== B) throw TypeError("Failed to execute 'decode' on 'TextDecoder': The provided value is not of type '(ArrayBuffer or ArrayBufferView)'");
              g = q ? new t(g) : g || [];
            }
            for (var f = l = "", b = 0, c = g.length | 0, u = c - 32 | 0, e, d, h = 0, p = 0, m, k = 0, n = -1; b < c;) {
              for (e = b <= u ? 32 : c - b | 0; k < e; b = b + 1 | 0, k = k + 1 | 0) {
                d = g[b] & 255;
                switch (d >> 4) {
                  case 15:
                    m = g[b = b + 1 | 0] & 255;
                    if (2 !== m >> 6 || 247 < d) {
                      b = b - 1 | 0;
                      break;
                    }
                    h = (d & 7) << 6 | m & 63;
                    p = 5;
                    d = 256;
                  case 14:
                    m = g[b = b + 1 | 0] & 255, h <<= 6, h |= (d & 15) << 6 | m & 63, p = 2 === m >> 6 ? p + 4 | 0 : 24, d = d + 256 & 768;
                  case 13:
                  case 12:
                    m = g[b = b + 1 | 0] & 255, h <<= 6, h |= (d & 31) << 6 | m & 63, p = p + 7 | 0, b < c && 2 === m >> 6 && h >> p && 1114112 > h ? (d = h, h = h - 65536 | 0, 0 <= h && (n = (h >> 10) + 55296 | 0, d = (h & 1023) + 56320 | 0, 31 > k ? (a[k] = n, k = k + 1 | 0, n = -1) : (m = n, n = d, d = m))) : (d >>= 8, b = b - d - 1 | 0, d = 65533), h = p = 0, e = b <= u ? 32 : c - b | 0;
                  default:
                    a[k] = d;
                    continue;
                  case 11:
                  case 10:
                  case 9:
                  case 8:
                }
                a[k] = 65533;
              }
              f += z(a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7], a[8], a[9], a[10], a[11], a[12], a[13], a[14], a[15], a[16], a[17], a[18], a[19], a[20], a[21], a[22], a[23], a[24], a[25], a[26], a[27], a[28], a[29], a[30], a[31]);
              32 > k && (f = f.slice(0, k - 32 | 0));
              if (b < c) {
                if (a[0] = n, k = ~n >>> 31, n = -1, f.length < l.length) continue;
              } else -1 !== n && (f += z(n));
              l += f;
              f = "";
            }
            return l;
          };
          w.encode = function (g) {
            g = void 0 === g ? "" : "" + g;
            var l = g.length | 0,
              f = new t((l << 1) + 8 | 0),
              b,
              c = 0,
              u = !q;
            for (b = 0; b < l; b = b + 1 | 0, c = c + 1 | 0) {
              var e = g.charCodeAt(b) | 0;
              if (127 >= e) f[c] = e;else {
                if (2047 >= e) f[c] = 192 | e >> 6;else {
                  a: {
                    if (55296 <= e) if (56319 >= e) {
                      var d = g.charCodeAt(b = b + 1 | 0) | 0;
                      if (56320 <= d && 57343 >= d) {
                        e = (e << 10) + d - 56613888 | 0;
                        if (65535 < e) {
                          f[c] = 240 | e >> 18;
                          f[c = c + 1 | 0] = 128 | e >> 12 & 63;
                          f[c = c + 1 | 0] = 128 | e >> 6 & 63;
                          f[c = c + 1 | 0] = 128 | e & 63;
                          continue;
                        }
                        break a;
                      }
                      e = 65533;
                    } else 57343 >= e && (e = 65533);
                    !u && b << 1 < c && b << 1 < (c - 7 | 0) && (u = !0, d = new t(3 * l), d.set(f), f = d);
                  }
                  f[c] = 224 | e >> 12;
                  f[c = c + 1 | 0] = 128 | e >> 6 & 63;
                }
                f[c = c + 1 | 0] = 128 | e & 63;
              }
            }
            return q ? f.subarray(0, c) : f.slice(0, c);
          };
          E || (r.TextDecoder = x, r.TextEncoder = y);
        })("" + void 0 == typeof global ? "" + void 0 == typeof self ? this : self : global); //AnonyCo

        /* WEBPACK VAR INJECTION */
      }).call(this, __nested_webpack_require_111098__( /*! ./../webpack/buildin/global.js */"./node_modules/webpack/buildin/global.js"));

      /***/
    }),
    /***/"./node_modules/ieee754/index.js": (
    /*!***************************************!*\
      !*** ./node_modules/ieee754/index.js ***!
      \***************************************/
    /*! no static exports found */
    /***/
    function _node_modules_ieee754_indexJs(module, exports) {
      /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
      exports.read = function (buffer, offset, isLE, mLen, nBytes) {
        var e, m;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var nBits = -7;
        var i = isLE ? nBytes - 1 : 0;
        var d = isLE ? -1 : 1;
        var s = buffer[offset + i];
        i += d;
        e = s & (1 << -nBits) - 1;
        s >>= -nBits;
        nBits += eLen;
        for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        m = e & (1 << -nBits) - 1;
        e >>= -nBits;
        nBits += mLen;
        for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}
        if (e === 0) {
          e = 1 - eBias;
        } else if (e === eMax) {
          return m ? NaN : (s ? -1 : 1) * Infinity;
        } else {
          m = m + Math.pow(2, mLen);
          e = e - eBias;
        }
        return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
      };
      exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
        var e, m, c;
        var eLen = nBytes * 8 - mLen - 1;
        var eMax = (1 << eLen) - 1;
        var eBias = eMax >> 1;
        var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
        var i = isLE ? 0 : nBytes - 1;
        var d = isLE ? 1 : -1;
        var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
        value = Math.abs(value);
        if (isNaN(value) || value === Infinity) {
          m = isNaN(value) ? 1 : 0;
          e = eMax;
        } else {
          e = Math.floor(Math.log(value) / Math.LN2);
          if (value * (c = Math.pow(2, -e)) < 1) {
            e--;
            c *= 2;
          }
          if (e + eBias >= 1) {
            value += rt / c;
          } else {
            value += rt * Math.pow(2, 1 - eBias);
          }
          if (value * c >= 2) {
            e++;
            c /= 2;
          }
          if (e + eBias >= eMax) {
            m = 0;
            e = eMax;
          } else if (e + eBias >= 1) {
            m = (value * c - 1) * Math.pow(2, mLen);
            e = e + eBias;
          } else {
            m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
            e = 0;
          }
        }
        for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
        e = e << mLen | m;
        eLen += mLen;
        for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
        buffer[offset + i - d] |= s * 128;
      };

      /***/
    }),
    /***/"./node_modules/js-md5/src/md5.js": (
    /*!****************************************!*\
      !*** ./node_modules/js-md5/src/md5.js ***!
      \****************************************/
    /*! no static exports found */
    /***/
    function _node_modules_jsMd5_src_md5Js(module, exports, __nested_webpack_require_119215__) {
      /* WEBPACK VAR INJECTION */(function (process, global) {
        var __WEBPACK_AMD_DEFINE_RESULT__; /**
                                           * [js-md5]{@link https://github.com/emn178/js-md5}
                                           *
                                           * @namespace md5
                                           * @version 0.7.3
                                           * @author Chen, Yi-Cyuan [emn178@gmail.com]
                                           * @copyright Chen, Yi-Cyuan 2014-2017
                                           * @license MIT
                                           */
        (function () {
          'use strict';

          var ERROR = 'input is invalid type';
          var WINDOW = typeof window === 'object';
          var root = WINDOW ? window : {};
          if (root.JS_MD5_NO_WINDOW) {
            WINDOW = false;
          }
          var WEB_WORKER = !WINDOW && typeof self === 'object';
          var NODE_JS = !root.JS_MD5_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
          if (NODE_JS) {
            root = global;
          } else if (WEB_WORKER) {
            root = self;
          }
          var COMMON_JS = !root.JS_MD5_NO_COMMON_JS && typeof module === 'object' && module.exports;
          var AMD =  true && __nested_webpack_require_119215__( /*! !webpack amd options */"./node_modules/webpack/buildin/amd-options.js");
          var ARRAY_BUFFER = !root.JS_MD5_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
          var HEX_CHARS = '0123456789abcdef'.split('');
          var EXTRA = [128, 32768, 8388608, -2147483648];
          var SHIFT = [0, 8, 16, 24];
          var OUTPUT_TYPES = ['hex', 'array', 'digest', 'buffer', 'arrayBuffer', 'base64'];
          var BASE64_ENCODE_CHAR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
          var blocks = [],
            buffer8;
          if (ARRAY_BUFFER) {
            var buffer = new ArrayBuffer(68);
            buffer8 = new Uint8Array(buffer);
            blocks = new Uint32Array(buffer);
          }
          if (root.JS_MD5_NO_NODE_JS || !Array.isArray) {
            Array.isArray = function (obj) {
              return Object.prototype.toString.call(obj) === '[object Array]';
            };
          }
          if (ARRAY_BUFFER && (root.JS_MD5_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
            ArrayBuffer.isView = function (obj) {
              return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
            };
          }

          /**
           * @method hex
           * @memberof md5
           * @description Output hash as hex string
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {String} Hex string
           * @example
           * md5.hex('The quick brown fox jumps over the lazy dog');
           * // equal to
           * md5('The quick brown fox jumps over the lazy dog');
           */
          /**
           * @method digest
           * @memberof md5
           * @description Output hash as bytes array
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {Array} Bytes array
           * @example
           * md5.digest('The quick brown fox jumps over the lazy dog');
           */
          /**
           * @method array
           * @memberof md5
           * @description Output hash as bytes array
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {Array} Bytes array
           * @example
           * md5.array('The quick brown fox jumps over the lazy dog');
           */
          /**
           * @method arrayBuffer
           * @memberof md5
           * @description Output hash as ArrayBuffer
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {ArrayBuffer} ArrayBuffer
           * @example
           * md5.arrayBuffer('The quick brown fox jumps over the lazy dog');
           */
          /**
           * @method buffer
           * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
           * @memberof md5
           * @description Output hash as ArrayBuffer
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {ArrayBuffer} ArrayBuffer
           * @example
           * md5.buffer('The quick brown fox jumps over the lazy dog');
           */
          /**
           * @method base64
           * @memberof md5
           * @description Output hash as base64 string
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {String} base64 string
           * @example
           * md5.base64('The quick brown fox jumps over the lazy dog');
           */
          var createOutputMethod = function createOutputMethod(outputType) {
            return function (message) {
              return new Md5(true).update(message)[outputType]();
            };
          };

          /**
           * @method create
           * @memberof md5
           * @description Create Md5 object
           * @returns {Md5} Md5 object.
           * @example
           * var hash = md5.create();
           */
          /**
           * @method update
           * @memberof md5
           * @description Create and update Md5 object
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {Md5} Md5 object.
           * @example
           * var hash = md5.update('The quick brown fox jumps over the lazy dog');
           * // equal to
           * var hash = md5.create();
           * hash.update('The quick brown fox jumps over the lazy dog');
           */
          var createMethod = function createMethod() {
            var method = createOutputMethod('hex');
            if (NODE_JS) {
              method = nodeWrap(method);
            }
            method.create = function () {
              return new Md5();
            };
            method.update = function (message) {
              return method.create().update(message);
            };
            for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
              var type = OUTPUT_TYPES[i];
              method[type] = createOutputMethod(type);
            }
            return method;
          };
          var nodeWrap = function nodeWrap(method) {
            var crypto = eval("require('crypto')");
            var Buffer = eval("require('buffer').Buffer");
            var nodeMethod = function nodeMethod(message) {
              if (typeof message === 'string') {
                return crypto.createHash('md5').update(message, 'utf8').digest('hex');
              } else {
                if (message === null || message === undefined) {
                  throw ERROR;
                } else if (message.constructor === ArrayBuffer) {
                  message = new Uint8Array(message);
                }
              }
              if (Array.isArray(message) || ArrayBuffer.isView(message) || message.constructor === Buffer) {
                return crypto.createHash('md5').update(new Buffer(message)).digest('hex');
              } else {
                return method(message);
              }
            };
            return nodeMethod;
          };

          /**
           * Md5 class
           * @class Md5
           * @description This is internal class.
           * @see {@link md5.create}
           */
          function Md5(sharedMemory) {
            if (sharedMemory) {
              blocks[0] = blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
              this.blocks = blocks;
              this.buffer8 = buffer8;
            } else {
              if (ARRAY_BUFFER) {
                var buffer = new ArrayBuffer(68);
                this.buffer8 = new Uint8Array(buffer);
                this.blocks = new Uint32Array(buffer);
              } else {
                this.blocks = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0];
              }
            }
            this.h0 = this.h1 = this.h2 = this.h3 = this.start = this.bytes = this.hBytes = 0;
            this.finalized = this.hashed = false;
            this.first = true;
          }

          /**
           * @method update
           * @memberof Md5
           * @instance
           * @description Update hash
           * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
           * @returns {Md5} Md5 object.
           * @see {@link md5.update}
           */
          Md5.prototype.update = function (message) {
            if (this.finalized) {
              return;
            }
            var notString,
              type = typeof message;
            if (type !== 'string') {
              if (type === 'object') {
                if (message === null) {
                  throw ERROR;
                } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
                  message = new Uint8Array(message);
                } else if (!Array.isArray(message)) {
                  if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
                    throw ERROR;
                  }
                }
              } else {
                throw ERROR;
              }
              notString = true;
            }
            var code,
              index = 0,
              i,
              length = message.length,
              blocks = this.blocks;
            var buffer8 = this.buffer8;
            while (index < length) {
              if (this.hashed) {
                this.hashed = false;
                blocks[0] = blocks[16];
                blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
              }
              if (notString) {
                if (ARRAY_BUFFER) {
                  for (i = this.start; index < length && i < 64; ++index) {
                    buffer8[i++] = message[index];
                  }
                } else {
                  for (i = this.start; index < length && i < 64; ++index) {
                    blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
                  }
                }
              } else {
                if (ARRAY_BUFFER) {
                  for (i = this.start; index < length && i < 64; ++index) {
                    code = message.charCodeAt(index);
                    if (code < 0x80) {
                      buffer8[i++] = code;
                    } else if (code < 0x800) {
                      buffer8[i++] = 0xc0 | code >> 6;
                      buffer8[i++] = 0x80 | code & 0x3f;
                    } else if (code < 0xd800 || code >= 0xe000) {
                      buffer8[i++] = 0xe0 | code >> 12;
                      buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                      buffer8[i++] = 0x80 | code & 0x3f;
                    } else {
                      code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                      buffer8[i++] = 0xf0 | code >> 18;
                      buffer8[i++] = 0x80 | code >> 12 & 0x3f;
                      buffer8[i++] = 0x80 | code >> 6 & 0x3f;
                      buffer8[i++] = 0x80 | code & 0x3f;
                    }
                  }
                } else {
                  for (i = this.start; index < length && i < 64; ++index) {
                    code = message.charCodeAt(index);
                    if (code < 0x80) {
                      blocks[i >> 2] |= code << SHIFT[i++ & 3];
                    } else if (code < 0x800) {
                      blocks[i >> 2] |= (0xc0 | code >> 6) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else if (code < 0xd800 || code >= 0xe000) {
                      blocks[i >> 2] |= (0xe0 | code >> 12) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    } else {
                      code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
                      blocks[i >> 2] |= (0xf0 | code >> 18) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code >> 12 & 0x3f) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code >> 6 & 0x3f) << SHIFT[i++ & 3];
                      blocks[i >> 2] |= (0x80 | code & 0x3f) << SHIFT[i++ & 3];
                    }
                  }
                }
              }
              this.lastByteIndex = i;
              this.bytes += i - this.start;
              if (i >= 64) {
                this.start = i - 64;
                this.hash();
                this.hashed = true;
              } else {
                this.start = i;
              }
            }
            if (this.bytes > 4294967295) {
              this.hBytes += this.bytes / 4294967296 << 0;
              this.bytes = this.bytes % 4294967296;
            }
            return this;
          };
          Md5.prototype.finalize = function () {
            if (this.finalized) {
              return;
            }
            this.finalized = true;
            var blocks = this.blocks,
              i = this.lastByteIndex;
            blocks[i >> 2] |= EXTRA[i & 3];
            if (i >= 56) {
              if (!this.hashed) {
                this.hash();
              }
              blocks[0] = blocks[16];
              blocks[16] = blocks[1] = blocks[2] = blocks[3] = blocks[4] = blocks[5] = blocks[6] = blocks[7] = blocks[8] = blocks[9] = blocks[10] = blocks[11] = blocks[12] = blocks[13] = blocks[14] = blocks[15] = 0;
            }
            blocks[14] = this.bytes << 3;
            blocks[15] = this.hBytes << 3 | this.bytes >>> 29;
            this.hash();
          };
          Md5.prototype.hash = function () {
            var a,
              b,
              c,
              d,
              bc,
              da,
              blocks = this.blocks;
            if (this.first) {
              a = blocks[0] - 680876937;
              a = (a << 7 | a >>> 25) - 271733879 << 0;
              d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
              d = (d << 12 | d >>> 20) + a << 0;
              c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
              c = (c << 17 | c >>> 15) + d << 0;
              b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
              b = (b << 22 | b >>> 10) + c << 0;
            } else {
              a = this.h0;
              b = this.h1;
              c = this.h2;
              d = this.h3;
              a += (d ^ b & (c ^ d)) + blocks[0] - 680876936;
              a = (a << 7 | a >>> 25) + b << 0;
              d += (c ^ a & (b ^ c)) + blocks[1] - 389564586;
              d = (d << 12 | d >>> 20) + a << 0;
              c += (b ^ d & (a ^ b)) + blocks[2] + 606105819;
              c = (c << 17 | c >>> 15) + d << 0;
              b += (a ^ c & (d ^ a)) + blocks[3] - 1044525330;
              b = (b << 22 | b >>> 10) + c << 0;
            }
            a += (d ^ b & (c ^ d)) + blocks[4] - 176418897;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ a & (b ^ c)) + blocks[5] + 1200080426;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ d & (a ^ b)) + blocks[6] - 1473231341;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ c & (d ^ a)) + blocks[7] - 45705983;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ b & (c ^ d)) + blocks[8] + 1770035416;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ a & (b ^ c)) + blocks[9] - 1958414417;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ d & (a ^ b)) + blocks[10] - 42063;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ c & (d ^ a)) + blocks[11] - 1990404162;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (d ^ b & (c ^ d)) + blocks[12] + 1804603682;
            a = (a << 7 | a >>> 25) + b << 0;
            d += (c ^ a & (b ^ c)) + blocks[13] - 40341101;
            d = (d << 12 | d >>> 20) + a << 0;
            c += (b ^ d & (a ^ b)) + blocks[14] - 1502002290;
            c = (c << 17 | c >>> 15) + d << 0;
            b += (a ^ c & (d ^ a)) + blocks[15] + 1236535329;
            b = (b << 22 | b >>> 10) + c << 0;
            a += (c ^ d & (b ^ c)) + blocks[1] - 165796510;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ c & (a ^ b)) + blocks[6] - 1069501632;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ b & (d ^ a)) + blocks[11] + 643717713;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ a & (c ^ d)) + blocks[0] - 373897302;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ d & (b ^ c)) + blocks[5] - 701558691;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ c & (a ^ b)) + blocks[10] + 38016083;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ b & (d ^ a)) + blocks[15] - 660478335;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ a & (c ^ d)) + blocks[4] - 405537848;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ d & (b ^ c)) + blocks[9] + 568446438;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ c & (a ^ b)) + blocks[14] - 1019803690;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ b & (d ^ a)) + blocks[3] - 187363961;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ a & (c ^ d)) + blocks[8] + 1163531501;
            b = (b << 20 | b >>> 12) + c << 0;
            a += (c ^ d & (b ^ c)) + blocks[13] - 1444681467;
            a = (a << 5 | a >>> 27) + b << 0;
            d += (b ^ c & (a ^ b)) + blocks[2] - 51403784;
            d = (d << 9 | d >>> 23) + a << 0;
            c += (a ^ b & (d ^ a)) + blocks[7] + 1735328473;
            c = (c << 14 | c >>> 18) + d << 0;
            b += (d ^ a & (c ^ d)) + blocks[12] - 1926607734;
            b = (b << 20 | b >>> 12) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[5] - 378558;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[8] - 2022574463;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[11] + 1839030562;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[14] - 35309556;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[1] - 1530992060;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[4] + 1272893353;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[7] - 155497632;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[10] - 1094730640;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[13] + 681279174;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[0] - 358537222;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[3] - 722521979;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[6] + 76029189;
            b = (b << 23 | b >>> 9) + c << 0;
            bc = b ^ c;
            a += (bc ^ d) + blocks[9] - 640364487;
            a = (a << 4 | a >>> 28) + b << 0;
            d += (bc ^ a) + blocks[12] - 421815835;
            d = (d << 11 | d >>> 21) + a << 0;
            da = d ^ a;
            c += (da ^ b) + blocks[15] + 530742520;
            c = (c << 16 | c >>> 16) + d << 0;
            b += (da ^ c) + blocks[2] - 995338651;
            b = (b << 23 | b >>> 9) + c << 0;
            a += (c ^ (b | ~d)) + blocks[0] - 198630844;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[7] + 1126891415;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[14] - 1416354905;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[5] - 57434055;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[12] + 1700485571;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[3] - 1894986606;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[10] - 1051523;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[1] - 2054922799;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[8] + 1873313359;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[15] - 30611744;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[6] - 1560198380;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[13] + 1309151649;
            b = (b << 21 | b >>> 11) + c << 0;
            a += (c ^ (b | ~d)) + blocks[4] - 145523070;
            a = (a << 6 | a >>> 26) + b << 0;
            d += (b ^ (a | ~c)) + blocks[11] - 1120210379;
            d = (d << 10 | d >>> 22) + a << 0;
            c += (a ^ (d | ~b)) + blocks[2] + 718787259;
            c = (c << 15 | c >>> 17) + d << 0;
            b += (d ^ (c | ~a)) + blocks[9] - 343485551;
            b = (b << 21 | b >>> 11) + c << 0;
            if (this.first) {
              this.h0 = a + 1732584193 << 0;
              this.h1 = b - 271733879 << 0;
              this.h2 = c - 1732584194 << 0;
              this.h3 = d + 271733878 << 0;
              this.first = false;
            } else {
              this.h0 = this.h0 + a << 0;
              this.h1 = this.h1 + b << 0;
              this.h2 = this.h2 + c << 0;
              this.h3 = this.h3 + d << 0;
            }
          };

          /**
           * @method hex
           * @memberof Md5
           * @instance
           * @description Output hash as hex string
           * @returns {String} Hex string
           * @see {@link md5.hex}
           * @example
           * hash.hex();
           */
          Md5.prototype.hex = function () {
            this.finalize();
            var h0 = this.h0,
              h1 = this.h1,
              h2 = this.h2,
              h3 = this.h3;
            return HEX_CHARS[h0 >> 4 & 0x0F] + HEX_CHARS[h0 & 0x0F] + HEX_CHARS[h0 >> 12 & 0x0F] + HEX_CHARS[h0 >> 8 & 0x0F] + HEX_CHARS[h0 >> 20 & 0x0F] + HEX_CHARS[h0 >> 16 & 0x0F] + HEX_CHARS[h0 >> 28 & 0x0F] + HEX_CHARS[h0 >> 24 & 0x0F] + HEX_CHARS[h1 >> 4 & 0x0F] + HEX_CHARS[h1 & 0x0F] + HEX_CHARS[h1 >> 12 & 0x0F] + HEX_CHARS[h1 >> 8 & 0x0F] + HEX_CHARS[h1 >> 20 & 0x0F] + HEX_CHARS[h1 >> 16 & 0x0F] + HEX_CHARS[h1 >> 28 & 0x0F] + HEX_CHARS[h1 >> 24 & 0x0F] + HEX_CHARS[h2 >> 4 & 0x0F] + HEX_CHARS[h2 & 0x0F] + HEX_CHARS[h2 >> 12 & 0x0F] + HEX_CHARS[h2 >> 8 & 0x0F] + HEX_CHARS[h2 >> 20 & 0x0F] + HEX_CHARS[h2 >> 16 & 0x0F] + HEX_CHARS[h2 >> 28 & 0x0F] + HEX_CHARS[h2 >> 24 & 0x0F] + HEX_CHARS[h3 >> 4 & 0x0F] + HEX_CHARS[h3 & 0x0F] + HEX_CHARS[h3 >> 12 & 0x0F] + HEX_CHARS[h3 >> 8 & 0x0F] + HEX_CHARS[h3 >> 20 & 0x0F] + HEX_CHARS[h3 >> 16 & 0x0F] + HEX_CHARS[h3 >> 28 & 0x0F] + HEX_CHARS[h3 >> 24 & 0x0F];
          };

          /**
           * @method toString
           * @memberof Md5
           * @instance
           * @description Output hash as hex string
           * @returns {String} Hex string
           * @see {@link md5.hex}
           * @example
           * hash.toString();
           */
          Md5.prototype.toString = Md5.prototype.hex;

          /**
           * @method digest
           * @memberof Md5
           * @instance
           * @description Output hash as bytes array
           * @returns {Array} Bytes array
           * @see {@link md5.digest}
           * @example
           * hash.digest();
           */
          Md5.prototype.digest = function () {
            this.finalize();
            var h0 = this.h0,
              h1 = this.h1,
              h2 = this.h2,
              h3 = this.h3;
            return [h0 & 0xFF, h0 >> 8 & 0xFF, h0 >> 16 & 0xFF, h0 >> 24 & 0xFF, h1 & 0xFF, h1 >> 8 & 0xFF, h1 >> 16 & 0xFF, h1 >> 24 & 0xFF, h2 & 0xFF, h2 >> 8 & 0xFF, h2 >> 16 & 0xFF, h2 >> 24 & 0xFF, h3 & 0xFF, h3 >> 8 & 0xFF, h3 >> 16 & 0xFF, h3 >> 24 & 0xFF];
          };

          /**
           * @method array
           * @memberof Md5
           * @instance
           * @description Output hash as bytes array
           * @returns {Array} Bytes array
           * @see {@link md5.array}
           * @example
           * hash.array();
           */
          Md5.prototype.array = Md5.prototype.digest;

          /**
           * @method arrayBuffer
           * @memberof Md5
           * @instance
           * @description Output hash as ArrayBuffer
           * @returns {ArrayBuffer} ArrayBuffer
           * @see {@link md5.arrayBuffer}
           * @example
           * hash.arrayBuffer();
           */
          Md5.prototype.arrayBuffer = function () {
            this.finalize();
            var buffer = new ArrayBuffer(16);
            var blocks = new Uint32Array(buffer);
            blocks[0] = this.h0;
            blocks[1] = this.h1;
            blocks[2] = this.h2;
            blocks[3] = this.h3;
            return buffer;
          };

          /**
           * @method buffer
           * @deprecated This maybe confuse with Buffer in node.js. Please use arrayBuffer instead.
           * @memberof Md5
           * @instance
           * @description Output hash as ArrayBuffer
           * @returns {ArrayBuffer} ArrayBuffer
           * @see {@link md5.buffer}
           * @example
           * hash.buffer();
           */
          Md5.prototype.buffer = Md5.prototype.arrayBuffer;

          /**
           * @method base64
           * @memberof Md5
           * @instance
           * @description Output hash as base64 string
           * @returns {String} base64 string
           * @see {@link md5.base64}
           * @example
           * hash.base64();
           */
          Md5.prototype.base64 = function () {
            var v1,
              v2,
              v3,
              base64Str = '',
              bytes = this.array();
            for (var i = 0; i < 15;) {
              v1 = bytes[i++];
              v2 = bytes[i++];
              v3 = bytes[i++];
              base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[(v1 << 4 | v2 >>> 4) & 63] + BASE64_ENCODE_CHAR[(v2 << 2 | v3 >>> 6) & 63] + BASE64_ENCODE_CHAR[v3 & 63];
            }
            v1 = bytes[i];
            base64Str += BASE64_ENCODE_CHAR[v1 >>> 2] + BASE64_ENCODE_CHAR[v1 << 4 & 63] + '==';
            return base64Str;
          };
          var exports = createMethod();
          if (COMMON_JS) {
            module.exports = exports;
          } else {
            /**
             * @method md5
             * @description Md5 hash function, export to global in browsers.
             * @param {String|Array|Uint8Array|ArrayBuffer} message message to hash
             * @returns {String} md5 hashes
             * @example
             * md5(''); // d41d8cd98f00b204e9800998ecf8427e
             * md5('The quick brown fox jumps over the lazy dog'); // 9e107d9d372bb6826bd81d3542a419d6
             * md5('The quick brown fox jumps over the lazy dog.'); // e4d909c290d0fb1ca068ffaddf22cbd0
             *
             * // It also supports UTF-8 encoding
             * md5('中文'); // a7bac2239fcdcb3a067903d8077c4a07
             *
             * // It also supports byte `Array`, `Uint8Array`, `ArrayBuffer`
             * md5([]); // d41d8cd98f00b204e9800998ecf8427e
             * md5(new Uint8Array([])); // d41d8cd98f00b204e9800998ecf8427e
             */
            root.md5 = exports;
            if (AMD) {
              !(__WEBPACK_AMD_DEFINE_RESULT__ = function () {
                return exports;
              }.call(exports, __nested_webpack_require_119215__, exports, module), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
            }
          }
        })();

        /* WEBPACK VAR INJECTION */
      }).call(this, __nested_webpack_require_119215__( /*! ./../../process/browser.js */"./node_modules/process/browser.js"), __nested_webpack_require_119215__( /*! ./../../webpack/buildin/global.js */"./node_modules/webpack/buildin/global.js"));

      /***/
    }),
    /***/"./node_modules/microee/index.js": (
    /*!***************************************!*\
      !*** ./node_modules/microee/index.js ***!
      \***************************************/
    /*! no static exports found */
    /***/
    function _node_modules_microee_indexJs(module, exports) {
      function M() {
        this._events = {};
      }
      M.prototype = {
        on: function on(ev, cb) {
          this._events || (this._events = {});
          var e = this._events;
          (e[ev] || (e[ev] = [])).push(cb);
          return this;
        },
        removeListener: function removeListener(ev, cb) {
          var e = this._events[ev] || [],
            i;
          for (i = e.length - 1; i >= 0 && e[i]; i--) {
            if (e[i] === cb || e[i].cb === cb) {
              e.splice(i, 1);
            }
          }
        },
        removeAllListeners: function removeAllListeners(ev) {
          if (!ev) {
            this._events = {};
          } else {
            this._events[ev] && (this._events[ev] = []);
          }
        },
        listeners: function listeners(ev) {
          return this._events ? this._events[ev] || [] : [];
        },
        emit: function emit(ev) {
          this._events || (this._events = {});
          var args = Array.prototype.slice.call(arguments, 1),
            i,
            e = this._events[ev] || [];
          for (i = e.length - 1; i >= 0 && e[i]; i--) {
            e[i].apply(this, args);
          }
          return this;
        },
        when: function when(ev, cb) {
          return this.once(ev, cb, true);
        },
        once: function once(ev, cb, when) {
          if (!cb) return this;
          function c() {
            if (!when) this.removeListener(ev, c);
            if (cb.apply(this, arguments) && when) this.removeListener(ev, c);
          }
          c.cb = cb;
          this.on(ev, c);
          return this;
        }
      };
      M.mixin = function (dest) {
        var o = M.prototype,
          k;
        for (k in o) {
          o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
        }
      };
      module.exports = M;

      /***/
    }),
    /***/"./node_modules/minilog/lib/common/filter.js": (
    /*!***************************************************!*\
      !*** ./node_modules/minilog/lib/common/filter.js ***!
      \***************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_common_filterJs(module, exports, __nested_webpack_require_150785__) {
      // default filter
      var Transform = __nested_webpack_require_150785__( /*! ./transform.js */"./node_modules/minilog/lib/common/transform.js");
      var levelMap = {
        debug: 1,
        info: 2,
        warn: 3,
        error: 4
      };
      function Filter() {
        this.enabled = true;
        this.defaultResult = true;
        this.clear();
      }
      Transform.mixin(Filter);

      // allow all matching, with level >= given level
      Filter.prototype.allow = function (name, level) {
        this._white.push({
          n: name,
          l: levelMap[level]
        });
        return this;
      };

      // deny all matching, with level <= given level
      Filter.prototype.deny = function (name, level) {
        this._black.push({
          n: name,
          l: levelMap[level]
        });
        return this;
      };
      Filter.prototype.clear = function () {
        this._white = [];
        this._black = [];
        return this;
      };
      function test(rule, name) {
        // use .test for RegExps
        return rule.n.test ? rule.n.test(name) : rule.n == name;
      }
      ;
      Filter.prototype.test = function (name, level) {
        var i,
          len = Math.max(this._white.length, this._black.length);
        for (i = 0; i < len; i++) {
          if (this._white[i] && test(this._white[i], name) && levelMap[level] >= this._white[i].l) {
            return true;
          }
          if (this._black[i] && test(this._black[i], name) && levelMap[level] <= this._black[i].l) {
            return false;
          }
        }
        return this.defaultResult;
      };
      Filter.prototype.write = function (name, level, args) {
        if (!this.enabled || this.test(name, level)) {
          return this.emit('item', name, level, args);
        }
      };
      module.exports = Filter;

      /***/
    }),
    /***/"./node_modules/minilog/lib/common/minilog.js": (
    /*!****************************************************!*\
      !*** ./node_modules/minilog/lib/common/minilog.js ***!
      \****************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_common_minilogJs(module, exports, __nested_webpack_require_153038__) {
      var Transform = __nested_webpack_require_153038__( /*! ./transform.js */"./node_modules/minilog/lib/common/transform.js"),
        Filter = __nested_webpack_require_153038__( /*! ./filter.js */"./node_modules/minilog/lib/common/filter.js");
      var log = new Transform(),
        slice = Array.prototype.slice;
      exports = module.exports = function create(name) {
        var _o = function o() {
          log.write(name, undefined, slice.call(arguments));
          return _o;
        };
        _o.debug = function () {
          log.write(name, 'debug', slice.call(arguments));
          return _o;
        };
        _o.info = function () {
          log.write(name, 'info', slice.call(arguments));
          return _o;
        };
        _o.warn = function () {
          log.write(name, 'warn', slice.call(arguments));
          return _o;
        };
        _o.error = function () {
          log.write(name, 'error', slice.call(arguments));
          return _o;
        };
        _o.log = _o.debug; // for interface compliance with Node and browser consoles
        _o.suggest = exports.suggest;
        _o.format = log.format;
        return _o;
      };

      // filled in separately
      exports.defaultBackend = exports.defaultFormatter = null;
      exports.pipe = function (dest) {
        return log.pipe(dest);
      };
      exports.end = exports.unpipe = exports.disable = function (from) {
        return log.unpipe(from);
      };
      exports.Transform = Transform;
      exports.Filter = Filter;
      // this is the default filter that's applied when .enable() is called normally
      // you can bypass it completely and set up your own pipes
      exports.suggest = new Filter();
      exports.enable = function () {
        if (exports.defaultFormatter) {
          return log.pipe(exports.suggest) // filter
          .pipe(exports.defaultFormatter) // formatter
          .pipe(exports.defaultBackend); // backend
        }
        return log.pipe(exports.suggest) // filter
        .pipe(exports.defaultBackend); // formatter
      };

      /***/
    }),
    /***/"./node_modules/minilog/lib/common/transform.js": (
    /*!******************************************************!*\
      !*** ./node_modules/minilog/lib/common/transform.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_common_transformJs(module, exports, __nested_webpack_require_155506__) {
      var microee = __nested_webpack_require_155506__( /*! microee */"./node_modules/microee/index.js");

      // Implements a subset of Node's stream.Transform - in a cross-platform manner.
      function Transform() {}
      microee.mixin(Transform);

      // The write() signature is different from Node's
      // --> makes it much easier to work with objects in logs.
      // One of the lessons from v1 was that it's better to target
      // a good browser rather than the lowest common denominator
      // internally.
      // If you want to use external streams, pipe() to ./stringify.js first.
      Transform.prototype.write = function (name, level, args) {
        this.emit('item', name, level, args);
      };
      Transform.prototype.end = function () {
        this.emit('end');
        this.removeAllListeners();
      };
      Transform.prototype.pipe = function (dest) {
        var s = this;
        // prevent double piping
        s.emit('unpipe', dest);
        // tell the dest that it's being piped to
        dest.emit('pipe', s);
        function onItem() {
          dest.write.apply(dest, Array.prototype.slice.call(arguments));
        }
        function onEnd() {
          !dest._isStdio && dest.end();
        }
        s.on('item', onItem);
        s.on('end', onEnd);
        s.when('unpipe', function (from) {
          var match = from === dest || typeof from == 'undefined';
          if (match) {
            s.removeListener('item', onItem);
            s.removeListener('end', onEnd);
            dest.emit('unpipe');
          }
          return match;
        });
        return dest;
      };
      Transform.prototype.unpipe = function (from) {
        this.emit('unpipe', from);
        return this;
      };
      Transform.prototype.format = function (dest) {
        throw new Error(['Warning: .format() is deprecated in Minilog v2! Use .pipe() instead. For example:', 'var Minilog = require(\'minilog\');', 'Minilog', '  .pipe(Minilog.backends.console.formatClean)', '  .pipe(Minilog.backends.console);'].join('\n'));
      };
      Transform.mixin = function (dest) {
        var o = Transform.prototype,
          k;
        for (k in o) {
          o.hasOwnProperty(k) && (dest.prototype[k] = o[k]);
        }
      };
      module.exports = Transform;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/array.js": (
    /*!***********************************************!*\
      !*** ./node_modules/minilog/lib/web/array.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_arrayJs(module, exports, __nested_webpack_require_158183__) {
      var Transform = __nested_webpack_require_158183__( /*! ../common/transform.js */"./node_modules/minilog/lib/common/transform.js"),
        cache = [];
      var logger = new Transform();
      logger.write = function (name, level, args) {
        cache.push([name, level, args]);
      };

      // utility functions
      logger.get = function () {
        return cache;
      };
      logger.empty = function () {
        cache = [];
      };
      module.exports = logger;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/console.js": (
    /*!*************************************************!*\
      !*** ./node_modules/minilog/lib/web/console.js ***!
      \*************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_consoleJs(module, exports, __nested_webpack_require_159042__) {
      var Transform = __nested_webpack_require_159042__( /*! ../common/transform.js */"./node_modules/minilog/lib/common/transform.js");
      var newlines = /\n+$/,
        logger = new Transform();
      logger.write = function (name, level, args) {
        var i = args.length - 1;
        if (typeof console === 'undefined' || !console.log) {
          return;
        }
        if (console.log.apply) {
          return console.log.apply(console, [name, level].concat(args));
        } else if (JSON && JSON.stringify) {
          // console.log.apply is undefined in IE8 and IE9
          // for IE8/9: make console.log at least a bit less awful
          if (args[i] && typeof args[i] == 'string') {
            args[i] = args[i].replace(newlines, '');
          }
          try {
            for (i = 0; i < args.length; i++) {
              args[i] = JSON.stringify(args[i]);
            }
          } catch (e) {}
          console.log(args.join(' '));
        }
      };
      logger.formatters = ['color', 'minilog'];
      logger.color = __nested_webpack_require_159042__( /*! ./formatters/color.js */"./node_modules/minilog/lib/web/formatters/color.js");
      logger.minilog = __nested_webpack_require_159042__( /*! ./formatters/minilog.js */"./node_modules/minilog/lib/web/formatters/minilog.js");
      module.exports = logger;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/formatters/color.js": (
    /*!**********************************************************!*\
      !*** ./node_modules/minilog/lib/web/formatters/color.js ***!
      \**********************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_formatters_colorJs(module, exports, __nested_webpack_require_160781__) {
      var Transform = __nested_webpack_require_160781__( /*! ../../common/transform.js */"./node_modules/minilog/lib/common/transform.js"),
        color = __nested_webpack_require_160781__( /*! ./util.js */"./node_modules/minilog/lib/web/formatters/util.js");
      var colors = {
          debug: ['cyan'],
          info: ['purple'],
          warn: ['yellow', true],
          error: ['red', true]
        },
        logger = new Transform();
      logger.write = function (name, level, args) {
        var fn = console.log;
        if (console[level] && console[level].apply) {
          fn = console[level];
          fn.apply(console, ['%c' + name + ' %c' + level, color('gray'), color.apply(color, colors[level])].concat(args));
        }
      };

      // NOP, because piping the formatted logs can only cause trouble.
      logger.pipe = function () {};
      module.exports = logger;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/formatters/minilog.js": (
    /*!************************************************************!*\
      !*** ./node_modules/minilog/lib/web/formatters/minilog.js ***!
      \************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_formatters_minilogJs(module, exports, __nested_webpack_require_162095__) {
      var Transform = __nested_webpack_require_162095__( /*! ../../common/transform.js */"./node_modules/minilog/lib/common/transform.js"),
        color = __nested_webpack_require_162095__( /*! ./util.js */"./node_modules/minilog/lib/web/formatters/util.js"),
        colors = {
          debug: ['gray'],
          info: ['purple'],
          warn: ['yellow', true],
          error: ['red', true]
        },
        logger = new Transform();
      logger.write = function (name, level, args) {
        var fn = console.log;
        if (level != 'debug' && console[level]) {
          fn = console[level];
        }
        var subset = [],
          i = 0;
        if (level != 'info') {
          for (; i < args.length; i++) {
            if (typeof args[i] != 'string') break;
          }
          fn.apply(console, ['%c' + name + ' ' + args.slice(0, i).join(' '), color.apply(color, colors[level])].concat(args.slice(i)));
        } else {
          fn.apply(console, ['%c' + name, color.apply(color, colors[level])].concat(args));
        }
      };

      // NOP, because piping the formatted logs can only cause trouble.
      logger.pipe = function () {};
      module.exports = logger;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/formatters/util.js": (
    /*!*********************************************************!*\
      !*** ./node_modules/minilog/lib/web/formatters/util.js ***!
      \*********************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_formatters_utilJs(module, exports) {
      var hex = {
        black: '#000',
        red: '#c23621',
        green: '#25bc26',
        yellow: '#bbbb00',
        blue: '#492ee1',
        magenta: '#d338d3',
        cyan: '#33bbc8',
        gray: '#808080',
        purple: '#708'
      };
      function color(fg, isInverse) {
        if (isInverse) {
          return 'color: #fff; background: ' + hex[fg] + ';';
        } else {
          return 'color: ' + hex[fg] + ';';
        }
      }
      module.exports = color;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/index.js": (
    /*!***********************************************!*\
      !*** ./node_modules/minilog/lib/web/index.js ***!
      \***********************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_indexJs(module, exports, __nested_webpack_require_164544__) {
      var Minilog = __nested_webpack_require_164544__( /*! ../common/minilog.js */"./node_modules/minilog/lib/common/minilog.js");
      var oldEnable = Minilog.enable,
        oldDisable = Minilog.disable,
        isChrome = typeof navigator != 'undefined' && /chrome/i.test(navigator.userAgent),
        console = __nested_webpack_require_164544__( /*! ./console.js */"./node_modules/minilog/lib/web/console.js");

      // Use a more capable logging backend if on Chrome
      Minilog.defaultBackend = isChrome ? console.minilog : console;

      // apply enable inputs from localStorage and from the URL
      if (typeof window != 'undefined') {
        try {
          Minilog.enable(JSON.parse(window.localStorage['minilogSettings']));
        } catch (e) {}
        if (window.location && window.location.search) {
          var match = RegExp('[?&]minilog=([^&]*)').exec(window.location.search);
          match && Minilog.enable(decodeURIComponent(match[1]));
        }
      }

      // Make enable also add to localStorage
      Minilog.enable = function () {
        oldEnable.call(Minilog, true);
        try {
          window.localStorage['minilogSettings'] = JSON.stringify(true);
        } catch (e) {}
        return this;
      };
      Minilog.disable = function () {
        oldDisable.call(Minilog);
        try {
          delete window.localStorage.minilogSettings;
        } catch (e) {}
        return this;
      };
      exports = module.exports = Minilog;
      exports.backends = {
        array: __nested_webpack_require_164544__( /*! ./array.js */"./node_modules/minilog/lib/web/array.js"),
        browser: Minilog.defaultBackend,
        localStorage: __nested_webpack_require_164544__( /*! ./localstorage.js */"./node_modules/minilog/lib/web/localstorage.js"),
        jQuery: __nested_webpack_require_164544__( /*! ./jquery_simple.js */"./node_modules/minilog/lib/web/jquery_simple.js")
      };

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/jquery_simple.js": (
    /*!*******************************************************!*\
      !*** ./node_modules/minilog/lib/web/jquery_simple.js ***!
      \*******************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_jquery_simpleJs(module, exports, __nested_webpack_require_166827__) {
      var Transform = __nested_webpack_require_166827__( /*! ../common/transform.js */"./node_modules/minilog/lib/common/transform.js");
      var cid = new Date().valueOf().toString(36);
      function AjaxLogger(options) {
        this.url = options.url || '';
        this.cache = [];
        this.timer = null;
        this.interval = options.interval || 30 * 1000;
        this.enabled = true;
        this.jQuery = window.jQuery;
        this.extras = {};
      }
      Transform.mixin(AjaxLogger);
      AjaxLogger.prototype.write = function (name, level, args) {
        if (!this.timer) {
          this.init();
        }
        this.cache.push([name, level].concat(args));
      };
      AjaxLogger.prototype.init = function () {
        if (!this.enabled || !this.jQuery) return;
        var self = this;
        this.timer = setTimeout(function () {
          var i,
            logs = [],
            ajaxData,
            url = self.url;
          if (self.cache.length == 0) return self.init();
          // Test each log line and only log the ones that are valid (e.g. don't have circular references).
          // Slight performance hit but benefit is we log all valid lines.
          for (i = 0; i < self.cache.length; i++) {
            try {
              JSON.stringify(self.cache[i]);
              logs.push(self.cache[i]);
            } catch (e) {}
          }
          if (self.jQuery.isEmptyObject(self.extras)) {
            ajaxData = JSON.stringify({
              logs: logs
            });
            url = self.url + '?client_id=' + cid;
          } else {
            ajaxData = JSON.stringify(self.jQuery.extend({
              logs: logs
            }, self.extras));
          }
          self.jQuery.ajax(url, {
            type: 'POST',
            cache: false,
            processData: false,
            data: ajaxData,
            contentType: 'application/json',
            timeout: 10000
          }).success(function (data, status, jqxhr) {
            if (data.interval) {
              self.interval = Math.max(1000, data.interval);
            }
          }).error(function () {
            self.interval = 30000;
          }).always(function () {
            self.init();
          });
          self.cache = [];
        }, this.interval);
      };
      AjaxLogger.prototype.end = function () {};

      // wait until jQuery is defined. Useful if you don't control the load order.
      AjaxLogger.jQueryWait = function (onDone) {
        if (typeof window !== 'undefined' && (window.jQuery || window.$)) {
          return onDone(window.jQuery || window.$);
        } else if (typeof window !== 'undefined') {
          setTimeout(function () {
            AjaxLogger.jQueryWait(onDone);
          }, 200);
        }
      };
      module.exports = AjaxLogger;

      /***/
    }),
    /***/"./node_modules/minilog/lib/web/localstorage.js": (
    /*!******************************************************!*\
      !*** ./node_modules/minilog/lib/web/localstorage.js ***!
      \******************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_minilog_lib_web_localstorageJs(module, exports, __nested_webpack_require_170047__) {
      var Transform = __nested_webpack_require_170047__( /*! ../common/transform.js */"./node_modules/minilog/lib/common/transform.js"),
        cache = false;
      var logger = new Transform();
      logger.write = function (name, level, args) {
        if (typeof window == 'undefined' || typeof JSON == 'undefined' || !JSON.stringify || !JSON.parse) return;
        try {
          if (!cache) {
            cache = window.localStorage.minilog ? JSON.parse(window.localStorage.minilog) : [];
          }
          cache.push([new Date().toString(), name, level, args]);
          window.localStorage.minilog = JSON.stringify(cache);
        } catch (e) {}
      };
      module.exports = logger;

      /***/
    }),
    /***/"./node_modules/process/browser.js": (
    /*!*****************************************!*\
      !*** ./node_modules/process/browser.js ***!
      \*****************************************/
    /*! no static exports found */
    /***/
    function _node_modules_process_browserJs(module, exports) {
      // shim for using process in browser
      var process = module.exports = {};

      // cached from whatever global is present so that test runners that stub it
      // don't break things.  But we need to wrap it in a try catch in case it is
      // wrapped in strict mode code which doesn't define any globals.  It's inside a
      // function because try/catches deoptimize in certain engines.

      var cachedSetTimeout;
      var cachedClearTimeout;
      function defaultSetTimout() {
        throw new Error('setTimeout has not been defined');
      }
      function defaultClearTimeout() {
        throw new Error('clearTimeout has not been defined');
      }
      (function () {
        try {
          if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
          } else {
            cachedSetTimeout = defaultSetTimout;
          }
        } catch (e) {
          cachedSetTimeout = defaultSetTimout;
        }
        try {
          if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
          } else {
            cachedClearTimeout = defaultClearTimeout;
          }
        } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
        }
      })();
      function runTimeout(fun) {
        if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
        }
        // if setTimeout wasn't available but was latter defined
        if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
          }
        }
      }
      function runClearTimeout(marker) {
        if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
        }
        // if clearTimeout wasn't available but was latter defined
        if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
        }
        try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
        } catch (e) {
          try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
          } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
          }
        }
      }
      var queue = [];
      var draining = false;
      var currentQueue;
      var queueIndex = -1;
      function cleanUpNextTick() {
        if (!draining || !currentQueue) {
          return;
        }
        draining = false;
        if (currentQueue.length) {
          queue = currentQueue.concat(queue);
        } else {
          queueIndex = -1;
        }
        if (queue.length) {
          drainQueue();
        }
      }
      function drainQueue() {
        if (draining) {
          return;
        }
        var timeout = runTimeout(cleanUpNextTick);
        draining = true;
        var len = queue.length;
        while (len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
            if (currentQueue) {
              currentQueue[queueIndex].run();
            }
          }
          queueIndex = -1;
          len = queue.length;
        }
        currentQueue = null;
        draining = false;
        runClearTimeout(timeout);
      }
      process.nextTick = function (fun) {
        var args = new Array(arguments.length - 1);
        if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
          }
        }
        queue.push(new Item(fun, args));
        if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
        }
      };

      // v8 likes predictible objects
      function Item(fun, array) {
        this.fun = fun;
        this.array = array;
      }
      Item.prototype.run = function () {
        this.fun.apply(null, this.array);
      };
      process.title = 'browser';
      process.browser = true;
      process.env = {};
      process.argv = [];
      process.version = ''; // empty string to avoid regexp issues
      process.versions = {};
      function noop() {}
      process.on = noop;
      process.addListener = noop;
      process.once = noop;
      process.off = noop;
      process.removeListener = noop;
      process.removeAllListeners = noop;
      process.emit = noop;
      process.prependListener = noop;
      process.prependOnceListener = noop;
      process.listeners = function (name) {
        return [];
      };
      process.binding = function (name) {
        throw new Error('process.binding is not supported');
      };
      process.cwd = function () {
        return '/';
      };
      process.chdir = function (dir) {
        throw new Error('process.chdir is not supported');
      };
      process.umask = function () {
        return 0;
      };

      /***/
    }),
    /***/"./node_modules/webpack/buildin/amd-options.js": (
    /*!****************************************!*\
      !*** (webpack)/buildin/amd-options.js ***!
      \****************************************/
    /*! no static exports found */
    /***/
    function _node_modules_webpack_buildin_amdOptionsJs(module, exports) {
      /* WEBPACK VAR INJECTION */(function (__webpack_amd_options__) {
        /* globals __webpack_amd_options__ */
        module.exports = __webpack_amd_options__;

        /* WEBPACK VAR INJECTION */
      }).call(this, {});

      /***/
    }),
    /***/"./node_modules/webpack/buildin/global.js": (
    /*!***********************************!*\
      !*** (webpack)/buildin/global.js ***!
      \***********************************/
    /*! no static exports found */
    /***/
    function _node_modules_webpack_buildin_globalJs(module, exports) {
      var g;

      // This works in non-strict mode
      g = function () {
        return this;
      }();
      try {
        // This works if eval is allowed (see CSP)
        g = g || new Function("return this")();
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
      }

      // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}

      module.exports = g;

      /***/
    }),
    /***/"./node_modules/worker-loader/dist/cjs.js?{\"inline\":true,\"fallback\":true}!./src/FetchWorkerTool.worker.js": (
    /*!****************************************************************************************************************!*\
      !*** ./node_modules/worker-loader/dist/cjs.js?{"inline":true,"fallback":true}!./src/FetchWorkerTool.worker.js ***!
      \****************************************************************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_workerLoader_dist_cjsJsInlineTrueFallbackTrue_src_FetchWorkerToolWorkerJs(module, exports, __nested_webpack_require_179315__) {
      module.exports = function () {
        return __nested_webpack_require_179315__( /*! !./node_modules/worker-loader/dist/workers/InlineWorker.js */"./node_modules/worker-loader/dist/workers/InlineWorker.js")("/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__webpack_require__.d = function(exports, name, getter) {\n/******/ \t\tif(!__webpack_require__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__webpack_require__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__webpack_require__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __webpack_require__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__webpack_require__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__webpack_require__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__webpack_require__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = \"./node_modules/babel-loader/lib/index.js?!./src/FetchWorkerTool.worker.js\");\n/******/ })\n/************************************************************************/\n/******/ ({\n\n/***/ \"./node_modules/babel-loader/lib/index.js?!./src/FetchWorkerTool.worker.js\":\n/*!*******************************************************************************!*\\\n  !*** ./node_modules/babel-loader/lib??ref--4!./src/FetchWorkerTool.worker.js ***!\n  \\*******************************************************************************/\n/*! no static exports found */\n/***/ (function(module, exports, __webpack_require__) {\n\n/* eslint-env worker */\n\nvar crossFetch = __webpack_require__(/*! cross-fetch */ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\").default;\nvar jobsActive = 0;\nvar complete = [];\nvar intervalId = null;\n\n/**\n * Register a step function.\n *\n * Step checks if there are completed jobs and if there are sends them to the\n * parent. Then it checks the jobs count. If there are no further jobs, clear\n * the step.\n */\nvar registerStep = function registerStep() {\n  intervalId = setInterval(function () {\n    if (complete.length) {\n      // Send our chunk of completed requests and instruct postMessage to\n      // transfer the buffers instead of copying them.\n      postMessage(complete.slice(),\n      // Instruct postMessage that these buffers in the sent message\n      // should use their Transferable trait. After the postMessage\n      // call the \"buffers\" will still be in complete if you looked,\n      // but they will all be length 0 as the data they reference has\n      // been sent to the window. This lets us send a lot of data\n      // without the normal postMessage behaviour of making a copy of\n      // all of the data for the window.\n      complete.map(function (response) {\n        return response.buffer;\n      }).filter(Boolean));\n      complete.length = 0;\n    }\n    if (jobsActive === 0) {\n      clearInterval(intervalId);\n      intervalId = null;\n    }\n  }, 1);\n};\n\n/**\n * Receive a job from the parent and fetch the requested data.\n * @param {object} options.job A job id, url, and options descriptor to perform.\n */\nvar onMessage = function onMessage(_ref) {\n  var job = _ref.data;\n  if (jobsActive === 0 && !intervalId) {\n    registerStep();\n  }\n  jobsActive++;\n  crossFetch(job.url, job.options).then(function (result) {\n    if (result.ok) return result.arrayBuffer();\n    if (result.status === 404) return null;\n    return Promise.reject(result.status);\n  }).then(function (buffer) {\n    return complete.push({\n      id: job.id,\n      buffer: buffer\n    });\n  }).catch(function (error) {\n    return complete.push({\n      id: job.id,\n      error: error && error.message || \"Failed request: \".concat(job.url)\n    });\n  }).then(function () {\n    return jobsActive--;\n  });\n};\n\n// crossFetch means \"fetch\" is now always supported\npostMessage({\n  support: {\n    fetch: true\n  }\n});\nself.addEventListener('message', onMessage);\n\n/***/ }),\n\n/***/ \"./node_modules/cross-fetch/dist/browser-ponyfill.js\":\n/*!***********************************************************!*\\\n  !*** ./node_modules/cross-fetch/dist/browser-ponyfill.js ***!\n  \\***********************************************************/\n/*! no static exports found */\n/***/ (function(module, exports) {\n\nvar global = typeof self !== 'undefined' ? self : this;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\nvar irrelevant = (function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n})({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers\nexports.Request = ctx.Request\nexports.Response = ctx.Response\nmodule.exports = exports\n\n\n/***/ })\n\n/******/ });\n//# sourceMappingURL=f6240eab828e6d415177.worker.js.map", __nested_webpack_require_179315__.p + "f6240eab828e6d415177.worker.js");
      };

      /***/
    }),
    /***/"./node_modules/worker-loader/dist/workers/InlineWorker.js": (
    /*!*****************************************************************!*\
      !*** ./node_modules/worker-loader/dist/workers/InlineWorker.js ***!
      \*****************************************************************/
    /*! no static exports found */
    /***/
    function _node_modules_workerLoader_dist_workers_InlineWorkerJs(module, exports, __webpack_require__) {
      "use strict";

      // http://stackoverflow.com/questions/10343913/how-to-create-a-web-worker-from-a-string
      var URL = window.URL || window.webkitURL;
      module.exports = function (content, url) {
        try {
          try {
            var blob;
            try {
              // BlobBuilder = Deprecated, but widely implemented
              var BlobBuilder = window.BlobBuilder || window.WebKitBlobBuilder || window.MozBlobBuilder || window.MSBlobBuilder;
              blob = new BlobBuilder();
              blob.append(content);
              blob = blob.getBlob();
            } catch (e) {
              // The proposed API
              blob = new Blob([content]);
            }
            return new Worker(URL.createObjectURL(blob));
          } catch (e) {
            return new Worker('data:application/javascript,' + encodeURIComponent(content));
          }
        } catch (e) {
          if (!url) {
            throw Error('Inline worker is not supported');
          }
          return new Worker(url);
        }
      };

      /***/
    }),
    /***/"./src/Asset.js": (
    /*!**********************!*\
      !*** ./src/Asset.js ***!
      \**********************/
    /*! no static exports found */
    /***/
    function _src_AssetJs(module, exports, __nested_webpack_require_204601__) {
      var _classCallCheck = __nested_webpack_require_204601__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_204601__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      // Use JS implemented TextDecoder and TextEncoder if it is not provided by the
      // browser.
      var _TextDecoder;
      var _TextEncoder;
      if (typeof TextDecoder === 'undefined' || typeof TextEncoder === 'undefined') {
        // Wait to require the text encoding polyfill until we know it's needed.
        // eslint-disable-next-line global-require
        var encoding = __nested_webpack_require_204601__( /*! fastestsmallesttextencoderdecoder */"./node_modules/fastestsmallesttextencoderdecoder/EncoderDecoderTogether.min.js");
        _TextDecoder = encoding.TextDecoder;
        _TextEncoder = encoding.TextEncoder;
      } else {
        _TextDecoder = TextDecoder;
        _TextEncoder = TextEncoder;
      }
      var md5 = __nested_webpack_require_204601__( /*! js-md5 */"./node_modules/js-md5/src/md5.js");
      var memoizedToString = function () {
        /**
         * The maximum length of a chunk before encoding it into base64.
         *
         * 32766 is a multiple of 3 so btoa does not need to use padding characters
         * except for the final chunk where that is fine. 32766 is also close to
         * 32768 so it is close to a size an memory allocator would prefer.
         * @const {number}
         */
        var BTOA_CHUNK_MAX_LENGTH = 32766;

        /**
         * An array cache of bytes to characters.
         * @const {?Array.<string>}
         */
        var fromCharCode = null;
        var strings = {};
        return function (assetId, data) {
          if (!Object.prototype.hasOwnProperty.call(strings, assetId)) {
            if (typeof btoa === 'undefined') {
              // Use a library that does not need btoa to run.
              /* eslint-disable-next-line global-require */
              var base64js = __nested_webpack_require_204601__( /*! base64-js */"./node_modules/base64-js/index.js");
              strings[assetId] = base64js.fromByteArray(data);
            } else {
              // Native btoa is faster than javascript translation. Use js to
              // create a "binary" string and btoa to encode it.
              if (fromCharCode === null) {
                // Cache the first 256 characters for input byte values.
                fromCharCode = new Array(256);
                for (var i = 0; i < 256; i++) {
                  fromCharCode[i] = String.fromCharCode(i);
                }
              }
              var length = data.length;
              var s = '';
              // Iterate over chunks of the binary data.
              for (var _i = 0, e = 0; _i < length; _i = e) {
                // Create small chunks to cause more small allocations and
                // less large allocations.
                e = Math.min(e + BTOA_CHUNK_MAX_LENGTH, length);
                var s_ = '';
                for (var j = _i; j < e; j += 1) {
                  s_ += fromCharCode[data[j]];
                }
                // Encode the latest chunk so the we create one big output
                // string instead of creating a big input string and then
                // one big output string.
                s += btoa(s_);
              }
              strings[assetId] = s;
            }
          }
          return strings[assetId];
        };
      }();
      var Asset = /*#__PURE__*/function () {
        "use strict";

        /**
         * Construct an Asset.
         * @param {AssetType} assetType - The type of this asset (sound, image, etc.)
         * @param {string} assetId - The ID of this asset.
         * @param {DataFormat} [dataFormat] - The format of the data (WAV, PNG, etc.); required iff `data` is present.
         * @param {Buffer} [data] - The in-memory data for this asset; optional.
         * @param {bool} [generateId] - Whether to create id from an md5 hash of data
         */
        function Asset(assetType, assetId, dataFormat, data, generateId) {
          _classCallCheck(this, Asset);
          /** @type {AssetType} */
          this.assetType = assetType;

          /** @type {string} */
          this.assetId = assetId;
          this.setData(data, dataFormat || assetType.runtimeFormat, generateId);

          /** @type {Asset[]} */
          this.dependencies = [];
        }
        return _createClass(Asset, [{
          key: "setData",
          value: function setData(data, dataFormat, generateId) {
            if (data && !dataFormat) {
              throw new Error('Data provided without specifying its format');
            }

            /** @type {DataFormat} */
            this.dataFormat = dataFormat;

            /** @type {Buffer} */
            this.data = data;
            if (generateId) this.assetId = md5(data);

            // Mark as clean only if set is being called without generateId
            // If a new id is being generated, mark this asset as not clean
            this.clean = !generateId;
          }

          /**
           * @returns {string} - This asset's data, decoded as text.
           */
        }, {
          key: "decodeText",
          value: function decodeText() {
            var decoder = new _TextDecoder();
            return decoder.decode(this.data);
          }

          /**
           * Same as `setData` but encodes text first.
           * @param {string} data - the text data to encode and store.
           * @param {DataFormat} dataFormat - the format of the data (DataFormat.SVG for example).
           * @param {bool} generateId - after setting data, set the id to an md5 of the data?
           */
        }, {
          key: "encodeTextData",
          value: function encodeTextData(data, dataFormat, generateId) {
            var encoder = new _TextEncoder();
            this.setData(encoder.encode(data), dataFormat, generateId);
          }

          /**
           * @param {string} [contentType] - Optionally override the content type to be included in the data URI.
           * @returns {string} - A data URI representing the asset's data.
           */
        }, {
          key: "encodeDataURI",
          value: function encodeDataURI(contentType) {
            contentType = contentType || this.assetType.contentType;
            return "data:".concat(contentType, ";base64,").concat(memoizedToString(this.assetId, this.data));
          }
        }]);
      }();
      module.exports = Asset;

      /***/
    }),
    /***/"./src/AssetType.js": (
    /*!**************************!*\
      !*** ./src/AssetType.js ***!
      \**************************/
    /*! no static exports found */
    /***/
    function _src_AssetTypeJs(module, exports, __nested_webpack_require_211480__) {
      var DataFormat = __nested_webpack_require_211480__( /*! ./DataFormat */"./src/DataFormat.js");

      /**
       * Enumeration of the supported asset types.
       * @type {Object.<String,AssetType>}
       * @typedef {Object} AssetType - Information about a supported asset type.
       * @property {string} contentType - the MIME type associated with this kind of data. Useful for data URIs, etc.
       * @property {string} name - The human-readable name of this asset type.
       * @property {DataFormat} runtimeFormat - The default format used for runtime, in-memory storage of this asset. For
       *     example, a project stored in SB2 format on disk will be returned as JSON when loaded into memory.
       * @property {boolean} immutable - Indicates if the asset id is determined by the asset content.
       */
      var AssetType = {
        ImageBitmap: {
          contentType: 'image/png',
          name: 'ImageBitmap',
          runtimeFormat: DataFormat.PNG,
          immutable: true
        },
        ImageVector: {
          contentType: 'image/svg+xml',
          name: 'ImageVector',
          runtimeFormat: DataFormat.SVG,
          immutable: true
        },
        Project: {
          contentType: 'application/json',
          name: 'Project',
          runtimeFormat: DataFormat.JSON,
          immutable: false
        },
        Sound: {
          contentType: 'audio/x-wav',
          name: 'Sound',
          runtimeFormat: DataFormat.WAV,
          immutable: true
        },
        Sprite: {
          contentType: 'application/json',
          name: 'Sprite',
          runtimeFormat: DataFormat.JSON,
          immutable: true
        }
      };
      module.exports = AssetType;

      /***/
    }),
    /***/"./src/BuiltinHelper.js": (
    /*!******************************!*\
      !*** ./src/BuiltinHelper.js ***!
      \******************************/
    /*! no static exports found */
    /***/
    function _src_BuiltinHelperJs(module, exports, __nested_webpack_require_213491__) {
      /* WEBPACK VAR INJECTION */(function (Buffer) {
        var _classCallCheck = __nested_webpack_require_213491__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
        var _createClass = __nested_webpack_require_213491__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
        var _possibleConstructorReturn = __nested_webpack_require_213491__( /*! @babel/runtime/helpers/possibleConstructorReturn */"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
        var _getPrototypeOf = __nested_webpack_require_213491__( /*! @babel/runtime/helpers/getPrototypeOf */"./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
        var _inherits = __nested_webpack_require_213491__( /*! @babel/runtime/helpers/inherits */"./node_modules/@babel/runtime/helpers/inherits.js");
        function _callSuper(t, o, e) {
          return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
        }
        function _isNativeReflectConstruct() {
          try {
            var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
          } catch (t) {}
          return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
            return !!t;
          })();
        }
        var md5 = __nested_webpack_require_213491__( /*! js-md5 */"./node_modules/js-md5/src/md5.js");
        var log = __nested_webpack_require_213491__( /*! ./log */"./src/log.js");
        var Asset = __nested_webpack_require_213491__( /*! ./Asset */"./src/Asset.js");
        var AssetType = __nested_webpack_require_213491__( /*! ./AssetType */"./src/AssetType.js");
        var DataFormat = __nested_webpack_require_213491__( /*! ./DataFormat */"./src/DataFormat.js");
        var Helper = __nested_webpack_require_213491__( /*! ./Helper */"./src/Helper.js");

        /**
         * @typedef {object} BuiltinAssetRecord
         * @property {AssetType} type - The type of the asset.
         * @property {DataFormat} format - The format of the asset's data.
         * @property {?string} id - The asset's unique ID.
         * @property {Buffer} data - The asset's data.
         */

        /**
         * @type {BuiltinAssetRecord[]}
         */
        var DefaultAssets = [{
          type: AssetType.ImageBitmap,
          format: DataFormat.PNG,
          id: null,
          data: Buffer.from(__nested_webpack_require_213491__( /*! ./builtins/defaultBitmap.png */"./src/builtins/defaultBitmap.png") // eslint-disable-line global-require
          )
        }, {
          type: AssetType.Sound,
          format: DataFormat.WAV,
          id: null,
          data: Buffer.from(__nested_webpack_require_213491__( /*! ./builtins/defaultSound.wav */"./src/builtins/defaultSound.wav") // eslint-disable-line global-require
          )
        }, {
          type: AssetType.ImageVector,
          format: DataFormat.SVG,
          id: null,
          data: Buffer.from(__nested_webpack_require_213491__( /*! ./builtins/defaultVector.svg */"./src/builtins/defaultVector.svg") // eslint-disable-line global-require
          )
        }];

        /**
         * @type {BuiltinAssetRecord[]}
         */
        var BuiltinAssets = DefaultAssets.concat([]);
        var BuiltinHelper = /*#__PURE__*/function (_Helper) {
          "use strict";

          function BuiltinHelper(parent) {
            var _this;
            _classCallCheck(this, BuiltinHelper);
            _this = _callSuper(this, BuiltinHelper, [parent]);

            /**
             * In-memory storage for all built-in assets.
             * @type {Object.<AssetType, AssetIdMap>} Maps asset type to a map of asset ID to actual assets.
             * @typedef {Object.<string, BuiltinAssetRecord>} AssetIdMap - Maps asset ID to asset.
             */
            _this.assets = {};
            BuiltinAssets.forEach(function (assetRecord) {
              assetRecord.id = _this._store(assetRecord.type, assetRecord.format, assetRecord.data, assetRecord.id);
            });
            return _this;
          }

          /**
           * Call `setDefaultAssetId` on the parent `ScratchStorage` instance to register all built-in default assets.
           */
          _inherits(BuiltinHelper, _Helper);
          return _createClass(BuiltinHelper, [{
            key: "registerDefaultAssets",
            value: function registerDefaultAssets() {
              var numAssets = DefaultAssets.length;
              for (var assetIndex = 0; assetIndex < numAssets; ++assetIndex) {
                var assetRecord = DefaultAssets[assetIndex];
                this.parent.setDefaultAssetId(assetRecord.type, assetRecord.id);
              }
            }

            /**
             * Synchronously fetch a cached asset for a given asset id. Returns null if not found.
             * @param {string} assetId - The id for the asset to fetch.
             * @returns {?Asset} The asset for assetId, if it exists.
             */
          }, {
            key: "get",
            value: function get(assetId) {
              var asset = null;
              if (Object.prototype.hasOwnProperty.call(this.assets, assetId)) {
                /** @type{BuiltinAssetRecord} */
                var assetRecord = this.assets[assetId];
                asset = new Asset(assetRecord.type, assetRecord.id, assetRecord.format, assetRecord.data);
              }
              return asset;
            }

            /**
             * Alias for store (old name of store)
             * @deprecated Use BuiltinHelper.store
             * @param {AssetType} assetType - The type of the asset to cache.
             * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.
             * @param {Buffer} data - The data for the cached asset.
             * @param {string} id - The id for the cached asset.
             * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.
             */
          }, {
            key: "cache",
            value: function cache(assetType, dataFormat, data, id) {
              log.warn('Deprecation: BuiltinHelper.cache has been replaced with BuiltinHelper.store.');
              return this.store(assetType, dataFormat, data, id);
            }

            /**
             * Deprecated external API for _store
             * @deprecated Not for external use. Create assets and keep track of them outside of the storage instance.
             * @param {AssetType} assetType - The type of the asset to cache.
             * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.
             * @param {Buffer} data - The data for the cached asset.
             * @param {(string|number)} id - The id for the cached asset.
             * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.
             */
          }, {
            key: "store",
            value: function store(assetType, dataFormat, data, id) {
              log.warn('Deprecation: use Storage.createAsset. BuiltinHelper is for internal use only.');
              return this._store(assetType, dataFormat, data, id);
            }

            /**
             * Cache an asset for future lookups by ID.
             * @param {AssetType} assetType - The type of the asset to cache.
             * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.
             * @param {Buffer} data - The data for the cached asset.
             * @param {(string|number)} id - The id for the cached asset.
             * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.
             */
          }, {
            key: "_store",
            value: function _store(assetType, dataFormat, data, id) {
              if (!dataFormat) throw new Error('Data cached without specifying its format');
              if (id !== '' && id !== null && typeof id !== 'undefined') {
                if (Object.prototype.hasOwnProperty.call(this.assets, id) && assetType.immutable) return id;
              } else if (assetType.immutable) {
                id = md5(data);
              } else {
                throw new Error('Tried to cache data without an id');
              }
              this.assets[id] = {
                type: assetType,
                format: dataFormat,
                id: id,
                data: data
              };
              return id;
            }

            /**
             * Fetch an asset but don't process dependencies.
             * @param {AssetType} assetType - The type of asset to fetch.
             * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.
             * @return {?Promise.<Asset>} A promise for the contents of the asset.
             */
          }, {
            key: "load",
            value: function load(assetType, assetId) {
              if (!this.get(assetId)) {
                // Return null immediately so Storage can quickly move to trying the
                // next helper.
                return null;
              }
              return Promise.resolve(this.get(assetId));
            }
          }]);
        }(Helper);
        module.exports = BuiltinHelper;
        /* WEBPACK VAR INJECTION */
      }).call(this, __nested_webpack_require_213491__( /*! ./../node_modules/buffer/index.js */"./node_modules/buffer/index.js").Buffer);

      /***/
    }),
    /***/"./src/DataFormat.js": (
    /*!***************************!*\
      !*** ./src/DataFormat.js ***!
      \***************************/
    /*! no static exports found */
    /***/
    function _src_DataFormatJs(module, exports) {
      /**
       * Enumeration of the supported data formats.
       * @enum {string}
       */
      var DataFormat = {
        JPG: 'jpg',
        JSON: 'json',
        MP3: 'mp3',
        PNG: 'png',
        SB2: 'sb2',
        SB3: 'sb3',
        SVG: 'svg',
        WAV: 'wav'
      };
      module.exports = DataFormat;

      /***/
    }),
    /***/"./src/FetchTool.js": (
    /*!**************************!*\
      !*** ./src/FetchTool.js ***!
      \**************************/
    /*! no static exports found */
    /***/
    function _src_FetchToolJs(module, exports, __nested_webpack_require_223834__) {
      var _objectWithoutProperties = __nested_webpack_require_223834__( /*! @babel/runtime/helpers/objectWithoutProperties */"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
      var _classCallCheck = __nested_webpack_require_223834__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_223834__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      var _excluded = ["url"],
        _excluded2 = ["url", "withCredentials"];
      var _require = __nested_webpack_require_223834__( /*! ./scratchFetch */"./src/scratchFetch.js"),
        scratchFetch = _require.scratchFetch;

      /**
       * @typedef {Request & {withCredentials: boolean}} ScratchSendRequest
       */

      /**
       * Get and send assets with the fetch standard web api.
       */
      var FetchTool = /*#__PURE__*/function () {
        "use strict";

        function FetchTool() {
          _classCallCheck(this, FetchTool);
        }
        return _createClass(FetchTool, [{
          key: "isGetSupported",
          get:
          /**
           * Is get supported?
           * Always true for `FetchTool` because `scratchFetch` ponyfills `fetch` if necessary.
           * @returns {boolean} Is get supported?
           */
          function get() {
            return true;
          }

          /**
           * Request data from a server with fetch.
           * @param {Request} reqConfig - Request configuration for data to get.
           * @returns {Promise.<Uint8Array?>} Resolve to Buffer of data from server.
           */
        }, {
          key: "get",
          value: function get(_ref) {
            var url = _ref.url,
              options = _objectWithoutProperties(_ref, _excluded);
            return scratchFetch(url, Object.assign({
              method: 'GET'
            }, options)).then(function (result) {
              if (result.ok) return result.arrayBuffer().then(function (b) {
                return new Uint8Array(b);
              });
              if (result.status === 404) return null;
              return Promise.reject(result.status); // TODO: we should throw a proper error
            });
          }

          /**
           * Is sending supported?
           * Always true for `FetchTool` because `scratchFetch` ponyfills `fetch` if necessary.
           * @returns {boolean} Is sending supported?
           */
        }, {
          key: "isSendSupported",
          get: function get() {
            return true;
          }

          /**
           * Send data to a server with fetch.
           * @param {ScratchSendRequest} reqConfig - Request configuration for data to send.
           * @returns {Promise.<string>} Server returned metadata.
           */
        }, {
          key: "send",
          value: function send(_ref2) {
            var url = _ref2.url,
              _ref2$withCredentials = _ref2.withCredentials,
              withCredentials = _ref2$withCredentials === void 0 ? false : _ref2$withCredentials,
              options = _objectWithoutProperties(_ref2, _excluded2);
            return scratchFetch(url, Object.assign({
              credentials: withCredentials ? 'include' : 'omit'
            }, options)).then(function (response) {
              if (response.ok) return response.text();
              return Promise.reject(response.status);
            });
          }
        }]);
      }();
      module.exports = FetchTool;

      /***/
    }),
    /***/"./src/FetchWorkerTool.js": (
    /*!********************************!*\
      !*** ./src/FetchWorkerTool.js ***!
      \********************************/
    /*! no static exports found */
    /***/
    function _src_FetchWorkerToolJs(module, exports, __nested_webpack_require_227656__) {
      var _objectWithoutProperties = __nested_webpack_require_227656__( /*! @babel/runtime/helpers/objectWithoutProperties */"./node_modules/@babel/runtime/helpers/objectWithoutProperties.js");
      var _classCallCheck = __nested_webpack_require_227656__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_227656__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      var _excluded = ["url"];
      function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0,
              F = function F() {};
            return {
              s: F,
              n: function n() {
                return _n >= r.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: r[_n++]
                };
              },
              e: function e(r) {
                throw r;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o,
          a = !0,
          u = !1;
        return {
          s: function s() {
            t = t.call(r);
          },
          n: function n() {
            var r = t.next();
            return a = r.done, r;
          },
          e: function e(r) {
            u = !0, o = r;
          },
          f: function f() {
            try {
              a || null == t.return || t.return();
            } finally {
              if (u) throw o;
            }
          }
        };
      }
      function _unsupportedIterableToArray(r, a) {
        if (r) {
          if ("string" == typeof r) return _arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
      }
      function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      var _require = __nested_webpack_require_227656__( /*! ./scratchFetch */"./src/scratchFetch.js"),
        Headers = _require.Headers,
        applyMetadata = _require.applyMetadata;

      /**
       * Get and send assets with a worker that uses fetch.
       */
      var PrivateFetchWorkerTool = /*#__PURE__*/function () {
        "use strict";

        function PrivateFetchWorkerTool() {
          var _this = this;
          _classCallCheck(this, PrivateFetchWorkerTool);
          /**
           * What does the worker support of the APIs we need?
           * @type {{fetch:boolean}}
           */
          this._workerSupport = {
            fetch: typeof fetch !== 'undefined'
          };

          /**
           * A possible error occurred standing up the worker.
           * @type {Error?}
           */
          this._supportError = null;

          /**
           * The worker that runs fetch and returns data for us.
           * @type {Worker?}
           */
          this.worker = null;

          /**
           * A map of ids to fetch job objects.
           * @type {object}
           */
          this.jobs = {};
          try {
            if (this.isGetSupported) {
              // eslint-disable-next-line global-require
              var FetchWorker = __nested_webpack_require_227656__( /*! worker-loader?{"inline":true,"fallback":true}!./FetchWorkerTool.worker */"./node_modules/worker-loader/dist/cjs.js?{\"inline\":true,\"fallback\":true}!./src/FetchWorkerTool.worker.js");
              var worker = new FetchWorker();
              worker.addEventListener('message', function (_ref) {
                var data = _ref.data;
                if (data.support) {
                  _this._workerSupport = data.support;
                  return;
                }
                var _iterator = _createForOfIteratorHelper(data),
                  _step;
                try {
                  for (_iterator.s(); !(_step = _iterator.n()).done;) {
                    var message = _step.value;
                    if (_this.jobs[message.id]) {
                      if (message.error) {
                        _this.jobs[message.id].reject(message.error);
                      } else {
                        _this.jobs[message.id].resolve(message.buffer);
                      }
                      delete _this.jobs[message.id];
                    }
                  }
                } catch (err) {
                  _iterator.e(err);
                } finally {
                  _iterator.f();
                }
              });
              this.worker = worker;
            }
          } catch (error) {
            this._supportError = error;
          }
        }

        /**
         * Is get supported?
         *
         * false if the environment does not workers, fetch, or fetch from inside a
         * worker. Finding out the worker supports fetch is asynchronous and will
         * guess that it does if the window does until the worker can inform us.
         * @returns {boolean} Is get supported?
         */
        return _createClass(PrivateFetchWorkerTool, [{
          key: "isGetSupported",
          get: function get() {
            return typeof Worker !== 'undefined' && this._workerSupport.fetch && !this._supportError;
          }

          /**
           * Request data from a server with a worker using fetch.
           * @param {{url:string}} reqConfig - Request configuration for data to get.
           * @param {{method:string}} options - Additional options to configure fetch.
           * @returns {Promise.<Buffer|Uint8Array|null>} Resolve to Buffer of data from server.
           */
        }, {
          key: "get",
          value: function get(_ref2) {
            var _this2 = this;
            var url = _ref2.url,
              options = _objectWithoutProperties(_ref2, _excluded);
            return new Promise(function (resolve, reject) {
              // TODO: Use a Scratch standard ID generator ...
              var id = Math.random().toString(16).substring(2);
              var augmentedOptions = applyMetadata(Object.assign({
                method: 'GET'
              }, options));
              // the Fetch spec says options.headers could be:
              // "A Headers object, an object literal, or an array of two-item arrays to set request's headers."
              // structured clone (postMessage) doesn't support Headers objects
              // so turn it into an array of two-item arrays to make it to the worker intact
              if (augmentedOptions && augmentedOptions.headers instanceof Headers) {
                augmentedOptions.headers = Array.from(augmentedOptions.headers.entries());
              }
              _this2.worker.postMessage({
                id: id,
                url: url,
                options: augmentedOptions
              });
              _this2.jobs[id] = {
                id: id,
                resolve: resolve,
                reject: reject
              };
            })
            /* eslint no-confusing-arrow: ["error", {"allowParens": true}] */.then(function (body) {
              return body ? new Uint8Array(body) : null;
            });
          }

          /**
           * Is sending supported? always false for FetchWorkerTool.
           * @returns {boolean} Is sending supported?
           */
        }, {
          key: "isSendSupported",
          get: function get() {
            return false;
          }

          /**
           * Send data to a server.
           * @throws {Error} A not implemented error.
           */
        }, {
          key: "send",
          value: function send() {
            throw new Error('Not implemented.');
          }

          /**
           * Return a static PrivateFetchWorkerTool instance on demand.
           * @returns {PrivateFetchWorkerTool} A static PrivateFetchWorkerTool
           *   instance
           */
        }], [{
          key: "instance",
          get: function get() {
            if (!this._instance) {
              this._instance = new PrivateFetchWorkerTool();
            }
            return this._instance;
          }
        }]);
      }();
      /**
       * Get and send assets with a worker that uses fetch.
       */
      var PublicFetchWorkerTool = /*#__PURE__*/function () {
        "use strict";

        function PublicFetchWorkerTool() {
          _classCallCheck(this, PublicFetchWorkerTool);
          /**
           * Shared instance of an internal worker. PublicFetchWorkerTool proxies
           * it.
           * @type {PrivateFetchWorkerTool}
           */
          this.inner = PrivateFetchWorkerTool.instance;
        }

        /**
         * Is get supported?
         * @returns {boolean} Is get supported?
         */
        return _createClass(PublicFetchWorkerTool, [{
          key: "isGetSupported",
          get: function get() {
            return this.inner.isGetSupported;
          }

          /**
           * Request data from a server with a worker that uses fetch.
           * @param {{url:string}} reqConfig - Request configuration for data to get.
           * @returns {Promise.<Buffer|Uint8Array|null>} Resolve to Buffer of data from server.
           */
        }, {
          key: "get",
          value: function get(reqConfig) {
            return this.inner.get(reqConfig);
          }

          /**
           * Is sending supported?
           * @returns {boolean} Is sending supported?
           */
        }, {
          key: "isSendSupported",
          get: function get() {
            return false;
          }

          /**
           * Send data to a server with a worker that uses fetch.
           * @throws {Error} A not implemented error.
           */
        }, {
          key: "send",
          value: function send() {
            throw new Error('Not implemented.');
          }
        }]);
      }();
      module.exports = PublicFetchWorkerTool;

      /***/
    }),
    /***/"./src/Helper.js": (
    /*!***********************!*\
      !*** ./src/Helper.js ***!
      \***********************/
    /*! no static exports found */
    /***/
    function _src_HelperJs(module, exports, __nested_webpack_require_238436__) {
      var _classCallCheck = __nested_webpack_require_238436__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_238436__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      /**
       * Base class for asset load/save helpers.
       * @abstract
       */
      var Helper = /*#__PURE__*/function () {
        "use strict";

        function Helper(parent) {
          _classCallCheck(this, Helper);
          this.parent = parent;
        }

        /**
         * Fetch an asset but don't process dependencies.
         * @param {AssetType} assetType - The type of asset to fetch.
         * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.
         * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.
         * @return {Promise.<Asset>} A promise for the contents of the asset.
         */
        return _createClass(Helper, [{
          key: "load",
          value: function load(assetType, assetId, dataFormat) {
            return Promise.reject(new Error("No asset of type ".concat(assetType, " for ID ").concat(assetId, " with format ").concat(dataFormat)));
          }
        }]);
      }();
      module.exports = Helper;

      /***/
    }),
    /***/"./src/ProxyTool.js": (
    /*!**************************!*\
      !*** ./src/ProxyTool.js ***!
      \**************************/
    /*! no static exports found */
    /***/
    function _src_ProxyToolJs(module, exports, __nested_webpack_require_240063__) {
      var _classCallCheck = __nested_webpack_require_240063__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_240063__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      var FetchWorkerTool = __nested_webpack_require_240063__( /*! ./FetchWorkerTool */"./src/FetchWorkerTool.js");
      var FetchTool = __nested_webpack_require_240063__( /*! ./FetchTool */"./src/FetchTool.js");

      /**
       * @typedef {object} Request
       * @property {string} url
       * @property {*} body
       * @property {string} method
       * @property {boolean} withCredentials
       */

      /**
       * Get and send assets with other tools in sequence.
       */
      var ProxyTool = /*#__PURE__*/function () {
        "use strict";

        function ProxyTool() {
          var filter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ProxyTool.TOOL_FILTER.ALL;
          _classCallCheck(this, ProxyTool);
          var tools;
          if (filter === ProxyTool.TOOL_FILTER.READY) {
            tools = [new FetchTool()];
          } else {
            tools = [new FetchWorkerTool(), new FetchTool()];
          }

          /**
           * Sequence of tools to proxy.
           * @type {Array.<Tool>}
           */
          this.tools = tools;
        }

        /**
         * Is get supported? false if all proxied tool return false.
         * @returns {boolean} Is get supported?
         */
        return _createClass(ProxyTool, [{
          key: "isGetSupported",
          get: function get() {
            return this.tools.some(function (tool) {
              return tool.isGetSupported;
            });
          }

          /**
           * Request data from with one of the proxied tools.
           * @param {Request} reqConfig - Request configuration for data to get.
           * @returns {Promise.<Buffer>} Resolve to Buffer of data from server.
           */
        }, {
          key: "get",
          value: function get(reqConfig) {
            var _this = this;
            var toolIndex = 0;
            var _nextTool = function nextTool(err) {
              var tool = _this.tools[toolIndex++];
              if (!tool) {
                throw err;
              }
              if (!tool.isGetSupported) {
                return _nextTool(err);
              }
              return tool.get(reqConfig).catch(_nextTool);
            };
            return _nextTool();
          }

          /**
           * Is sending supported? false if all proxied tool return false.
           * @returns {boolean} Is sending supported?
           */
        }, {
          key: "isSendSupported",
          get: function get() {
            return this.tools.some(function (tool) {
              return tool.isSendSupported;
            });
          }

          /**
           * Send data to a server with one of the proxied tools.
           * @param {Request} reqConfig - Request configuration for data to send.
           * @returns {Promise.<Buffer|string|object>} Server returned metadata.
           */
        }, {
          key: "send",
          value: function send(reqConfig) {
            var _this2 = this;
            var toolIndex = 0;
            var _nextTool2 = function nextTool(err) {
              var tool = _this2.tools[toolIndex++];
              if (!tool) {
                throw err;
              }
              if (!tool.isSendSupported) {
                return _nextTool2(err);
              }
              return tool.send(reqConfig).catch(_nextTool2);
            };
            return _nextTool2();
          }
        }]);
      }();
      /**
       * Constant values that filter the set of tools in a ProxyTool instance.
       * @enum {string}
       */
      ProxyTool.TOOL_FILTER = {
        /**
         * Use all tools.
         */
        ALL: 'all',
        /**
         * Use tools that are ready right now.
         */
        READY: 'ready'
      };
      module.exports = ProxyTool;

      /***/
    }),
    /***/"./src/ScratchStorage.js": (
    /*!*******************************!*\
      !*** ./src/ScratchStorage.js ***!
      \*******************************/
    /*! no static exports found */
    /***/
    function _src_ScratchStorageJs(module, exports, __nested_webpack_require_244436__) {
      var _classCallCheck = __nested_webpack_require_244436__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_244436__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      var log = __nested_webpack_require_244436__( /*! ./log */"./src/log.js");
      var BuiltinHelper = __nested_webpack_require_244436__( /*! ./BuiltinHelper */"./src/BuiltinHelper.js");
      var WebHelper = __nested_webpack_require_244436__( /*! ./WebHelper */"./src/WebHelper.js");
      var _Asset = __nested_webpack_require_244436__( /*! ./Asset */"./src/Asset.js");
      var _AssetType = __nested_webpack_require_244436__( /*! ./AssetType */"./src/AssetType.js");
      var _DataFormat = __nested_webpack_require_244436__( /*! ./DataFormat */"./src/DataFormat.js");
      var _scratchFetch = __nested_webpack_require_244436__( /*! ./scratchFetch */"./src/scratchFetch.js");
      var ScratchStorage = /*#__PURE__*/function () {
        "use strict";

        function ScratchStorage() {
          _classCallCheck(this, ScratchStorage);
          this.defaultAssetId = {};
          this.builtinHelper = new BuiltinHelper(this);
          this.webHelper = new WebHelper(this);
          this.builtinHelper.registerDefaultAssets(this);
          this._helpers = [{
            helper: this.builtinHelper,
            priority: 100
          }, {
            helper: this.webHelper,
            priority: -100
          }];
        }

        /**
         * @return {Asset} - the `Asset` class constructor.
         * @constructor
         */
        return _createClass(ScratchStorage, [{
          key: "Asset",
          get: function get() {
            return _Asset;
          }

          /**
           * @return {AssetType} - the list of supported asset types.
           * @constructor
           */
        }, {
          key: "AssetType",
          get: function get() {
            return _AssetType;
          }

          /**
           * @return {DataFormat} - the list of supported data formats.
           * @constructor
           */
        }, {
          key: "DataFormat",
          get: function get() {
            return _DataFormat;
          }

          /**
           * Access the `scratchFetch` module within this library.
           * @return {module} the scratchFetch module, with properties for `scratchFetch`, `setMetadata`, etc.
           */
        }, {
          key: "scratchFetch",
          get: function get() {
            return _scratchFetch;
          }

          /**
           * @deprecated Please use the `Asset` member of a storage instance instead.
           * @return {Asset} - the `Asset` class constructor.
           * @constructor
           */
        }, {
          key: "addHelper",
          value:
          /**
           * Add a storage helper to this manager. Helpers with a higher priority number will be checked first when loading
           * or storing assets. For comparison, the helper for built-in assets has `priority=100` and the default web helper
           * has `priority=-100`. The relative order of helpers with equal priorities is undefined.
           * @param {Helper} helper - the helper to be added.
           * @param {number} [priority] - the priority for this new helper (default: 0).
           */
          function addHelper(helper) {
            var priority = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
            this._helpers.push({
              helper: helper,
              priority: priority
            });
            this._helpers.sort(function (a, b) {
              return b.priority - a.priority;
            });
          }

          /**
           * Synchronously fetch a cached asset from built-in storage. Assets are cached when they are loaded.
           * @param {string} assetId - The id of the asset to fetch.
           * @returns {?Asset} The asset, if it exists.
           */
        }, {
          key: "get",
          value: function get(assetId) {
            return this.builtinHelper.get(assetId);
          }

          /**
           * Deprecated API for caching built-in assets. Use createAsset.
           * @param {AssetType} assetType - The type of the asset to cache.
           * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.
           * @param {Buffer} data - The data for the cached asset.
           * @param {string} id - The id for the cached asset.
           * @returns {string} The calculated id of the cached asset, or the supplied id if the asset is mutable.
           */
        }, {
          key: "cache",
          value: function cache(assetType, dataFormat, data, id) {
            log.warn('Deprecation: Storage.cache is deprecated. Use Storage.createAsset, and store assets externally.');
            return this.builtinHelper._store(assetType, dataFormat, data, id);
          }

          /**
           * Construct an Asset, and optionally generate an md5 hash of its data to create an id
           * @param {AssetType} assetType - The type of the asset to cache.
           * @param {DataFormat} dataFormat - The dataFormat of the data for the cached asset.
           * @param {Buffer} data - The data for the cached asset.
           * @param {string} [id] - The id for the cached asset.
           * @param {bool} [generateId] - flag to set id to an md5 hash of data if `id` isn't supplied
           * @returns {Asset} generated Asset with `id` attribute set if not supplied
           */
        }, {
          key: "createAsset",
          value: function createAsset(assetType, dataFormat, data, id, generateId) {
            if (!dataFormat) throw new Error('Tried to create asset without a dataFormat');
            return new _Asset(assetType, id, dataFormat, data, generateId);
          }

          /**
           * Register a web-based source for assets. Sources will be checked in order of registration.
           * @param {Array.<AssetType>} types - The types of asset provided by this source.
           * @param {UrlFunction} getFunction - A function which computes a GET URL from an Asset.
           * @param {UrlFunction} createFunction - A function which computes a POST URL for asset data.
           * @param {UrlFunction} updateFunction - A function which computes a PUT URL for asset data.
           */
        }, {
          key: "addWebStore",
          value: function addWebStore(types, getFunction, createFunction, updateFunction) {
            this.webHelper.addStore(types, getFunction, createFunction, updateFunction);
          }

          /**
           * Register a web-based source for assets. Sources will be checked in order of registration.
           * @deprecated Please use addWebStore
           * @param {Array.<AssetType>} types - The types of asset provided by this source.
           * @param {UrlFunction} urlFunction - A function which computes a GET URL from an Asset.
           */
        }, {
          key: "addWebSource",
          value: function addWebSource(types, urlFunction) {
            log.warn('Deprecation: Storage.addWebSource has been replaced by addWebStore.');
            this.addWebStore(types, urlFunction);
          }

          /**
           * TODO: Should this be removed in favor of requesting an asset with `null` as the ID?
           * @param {AssetType} type - Get the default ID for assets of this type.
           * @return {?string} The ID of the default asset of the given type, if any.
           */
        }, {
          key: "getDefaultAssetId",
          value: function getDefaultAssetId(type) {
            if (Object.prototype.hasOwnProperty.call(this.defaultAssetId, type.name)) {
              return this.defaultAssetId[type.name];
            }
          }

          /**
           * Set the default ID for a particular type of asset. This default asset will be used if a requested asset cannot
           * be found and automatic fallback is enabled. Ideally this should be an asset that is available locally or even
           * one built into this module.
           * TODO: Should this be removed in favor of requesting an asset with `null` as the ID?
           * @param {AssetType} type - The type of asset for which the default will be set.
           * @param {string} id - The default ID to use for this type of asset.
           */
        }, {
          key: "setDefaultAssetId",
          value: function setDefaultAssetId(type, id) {
            this.defaultAssetId[type.name] = id;
          }

          /**
           * Fetch an asset by type & ID.
           * @param {AssetType} assetType - The type of asset to fetch. This also determines which asset store to use.
           * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.
           * @param {DataFormat} [dataFormat] - Optional: load this format instead of the AssetType's default.
           * @return {Promise.<Asset>} A promise for the requested Asset.
           *   If the promise is resolved with non-null, the value is the requested asset.
           *   If the promise is resolved with null, the desired asset could not be found with the current asset sources.
           *   If the promise is rejected, there was an error on at least one asset source. HTTP 404 does not count as an
           *   error here, but (for example) HTTP 403 does.
           */
        }, {
          key: "load",
          value: function load(assetType, assetId, dataFormat) {
            /** @type {Helper[]} */
            var helpers = this._helpers.map(function (x) {
              return x.helper;
            });
            var errors = [];
            dataFormat = dataFormat || assetType.runtimeFormat;
            var helperIndex = 0;
            var helper;
            var _tryNextHelper = function tryNextHelper(err) {
              if (err) {
                // Track the error, but continue looking
                errors.push(err);
              }
              helper = helpers[helperIndex++];
              if (helper) {
                var loading = helper.load(assetType, assetId, dataFormat);
                if (loading === null) {
                  return _tryNextHelper();
                }
                // Note that other attempts may have logged errors; if this succeeds they will be suppressed.
                return loading
                // TODO: maybe some types of error should prevent trying the next helper?
                .catch(_tryNextHelper);
              } else if (errors.length > 0) {
                // We looked through all the helpers and couldn't find the asset, AND
                // at least one thing went wrong while we were looking.
                return Promise.reject(errors);
              }

              // Nothing went wrong but we couldn't find the asset.
              return Promise.resolve(null);
            };
            return _tryNextHelper();
          }

          /**
           * Store an asset by type & ID.
           * @param {AssetType} assetType - The type of asset to fetch. This also determines which asset store to use.
           * @param {?DataFormat} [dataFormat] - Optional: load this format instead of the AssetType's default.
           * @param {Buffer} data - Data to store for the asset
           * @param {?string} [assetId] - The ID of the asset to fetch: a project ID, MD5, etc.
           * @return {Promise.<object>} A promise for asset metadata
           */
        }, {
          key: "store",
          value: function store(assetType, dataFormat, data, assetId) {
            var _this = this;
            dataFormat = dataFormat || assetType.runtimeFormat;
            return new Promise(function (resolve, reject) {
              return _this.webHelper.store(assetType, dataFormat, data, assetId).then(function (body) {
                _this.builtinHelper._store(assetType, dataFormat, data, body.id);
                return resolve(body);
              }).catch(function (error) {
                return reject(error);
              });
            });
          }
        }], [{
          key: "Asset",
          get: function get() {
            return _Asset;
          }

          /**
           * @deprecated Please use the `AssetType` member of a storage instance instead.
           * @return {AssetType} - the list of supported asset types.
           * @constructor
           */
        }, {
          key: "AssetType",
          get: function get() {
            return _AssetType;
          }
        }]);
      }();
      module.exports = ScratchStorage;

      /***/
    }),
    /***/"./src/WebHelper.js": (
    /*!**************************!*\
      !*** ./src/WebHelper.js ***!
      \**************************/
    /*! no static exports found */
    /***/
    function _src_WebHelperJs(module, exports, __nested_webpack_require_257321__) {
      var _readOnlyError = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/readOnlyError */"./node_modules/@babel/runtime/helpers/readOnlyError.js");
      var _classCallCheck = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/classCallCheck */"./node_modules/@babel/runtime/helpers/classCallCheck.js");
      var _createClass = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/createClass */"./node_modules/@babel/runtime/helpers/createClass.js");
      var _possibleConstructorReturn = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/possibleConstructorReturn */"./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js");
      var _getPrototypeOf = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/getPrototypeOf */"./node_modules/@babel/runtime/helpers/getPrototypeOf.js");
      var _inherits = __nested_webpack_require_257321__( /*! @babel/runtime/helpers/inherits */"./node_modules/@babel/runtime/helpers/inherits.js");
      function _callSuper(t, o, e) {
        return o = _getPrototypeOf(o), _possibleConstructorReturn(t, _isNativeReflectConstruct() ? Reflect.construct(o, e || [], _getPrototypeOf(t).constructor) : o.apply(t, e));
      }
      function _isNativeReflectConstruct() {
        try {
          var t = !Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
        } catch (t) {}
        return (_isNativeReflectConstruct = function _isNativeReflectConstruct() {
          return !!t;
        })();
      }
      var log = __nested_webpack_require_257321__( /*! ./log */"./src/log.js");
      var Asset = __nested_webpack_require_257321__( /*! ./Asset */"./src/Asset.js");
      var Helper = __nested_webpack_require_257321__( /*! ./Helper */"./src/Helper.js");
      var ProxyTool = __nested_webpack_require_257321__( /*! ./ProxyTool */"./src/ProxyTool.js");
      var ensureRequestConfig = function ensureRequestConfig(reqConfig) {
        if (typeof reqConfig === 'string') {
          return {
            url: reqConfig
          };
        }
        return reqConfig;
      };

      /**
       * @typedef {function} UrlFunction - A function which computes a URL from asset information.
       * @param {Asset} - The asset for which the URL should be computed.
       * @returns {(string|object)} - A string representing the URL for the asset request OR an object with configuration for
       *                              the underlying fetch call (necessary for configuring e.g. authentication)
       */
      var WebHelper = /*#__PURE__*/function (_Helper) {
        "use strict";

        function WebHelper(parent) {
          var _this;
          _classCallCheck(this, WebHelper);
          _this = _callSuper(this, WebHelper, [parent]);

          /**
           * @type {Array.<StoreRecord>}
           * @typedef {object} StoreRecord
           * @property {Array.<string>} types - The types of asset provided by this store, from AssetType's name field.
           * @property {UrlFunction} getFunction - A function which computes a URL from an Asset.
           * @property {UrlFunction} createFunction - A function which computes a URL from an Asset.
           * @property {UrlFunction} updateFunction - A function which computes a URL from an Asset.
           */
          _this.stores = [];

          /**
           * Set of tools to best load many assets in parallel. If one tool
           * cannot be used, it will use the next.
           * @type {ProxyTool}
           */
          _this.assetTool = new ProxyTool();

          /**
           * Set of tools to best load project data in parallel with assets. This
           * tool set prefers tools that are immediately ready. Some tools have
           * to initialize before they can load files.
           * @type {ProxyTool}
           */
          _this.projectTool = new ProxyTool(ProxyTool.TOOL_FILTER.READY);
          return _this;
        }

        /**
         * Register a web-based source for assets. Sources will be checked in order of registration.
         * @deprecated Please use addStore
         * @param {Array.<AssetType>} types - The types of asset provided by this source.
         * @param {UrlFunction} urlFunction - A function which computes a URL from an Asset.
         */
        _inherits(WebHelper, _Helper);
        return _createClass(WebHelper, [{
          key: "addSource",
          value: function addSource(types, urlFunction) {
            log.warn('Deprecation: WebHelper.addSource has been replaced with WebHelper.addStore.');
            this.addStore(types, urlFunction);
          }

          /**
           * Register a web-based store for assets. Sources will be checked in order of registration.
           * @param {Array.<AssetType>} types - The types of asset provided by this store.
           * @param {UrlFunction} getFunction - A function which computes a GET URL for an Asset
           * @param {UrlFunction} createFunction - A function which computes a POST URL for an Asset
           * @param {UrlFunction} updateFunction - A function which computes a PUT URL for an Asset
           */
        }, {
          key: "addStore",
          value: function addStore(types, getFunction, createFunction, updateFunction) {
            this.stores.push({
              types: types.map(function (assetType) {
                return assetType.name;
              }),
              get: getFunction,
              create: createFunction,
              update: updateFunction
            });
          }

          /**
           * Fetch an asset but don't process dependencies.
           * @param {AssetType} assetType - The type of asset to fetch.
           * @param {string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.
           * @param {DataFormat} dataFormat - The file format / file extension of the asset to fetch: PNG, JPG, etc.
           * @return {Promise.<Asset>} A promise for the contents of the asset.
           */
        }, {
          key: "load",
          value: function load(assetType, assetId, dataFormat) {
            /** @type {Array.<{url:string, result:*}>} List of URLs attempted & errors encountered. */
            var errors = [];
            var stores = this.stores.slice().filter(function (store) {
              return store.types.indexOf(assetType.name) >= 0;
            });

            // New empty asset but it doesn't have data yet
            var asset = new Asset(assetType, assetId, dataFormat);
            var tool = this.assetTool;
            if (assetType.name === 'Project') {
              tool = this.projectTool;
            }
            var storeIndex = 0;
            var _tryNextSource = function tryNextSource(err) {
              if (err) {
                errors.push(err);
              }
              var store = stores[storeIndex++];

              /** @type {UrlFunction} */
              var reqConfigFunction = store && store.get;
              if (reqConfigFunction) {
                var reqConfig = ensureRequestConfig(reqConfigFunction(asset));
                if (reqConfig === false) {
                  return _tryNextSource();
                }
                return tool.get(reqConfig).then(function (body) {
                  if (body) {
                    asset.setData(body, dataFormat);
                    return asset;
                  }
                  return _tryNextSource();
                }).catch(_tryNextSource);
              } else if (errors.length > 0) {
                return Promise.reject(errors);
              }

              // no stores matching asset
              return Promise.resolve(null);
            };
            return _tryNextSource();
          }

          /**
           * Create or update an asset with provided data. The create function is called if no asset id is provided
           * @param {AssetType} assetType - The type of asset to create or update.
           * @param {?DataFormat} dataFormat - DataFormat of the data for the stored asset.
           * @param {Buffer} data - The data for the cached asset.
           * @param {?string} assetId - The ID of the asset to fetch: a project ID, MD5, etc.
           * @return {Promise.<object>} A promise for the response from the create or update request
           */
        }, {
          key: "store",
          value: function store(assetType, dataFormat, data, assetId) {
            var asset = new Asset(assetType, assetId, dataFormat);
            // If we have an asset id, we should update, otherwise create to get an id
            var create = assetId === '' || assetId === null || typeof assetId === 'undefined';

            // Use the first store with the appropriate asset type and url function
            var store = this.stores.filter(function (s) {
              return (
                // Only use stores for the incoming asset type
                s.types.indexOf(assetType.name) !== -1 && (
                // Only use stores that have a create function if this is a create request
                // or an update function if this is an update request
                create && s.create || s.update)
              );
            })[0];
            var method = create ? 'post' : 'put';
            if (!store) return Promise.reject(new Error('No appropriate stores'));
            var tool = this.assetTool;
            if (assetType.name === 'Project') {
              tool = this.projectTool;
            }
            var reqConfig = ensureRequestConfig(create ? store.create(asset) : store.update(asset));
            var reqBodyConfig = Object.assign({
              body: data,
              method: method
            }, reqConfig);
            return tool.send(reqBodyConfig).then(function (body) {
              // xhr makes it difficult to both send FormData and
              // automatically parse a JSON response. So try to parse
              // everything as JSON.
              if (typeof body === 'string') {
                try {
                  body = JSON.parse(body);
                } catch (parseError) {
                  // If it's not parseable, then we can't add the id even
                  // if we want to, so stop here
                  return body;
                }
              }
              return Object.assign({
                id: body['content-name'] || assetId
              }, body);
            });
          }
        }]);
      }(Helper);
      module.exports = WebHelper;

      /***/
    }),
    /***/"./src/builtins/defaultBitmap.png": (
    /*!****************************************!*\
      !*** ./src/builtins/defaultBitmap.png ***!
      \****************************************/
    /*! no static exports found */
    /***/
    function _src_builtins_defaultBitmapPng(module, exports, __nested_webpack_require_268045__) {
      module.exports = __nested_webpack_require_268045__( /*! ../../node_modules/arraybuffer-loader/lib/to-array-buffer.js */"./node_modules/arraybuffer-loader/lib/to-array-buffer.js")("iVBORw0KGgoAAAANSUhEUgAAAIAAAACACAAAAADmVT4XAAADZElEQVR42u3a70vbQBgH8O/7vOibvsmbFUEEWUGGUhQ25nDuhSKIUFDxlYi0SAd94atRmFiHCH2x4W8iiNtwowXRgd1QipJYY3N/1F4kTQ6XLKS9yyHcvWyO8MnT5y53Tw5EcIMESIAESIAESIAESIAEPFVAq/6l8G4oAQCp4aniwbUVJ6BVzafwqKXy1VZMgNb+CHzbyK4ZB+Bi0nnk0VyhsDiSoAmvvnMHmGUVAF6UG+0ffsxRhsRHky/AyCsAUpumX0wAAIs6T4CxDADDtcdZsal6gjmdH8AsAEC6+s8Fa48SFExeAKusAEju+V367AmUCi9ANQ0AU3pwcOw2cMEH0FwAAKz5X228pRLR5AI4TgIAtIDL24oLUE94AB6W7LsH/cONN14Ilh44AOqD9s2LQR1KHiB9zgGgOSGeuA3ocPrME1Q4ANaceyePAzrcjHmAZYs9IBeW4/fzHiAwTCwAgTle9ACZK44ALDT9e6x7gL4aT0BQCHb4AqgA5/1TTOMLoJ7vZSMM0H/GHnCeDnu+CrU8vGYPcN5FADBYD0vCaYPDy+i0p337GSMsS1Z4vA3t9QgAZTt0IuIxFRPSKicAQHlvhk3FXF5GhBByMa8qo/sBO6BarwuYbYrYnFKDYEvE7phKgcxvEQBqnvhgiQCUOgoAO4C3JOS3L/hv23UXxVldBECfcueAqpAa0WGy/QeULREAY6aTXRFDgBuA13+ElOncAERMAGaA9hBQD4gQQHsIRE1AZoD2xrgQS5nOZyHgFKmWDSIG4GRAVidiAE4GRB6AzAB2AKIPQFaA5myHA5AV4ESNugZhC7BLR50lIBPAebrzBGQCKAFQNSIMcDvRTQIwAHxNApM3RBygGK0uyhxwOwGsPAgEnPWj5ycRCNiJtBHlAChGKQVwANzPY+CXSMDNWISiLA9AfRA5IhJQ68UnoQAt+AtOPIBKhJosF8B6UM0yLkAxQk2WCyDX9SiUh1gkQAIkoCuAvjGuquMbuijAtwG7MPL8yBICOHSPk3W8Ne8KcEUdmBi6FADYos+QleIH0N/ogOxd7AD6uAS6WRU8WcBdlgZMG/EnYUlwEpLLoQ4PjzGbiA5UsRMRsbQ+5ziDJmYqJuR6NaMomdXuFuZyPSABEiABEiABEiABEiAc8Bd6VyvCEKGqcQAAAABJRU5ErkJggg==");

      /***/
    }),
    /***/"./src/builtins/defaultSound.wav": (
    /*!***************************************!*\
      !*** ./src/builtins/defaultSound.wav ***!
      \***************************************/
    /*! no static exports found */
    /***/
    function _src_builtins_defaultSoundWav(module, exports, __nested_webpack_require_269798__) {
      module.exports = __nested_webpack_require_269798__( /*! ../../node_modules/arraybuffer-loader/lib/to-array-buffer.js */"./node_modules/arraybuffer-loader/lib/to-array-buffer.js")("UklGRiYAAABXQVZFZm10IBAAAAABAAEAIlYAAESsAAACABAAZGF0YQIAAAAAAA==");

      /***/
    }),
    /***/"./src/builtins/defaultVector.svg": (
    /*!****************************************!*\
      !*** ./src/builtins/defaultVector.svg ***!
      \****************************************/
    /*! no static exports found */
    /***/
    function _src_builtins_defaultVectorSvg(module, exports, __nested_webpack_require_270384__) {
      module.exports = __nested_webpack_require_270384__( /*! ../../node_modules/arraybuffer-loader/lib/to-array-buffer.js */"./node_modules/arraybuffer-loader/lib/to-array-buffer.js")("PD94bWwgdmVyc2lvbj0iMS4wIj8+Cjxzdmcgd2lkdGg9IjEyOCIgaGVpZ2h0PSIxMjgiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyIgeG1sbnM6c3ZnPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CiA8Zz4KICA8cmVjdCBmaWxsPSIjQ0NDIiBoZWlnaHQ9IjEyOCIgd2lkdGg9IjEyOCIvPgogIDx0ZXh0IGZpbGw9ImJsYWNrIiB5PSIxMDciIHg9IjM1LjUiIGZvbnQtc2l6ZT0iMTI4Ij4/PC90ZXh0PgogPC9nPgo8L3N2Zz4K");

      /***/
    }),
    /***/"./src/index.js": (
    /*!**********************!*\
      !*** ./src/index.js ***!
      \**********************/
    /*! no static exports found */
    /***/
    function _src_indexJs(module, exports, __nested_webpack_require_271156__) {
      var ScratchStorage = __nested_webpack_require_271156__( /*! ./ScratchStorage */"./src/ScratchStorage.js");

      /**
       * Export for use with NPM & Node.js.
       * @type {ScratchStorage}
       */
      module.exports = ScratchStorage;

      /***/
    }),
    /***/"./src/log.js": (
    /*!********************!*\
      !*** ./src/log.js ***!
      \********************/
    /*! no static exports found */
    /***/
    function _src_logJs(module, exports, __nested_webpack_require_271637__) {
      var minilog = __nested_webpack_require_271637__( /*! minilog */"./node_modules/minilog/lib/web/index.js");
      minilog.enable();
      module.exports = minilog('storage');

      /***/
    }),
    /***/"./src/scratchFetch.js": (
    /*!*****************************!*\
      !*** ./src/scratchFetch.js ***!
      \*****************************/
    /*! no static exports found */
    /***/
    function _src_scratchFetchJs(module, exports, __nested_webpack_require_272094__) {
      var _slicedToArray = __nested_webpack_require_272094__( /*! @babel/runtime/helpers/slicedToArray */"./node_modules/@babel/runtime/helpers/slicedToArray.js");
      function _createForOfIteratorHelper(r, e) {
        var t = "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
        if (!t) {
          if (Array.isArray(r) || (t = _unsupportedIterableToArray(r)) || e && r && "number" == typeof r.length) {
            t && (r = t);
            var _n = 0,
              F = function F() {};
            return {
              s: F,
              n: function n() {
                return _n >= r.length ? {
                  done: !0
                } : {
                  done: !1,
                  value: r[_n++]
                };
              },
              e: function e(r) {
                throw r;
              },
              f: F
            };
          }
          throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
        }
        var o,
          a = !0,
          u = !1;
        return {
          s: function s() {
            t = t.call(r);
          },
          n: function n() {
            var r = t.next();
            return a = r.done, r;
          },
          e: function e(r) {
            u = !0, o = r;
          },
          f: function f() {
            try {
              a || null == t.return || t.return();
            } finally {
              if (u) throw o;
            }
          }
        };
      }
      function _unsupportedIterableToArray(r, a) {
        if (r) {
          if ("string" == typeof r) return _arrayLikeToArray(r, a);
          var t = {}.toString.call(r).slice(8, -1);
          return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
        }
      }
      function _arrayLikeToArray(r, a) {
        (null == a || a > r.length) && (a = r.length);
        for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
        return n;
      }
      var crossFetch = __nested_webpack_require_272094__( /*! cross-fetch */"./node_modules/cross-fetch/dist/browser-ponyfill.js");

      /**
       * Metadata header names
       * @enum {string} The enum value is the name of the associated header.
       * @readonly
       */
      var RequestMetadata = {
        /** The ID of the project associated with this request */
        ProjectId: 'X-Project-ID',
        /** The ID of the project run associated with this request */
        RunId: 'X-Run-ID'
      };

      /**
       * Metadata headers for requests
       * @type {Headers}
       */
      var metadata = new crossFetch.Headers();

      /**
       * Check if there is any metadata to apply.
       * @returns {boolean} true if `metadata` has contents, or false if it is empty.
       */
      var hasMetadata = function hasMetadata() {
        /* global self */
        var searchParams = typeof self !== 'undefined' && self && self.location && self.location.search && self.location.search.split(/[?&]/) || [];
        if (!searchParams.includes('scratchMetadata=1')) {
          // for now, disable this feature unless scratchMetadata=1
          // TODO: remove this check once we're sure the feature works correctly in production
          return false;
        }
        var _iterator = _createForOfIteratorHelper(metadata),
          _step;
        try {
          for (_iterator.s(); !(_step = _iterator.n()).done;) {
            var _ = _step.value;
            return true;
          }
        } catch (err) {
          _iterator.e(err);
        } finally {
          _iterator.f();
        }
        return false;
      };

      /**
       * Non-destructively merge any metadata state (if any) with the provided options object (if any).
       * If there is metadata state but no options object is provided, make a new object.
       * If there is no metadata state, return the provided options parameter without modification.
       * If there is metadata and an options object is provided, modify a copy and return it.
       * Headers in the provided options object may override headers generated from metadata state.
       * @param {RequestInit} [options] The initial request options. May be null or undefined.
       * @returns {RequestInit|undefined} the provided options parameter without modification, or a new options object.
       */
      var applyMetadata = function applyMetadata(options) {
        if (hasMetadata()) {
          var augmentedOptions = Object.assign({}, options);
          augmentedOptions.headers = new crossFetch.Headers(metadata);
          if (options && options.headers) {
            // the Fetch spec says options.headers could be:
            // "A Headers object, an object literal, or an array of two-item arrays to set request's headers."
            // turn it into a Headers object to be sure of how to interact with it
            var overrideHeaders = options.headers instanceof crossFetch.Headers ? options.headers : new crossFetch.Headers(options.headers);
            var _iterator2 = _createForOfIteratorHelper(overrideHeaders.entries()),
              _step2;
            try {
              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
                var _step2$value = _slicedToArray(_step2.value, 2),
                  name = _step2$value[0],
                  value = _step2$value[1];
                augmentedOptions.headers.set(name, value);
              }
            } catch (err) {
              _iterator2.e(err);
            } finally {
              _iterator2.f();
            }
          }
          return augmentedOptions;
        }
        return options;
      };

      /**
       * Make a network request.
       * This is a wrapper for the global fetch method, adding some Scratch-specific functionality.
       * @param {RequestInfo|URL} resource The resource to fetch.
       * @param {RequestInit} options Optional object containing custom settings for this request.
       * @see {@link https://developer.mozilla.org/docs/Web/API/fetch} for more about the fetch API.
       * @returns {Promise<Response>} A promise for the response to the request.
       */
      var scratchFetch = function scratchFetch(resource, options) {
        var augmentedOptions = applyMetadata(options);
        return crossFetch.fetch(resource, augmentedOptions);
      };

      /**
       * Set the value of a named request metadata item.
       * Setting the value to `null` or `undefined` will NOT remove the item.
       * Use `unsetMetadata` for that.
       * @param {RequestMetadata} name The name of the metadata item to set.
       * @param {any} value The value to set (will be converted to a string).
       */
      var setMetadata = function setMetadata(name, value) {
        metadata.set(name, value);
      };

      /**
       * Remove a named request metadata item.
       * @param {RequestMetadata} name The name of the metadata item to remove.
       */
      var unsetMetadata = function unsetMetadata(name) {
        metadata.delete(name);
      };
      module.exports = {
        default: scratchFetch,
        Headers: crossFetch.Headers,
        RequestMetadata: RequestMetadata,
        applyMetadata: applyMetadata,
        scratchFetch: scratchFetch,
        setMetadata: setMetadata,
        unsetMetadata: unsetMetadata
      };
      if (true) {
        /**
         * Retrieve a named request metadata item.
         * Only for use in tests.
         * @param {RequestMetadata} name The name of the metadata item to retrieve.
         * @returns {any} value The value of the metadata item, or `undefined` if it was not found.
         */
        var getMetadata = function getMetadata(name) {
          return metadata.get(name);
        };
        module.exports.getMetadata = getMetadata;
      }

      /***/
    })

    /******/
  });
});

/***/ }),

/***/ "./node_modules/startaudiocontext/StartAudioContext.js":
/*!*************************************************************!*\
  !*** ./node_modules/startaudiocontext/StartAudioContext.js ***!
  \*************************************************************/
/***/ (function(module, exports) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/**
 *  StartAudioContext.js
 *  @author Yotam Mann
 *  @license http://opensource.org/licenses/MIT MIT License
 *  @copyright 2016 Yotam Mann
 */
(function (root, factory) {
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  } else {}
})(this, function () {
  //TAP LISTENER/////////////////////////////////////////////////////////////

  /**
   * @class  Listens for non-dragging tap ends on the given element
   * @param {Element} element
   * @internal
   */
  var TapListener = function TapListener(element, context) {
    this._dragged = false;
    this._element = element;
    this._bindedMove = this._moved.bind(this);
    this._bindedEnd = this._ended.bind(this, context);
    element.addEventListener("touchstart", this._bindedEnd);
    element.addEventListener("touchmove", this._bindedMove);
    element.addEventListener("touchend", this._bindedEnd);
    element.addEventListener("mouseup", this._bindedEnd);
  };

  /**
   * drag move event
   */
  TapListener.prototype._moved = function (e) {
    this._dragged = true;
  };

  /**
   * tap ended listener
   */
  TapListener.prototype._ended = function (context) {
    if (!this._dragged) {
      startContext(context);
    }
    this._dragged = false;
  };

  /**
   * remove all the bound events
   */
  TapListener.prototype.dispose = function () {
    this._element.removeEventListener("touchstart", this._bindedEnd);
    this._element.removeEventListener("touchmove", this._bindedMove);
    this._element.removeEventListener("touchend", this._bindedEnd);
    this._element.removeEventListener("mouseup", this._bindedEnd);
    this._bindedMove = null;
    this._bindedEnd = null;
    this._element = null;
  };

  //END TAP LISTENER/////////////////////////////////////////////////////////

  /**
   * Plays a silent sound and also invoke the "resume" method
   * @param {AudioContext} context
   * @private
   */
  function startContext(context) {
    // this accomplishes the iOS specific requirement
    var buffer = context.createBuffer(1, 1, context.sampleRate);
    var source = context.createBufferSource();
    source.buffer = buffer;
    source.connect(context.destination);
    source.start(0);

    // resume the audio context
    if (context.resume) {
      context.resume();
    }
  }

  /**
   * Returns true if the audio context is started
   * @param  {AudioContext}  context
   * @return {Boolean}
   * @private
   */
  function isStarted(context) {
    return context.state === "running";
  }

  /**
   * Invokes the callback as soon as the AudioContext
   * is started
   * @param  {AudioContext}   context
   * @param  {Function} callback
   */
  function onStarted(context, callback) {
    function checkLoop() {
      if (isStarted(context)) {
        callback();
      } else {
        requestAnimationFrame(checkLoop);
        if (context.resume) {
          context.resume();
        }
      }
    }
    if (isStarted(context)) {
      callback();
    } else {
      checkLoop();
    }
  }

  /**
   * Add a tap listener to the audio context
   * @param  {Array|Element|String|jQuery} element
   * @param {Array} tapListeners
   */
  function bindTapListener(element, tapListeners, context) {
    if (Array.isArray(element) || NodeList && element instanceof NodeList) {
      for (var i = 0; i < element.length; i++) {
        bindTapListener(element[i], tapListeners, context);
      }
    } else if (typeof element === "string") {
      bindTapListener(document.querySelectorAll(element), tapListeners, context);
    } else if (element.jquery && typeof element.toArray === "function") {
      bindTapListener(element.toArray(), tapListeners, context);
    } else if (Element && element instanceof Element) {
      //if it's an element, create a TapListener
      var tap = new TapListener(element, context);
      tapListeners.push(tap);
    }
  }

  /**
   * @param {AudioContext} context The AudioContext to start.
   * @param {Array|String|Element|jQuery=} elements For iOS, the list of elements
   *                                               to bind tap event listeners
   *                                               which will start the AudioContext. If
   *                                               no elements are given, it will bind
   *                                               to the document.body.
   * @param {Function=} callback The callback to invoke when the AudioContext is started.
   * @return {Promise} The promise is invoked when the AudioContext
   *                       is started.
   */
  function StartAudioContext(context, elements, callback) {
    //the promise is invoked when the AudioContext is started
    var promise = new Promise(function (success) {
      onStarted(context, success);
    });

    // The TapListeners bound to the elements
    var tapListeners = [];

    // add all the tap listeners
    if (!elements) {
      elements = document.body;
    }
    bindTapListener(elements, tapListeners, context);

    //dispose all these tap listeners when the context is started
    promise.then(function () {
      for (var i = 0; i < tapListeners.length; i++) {
        tapListeners[i].dispose();
      }
      tapListeners = null;
      if (callback) {
        callback();
      }
    });
    return promise;
  }
  return StartAudioContext;
});

/***/ }),

/***/ "./node_modules/tiny-inflate/index.js":
/*!********************************************!*\
  !*** ./node_modules/tiny-inflate/index.js ***!
  \********************************************/
/***/ ((module) => {

var TINF_OK = 0;
var TINF_DATA_ERROR = -3;
function Tree() {
  this.table = new Uint16Array(16); /* table of code length counts */
  this.trans = new Uint16Array(288); /* code -> symbol translation table */
}
function Data(source, dest) {
  this.source = source;
  this.sourceIndex = 0;
  this.tag = 0;
  this.bitcount = 0;
  this.dest = dest;
  this.destLen = 0;
  this.ltree = new Tree(); /* dynamic length/symbol tree */
  this.dtree = new Tree(); /* dynamic distance tree */
}

/* --------------------------------------------------- *
 * -- uninitialized global data (static structures) -- *
 * --------------------------------------------------- */

var sltree = new Tree();
var sdtree = new Tree();

/* extra bits and base tables for length codes */
var length_bits = new Uint8Array(30);
var length_base = new Uint16Array(30);

/* extra bits and base tables for distance codes */
var dist_bits = new Uint8Array(30);
var dist_base = new Uint16Array(30);

/* special ordering of code length codes */
var clcidx = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]);

/* used by tinf_decode_trees, avoids allocations every call */
var code_tree = new Tree();
var lengths = new Uint8Array(288 + 32);

/* ----------------------- *
 * -- utility functions -- *
 * ----------------------- */

/* build extra bits and base tables */
function tinf_build_bits_base(bits, base, delta, first) {
  var i, sum;

  /* build bits table */
  for (i = 0; i < delta; ++i) bits[i] = 0;
  for (i = 0; i < 30 - delta; ++i) bits[i + delta] = i / delta | 0;

  /* build base table */
  for (sum = first, i = 0; i < 30; ++i) {
    base[i] = sum;
    sum += 1 << bits[i];
  }
}

/* build the fixed huffman trees */
function tinf_build_fixed_trees(lt, dt) {
  var i;

  /* build fixed length tree */
  for (i = 0; i < 7; ++i) lt.table[i] = 0;
  lt.table[7] = 24;
  lt.table[8] = 152;
  lt.table[9] = 112;
  for (i = 0; i < 24; ++i) lt.trans[i] = 256 + i;
  for (i = 0; i < 144; ++i) lt.trans[24 + i] = i;
  for (i = 0; i < 8; ++i) lt.trans[24 + 144 + i] = 280 + i;
  for (i = 0; i < 112; ++i) lt.trans[24 + 144 + 8 + i] = 144 + i;

  /* build fixed distance tree */
  for (i = 0; i < 5; ++i) dt.table[i] = 0;
  dt.table[5] = 32;
  for (i = 0; i < 32; ++i) dt.trans[i] = i;
}

/* given an array of code lengths, build a tree */
var offs = new Uint16Array(16);
function tinf_build_tree(t, lengths, off, num) {
  var i, sum;

  /* clear code length count table */
  for (i = 0; i < 16; ++i) t.table[i] = 0;

  /* scan symbol lengths, and sum code length counts */
  for (i = 0; i < num; ++i) t.table[lengths[off + i]]++;
  t.table[0] = 0;

  /* compute offset table for distribution sort */
  for (sum = 0, i = 0; i < 16; ++i) {
    offs[i] = sum;
    sum += t.table[i];
  }

  /* create code->symbol translation table (symbols sorted by code) */
  for (i = 0; i < num; ++i) {
    if (lengths[off + i]) t.trans[offs[lengths[off + i]]++] = i;
  }
}

/* ---------------------- *
 * -- decode functions -- *
 * ---------------------- */

/* get one bit from source stream */
function tinf_getbit(d) {
  /* check if tag is empty */
  if (!d.bitcount--) {
    /* load next tag */
    d.tag = d.source[d.sourceIndex++];
    d.bitcount = 7;
  }

  /* shift bit out of tag */
  var bit = d.tag & 1;
  d.tag >>>= 1;
  return bit;
}

/* read a num bit value from a stream and add base */
function tinf_read_bits(d, num, base) {
  if (!num) return base;
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var val = d.tag & 0xffff >>> 16 - num;
  d.tag >>>= num;
  d.bitcount -= num;
  return val + base;
}

/* given a data stream and a tree, decode a symbol */
function tinf_decode_symbol(d, t) {
  while (d.bitcount < 24) {
    d.tag |= d.source[d.sourceIndex++] << d.bitcount;
    d.bitcount += 8;
  }
  var sum = 0,
    cur = 0,
    len = 0;
  var tag = d.tag;

  /* get more bits while code value is above sum */
  do {
    cur = 2 * cur + (tag & 1);
    tag >>>= 1;
    ++len;
    sum += t.table[len];
    cur -= t.table[len];
  } while (cur >= 0);
  d.tag = tag;
  d.bitcount -= len;
  return t.trans[sum + cur];
}

/* given a data stream, decode dynamic trees from it */
function tinf_decode_trees(d, lt, dt) {
  var hlit, hdist, hclen;
  var i, num, length;

  /* get 5 bits HLIT (257-286) */
  hlit = tinf_read_bits(d, 5, 257);

  /* get 5 bits HDIST (1-32) */
  hdist = tinf_read_bits(d, 5, 1);

  /* get 4 bits HCLEN (4-19) */
  hclen = tinf_read_bits(d, 4, 4);
  for (i = 0; i < 19; ++i) lengths[i] = 0;

  /* read code lengths for code length alphabet */
  for (i = 0; i < hclen; ++i) {
    /* get 3 bits code length (0-7) */
    var clen = tinf_read_bits(d, 3, 0);
    lengths[clcidx[i]] = clen;
  }

  /* build code length tree */
  tinf_build_tree(code_tree, lengths, 0, 19);

  /* decode code lengths for the dynamic trees */
  for (num = 0; num < hlit + hdist;) {
    var sym = tinf_decode_symbol(d, code_tree);
    switch (sym) {
      case 16:
        /* copy previous code length 3-6 times (read 2 bits) */
        var prev = lengths[num - 1];
        for (length = tinf_read_bits(d, 2, 3); length; --length) {
          lengths[num++] = prev;
        }
        break;
      case 17:
        /* repeat code length 0 for 3-10 times (read 3 bits) */
        for (length = tinf_read_bits(d, 3, 3); length; --length) {
          lengths[num++] = 0;
        }
        break;
      case 18:
        /* repeat code length 0 for 11-138 times (read 7 bits) */
        for (length = tinf_read_bits(d, 7, 11); length; --length) {
          lengths[num++] = 0;
        }
        break;
      default:
        /* values 0-15 represent the actual code lengths */
        lengths[num++] = sym;
        break;
    }
  }

  /* build dynamic trees */
  tinf_build_tree(lt, lengths, 0, hlit);
  tinf_build_tree(dt, lengths, hlit, hdist);
}

/* ----------------------------- *
 * -- block inflate functions -- *
 * ----------------------------- */

/* given a stream and two trees, inflate a block of data */
function tinf_inflate_block_data(d, lt, dt) {
  while (1) {
    var sym = tinf_decode_symbol(d, lt);

    /* check for end of block */
    if (sym === 256) {
      return TINF_OK;
    }
    if (sym < 256) {
      d.dest[d.destLen++] = sym;
    } else {
      var length, dist, offs;
      var i;
      sym -= 257;

      /* possibly get more bits from length code */
      length = tinf_read_bits(d, length_bits[sym], length_base[sym]);
      dist = tinf_decode_symbol(d, dt);

      /* possibly get more bits from distance code */
      offs = d.destLen - tinf_read_bits(d, dist_bits[dist], dist_base[dist]);

      /* copy match */
      for (i = offs; i < offs + length; ++i) {
        d.dest[d.destLen++] = d.dest[i];
      }
    }
  }
}

/* inflate an uncompressed block of data */
function tinf_inflate_uncompressed_block(d) {
  var length, invlength;
  var i;

  /* unread from bitbuffer */
  while (d.bitcount > 8) {
    d.sourceIndex--;
    d.bitcount -= 8;
  }

  /* get length */
  length = d.source[d.sourceIndex + 1];
  length = 256 * length + d.source[d.sourceIndex];

  /* get one's complement of length */
  invlength = d.source[d.sourceIndex + 3];
  invlength = 256 * invlength + d.source[d.sourceIndex + 2];

  /* check length */
  if (length !== (~invlength & 0x0000ffff)) return TINF_DATA_ERROR;
  d.sourceIndex += 4;

  /* copy block */
  for (i = length; i; --i) d.dest[d.destLen++] = d.source[d.sourceIndex++];

  /* make sure we start next block on a byte boundary */
  d.bitcount = 0;
  return TINF_OK;
}

/* inflate stream from source to dest */
function tinf_uncompress(source, dest) {
  var d = new Data(source, dest);
  var bfinal, btype, res;
  do {
    /* read final block flag */
    bfinal = tinf_getbit(d);

    /* read block type (2 bits) */
    btype = tinf_read_bits(d, 2, 0);

    /* decompress block */
    switch (btype) {
      case 0:
        /* decompress uncompressed block */
        res = tinf_inflate_uncompressed_block(d);
        break;
      case 1:
        /* decompress block with fixed huffman trees */
        res = tinf_inflate_block_data(d, sltree, sdtree);
        break;
      case 2:
        /* decompress block with dynamic huffman trees */
        tinf_decode_trees(d, d.ltree, d.dtree);
        res = tinf_inflate_block_data(d, d.ltree, d.dtree);
        break;
      default:
        res = TINF_DATA_ERROR;
    }
    if (res !== TINF_OK) throw new Error('Data error');
  } while (!bfinal);
  if (d.destLen < d.dest.length) {
    if (typeof d.dest.slice === 'function') return d.dest.slice(0, d.destLen);else return d.dest.subarray(0, d.destLen);
  }
  return d.dest;
}

/* -------------------- *
 * -- initialization -- *
 * -------------------- */

/* build fixed huffman trees */
tinf_build_fixed_trees(sltree, sdtree);

/* build extra bits and base tables */
tinf_build_bits_base(length_bits, length_base, 4, 3);
tinf_build_bits_base(dist_bits, dist_base, 2, 1);

/* fix a special case */
length_bits[28] = 0;
length_base[28] = 258;
module.exports = tinf_uncompress;

/***/ }),

/***/ "./node_modules/twgl.js/dist/4.x/twgl-full.module.js":
/*!***********************************************************!*\
  !*** ./node_modules/twgl.js/dist/4.x/twgl-full.module.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   addExtensionsToContext: () => (/* binding */ addExtensionsToContext),
/* harmony export */   attributes: () => (/* binding */ attributes),
/* harmony export */   bindFramebufferInfo: () => (/* binding */ bindFramebufferInfo),
/* harmony export */   bindTransformFeedbackInfo: () => (/* binding */ bindTransformFeedbackInfo),
/* harmony export */   bindUniformBlock: () => (/* binding */ bindUniformBlock),
/* harmony export */   canFilter: () => (/* binding */ canFilter),
/* harmony export */   canGenerateMipmap: () => (/* binding */ canGenerateMipmap),
/* harmony export */   createAttribsFromArrays: () => (/* binding */ createAttribsFromArrays),
/* harmony export */   createAttributeSetters: () => (/* binding */ createAttributeSetters),
/* harmony export */   createBufferFromArray: () => (/* binding */ createBufferFromArray),
/* harmony export */   createBufferFromTypedArray: () => (/* binding */ createBufferFromTypedArray),
/* harmony export */   createBufferInfoFromArrays: () => (/* binding */ createBufferInfoFromArrays),
/* harmony export */   createBuffersFromArrays: () => (/* binding */ createBuffersFromArrays),
/* harmony export */   createFramebufferInfo: () => (/* binding */ createFramebufferInfo),
/* harmony export */   createProgram: () => (/* binding */ createProgram),
/* harmony export */   createProgramAsync: () => (/* binding */ createProgramAsync),
/* harmony export */   createProgramFromScripts: () => (/* binding */ createProgramFromScripts),
/* harmony export */   createProgramFromSources: () => (/* binding */ createProgramFromSources),
/* harmony export */   createProgramInfo: () => (/* binding */ createProgramInfo),
/* harmony export */   createProgramInfoAsync: () => (/* binding */ createProgramInfoAsync),
/* harmony export */   createProgramInfoFromProgram: () => (/* binding */ createProgramInfoFromProgram),
/* harmony export */   createSampler: () => (/* binding */ createSampler),
/* harmony export */   createSamplers: () => (/* binding */ createSamplers),
/* harmony export */   createTexture: () => (/* binding */ createTexture),
/* harmony export */   createTextures: () => (/* binding */ createTextures),
/* harmony export */   createTransformFeedback: () => (/* binding */ createTransformFeedback),
/* harmony export */   createTransformFeedbackInfo: () => (/* binding */ createTransformFeedbackInfo),
/* harmony export */   createUniformBlockInfo: () => (/* binding */ createUniformBlockInfo),
/* harmony export */   createUniformBlockInfoFromProgram: () => (/* binding */ createUniformBlockInfoFromProgram),
/* harmony export */   createUniformBlockSpecFromProgram: () => (/* binding */ createUniformBlockSpecFromProgram),
/* harmony export */   createUniformSetters: () => (/* binding */ createUniformSetters),
/* harmony export */   createVAOAndSetAttributes: () => (/* binding */ createVAOAndSetAttributes),
/* harmony export */   createVAOFromBufferInfo: () => (/* binding */ createVAOFromBufferInfo),
/* harmony export */   createVertexArrayInfo: () => (/* binding */ createVertexArrayInfo),
/* harmony export */   draw: () => (/* binding */ draw),
/* harmony export */   drawBufferInfo: () => (/* binding */ drawBufferInfo),
/* harmony export */   drawObjectList: () => (/* binding */ drawObjectList),
/* harmony export */   framebuffers: () => (/* binding */ framebuffers),
/* harmony export */   getArray_: () => (/* binding */ getArray),
/* harmony export */   getBytesPerElementForInternalFormat: () => (/* binding */ getBytesPerElementForInternalFormat),
/* harmony export */   getContext: () => (/* binding */ getContext),
/* harmony export */   getFormatAndTypeForInternalFormat: () => (/* binding */ getFormatAndTypeForInternalFormat),
/* harmony export */   getGLTypeForTypedArray: () => (/* binding */ getGLTypeForTypedArray),
/* harmony export */   getGLTypeForTypedArrayType: () => (/* binding */ getGLTypeForTypedArrayType),
/* harmony export */   getNumComponentsForFormat: () => (/* binding */ getNumComponentsForFormat),
/* harmony export */   getNumComponents_: () => (/* binding */ getNumComponents),
/* harmony export */   getTypedArrayTypeForGLType: () => (/* binding */ getTypedArrayTypeForGLType),
/* harmony export */   getWebGLContext: () => (/* binding */ getWebGLContext),
/* harmony export */   glEnumToString: () => (/* binding */ glEnumToString),
/* harmony export */   isArrayBuffer: () => (/* binding */ isArrayBuffer),
/* harmony export */   isWebGL1: () => (/* binding */ isWebGL1),
/* harmony export */   isWebGL2: () => (/* binding */ isWebGL2),
/* harmony export */   loadTextureFromUrl: () => (/* binding */ loadTextureFromUrl),
/* harmony export */   m4: () => (/* binding */ m4),
/* harmony export */   primitives: () => (/* binding */ primitives),
/* harmony export */   programs: () => (/* binding */ programs),
/* harmony export */   resizeCanvasToDisplaySize: () => (/* binding */ resizeCanvasToDisplaySize),
/* harmony export */   resizeFramebufferInfo: () => (/* binding */ resizeFramebufferInfo),
/* harmony export */   resizeTexture: () => (/* binding */ resizeTexture),
/* harmony export */   setAttribInfoBufferFromArray: () => (/* binding */ setAttribInfoBufferFromArray),
/* harmony export */   setAttributeDefaults_: () => (/* binding */ setDefaults),
/* harmony export */   setAttributePrefix: () => (/* binding */ setAttributePrefix),
/* harmony export */   setAttributes: () => (/* binding */ setAttributes),
/* harmony export */   setBlockUniforms: () => (/* binding */ setBlockUniforms),
/* harmony export */   setBuffersAndAttributes: () => (/* binding */ setBuffersAndAttributes),
/* harmony export */   setDefaultTextureColor: () => (/* binding */ setDefaultTextureColor),
/* harmony export */   setDefaults: () => (/* binding */ setDefaults$2),
/* harmony export */   setEmptyTexture: () => (/* binding */ setEmptyTexture),
/* harmony export */   setSamplerParameters: () => (/* binding */ setSamplerParameters),
/* harmony export */   setTextureDefaults_: () => (/* binding */ setDefaults$1),
/* harmony export */   setTextureFilteringForSize: () => (/* binding */ setTextureFilteringForSize),
/* harmony export */   setTextureFromArray: () => (/* binding */ setTextureFromArray),
/* harmony export */   setTextureFromElement: () => (/* binding */ setTextureFromElement),
/* harmony export */   setTextureParameters: () => (/* binding */ setTextureParameters),
/* harmony export */   setUniformBlock: () => (/* binding */ setUniformBlock),
/* harmony export */   setUniforms: () => (/* binding */ setUniforms),
/* harmony export */   setUniformsAndBindTextures: () => (/* binding */ setUniformsAndBindTextures),
/* harmony export */   textures: () => (/* binding */ textures),
/* harmony export */   typedarrays: () => (/* binding */ typedarrays),
/* harmony export */   utils: () => (/* binding */ utils),
/* harmony export */   v3: () => (/* binding */ v3),
/* harmony export */   vertexArrays: () => (/* binding */ vertexArrays)
/* harmony export */ });
/* @license twgl.js 4.24.0 Copyright (c) 2015, Gregg Tavares All Rights Reserved.
Available via the MIT license.
see: http://github.com/greggman/twgl.js for details */
/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 *
 * Vec3 math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new Vec3. In other words you can do this
 *
 *     var v = v3.cross(v1, v2);  // Creates a new Vec3 with the cross product of v1 x v2.
 *
 * or
 *
 *     var v = v3.create();
 *     v3.cross(v1, v2, v);  // Puts the cross product of v1 x v2 in v
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any vector as the destination. So for example
 *
 *     v3.cross(v1, v2, v1);  // Puts the cross product of v1 x v2 in v1
 *
 * @module twgl/v3
 */

let VecType = Float32Array;

/**
 * A JavaScript array with 3 values or a Float32Array with 3 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/v3.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Vec3
 * @memberOf module:twgl/v3
 */

/**
 * Sets the type this library creates for a Vec3
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Vec3
 * @memberOf module:twgl/v3
 */
function setDefaultType(ctor) {
  const oldType = VecType;
  VecType = ctor;
  return oldType;
}

/**
 * Creates a vec3; may be called with x, y, z to set initial values.
 * @param {number} [x] Initial x value.
 * @param {number} [y] Initial y value.
 * @param {number} [z] Initial z value.
 * @return {module:twgl/v3.Vec3} the created vector
 * @memberOf module:twgl/v3
 */
function create(x, y, z) {
  const dst = new VecType(3);
  if (x) {
    dst[0] = x;
  }
  if (y) {
    dst[1] = y;
  }
  if (z) {
    dst[2] = z;
  }
  return dst;
}

/**
 * Adds two vectors; assumes a and b have the same dimension.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector tha tis the sum of a and b.
 * @memberOf module:twgl/v3
 */
function add(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + b[0];
  dst[1] = a[1] + b[1];
  dst[2] = a[2] + b[2];
  return dst;
}

/**
 * Subtracts two vectors.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A vector that is the difference of a and b.
 * @memberOf module:twgl/v3
 */
function subtract(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] - b[0];
  dst[1] = a[1] - b[1];
  dst[2] = a[2] - b[2];
  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {number} t Interpolation coefficient.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerp(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t * (b[0] - a[0]);
  dst[1] = a[1] + t * (b[1] - a[1]);
  dst[2] = a[2] + t * (b[2] - a[2]);
  return dst;
}

/**
 * Performs linear interpolation on two vectors.
 * Given vectors a and b and interpolation coefficient vector t, returns
 * a + t * (b - a).
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} t Interpolation coefficients vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} the linear interpolated result.
 * @memberOf module:twgl/v3
 */
function lerpV(a, b, t, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] + t[0] * (b[0] - a[0]);
  dst[1] = a[1] + t[1] * (b[1] - a[1]);
  dst[2] = a[2] + t[2] * (b[2] - a[2]);
  return dst;
}

/**
 * Return max values of two vectors.
 * Given vectors a and b returns
 * [max(a[0], b[0]), max(a[1], b[1]), max(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The max components vector.
 * @memberOf module:twgl/v3
 */
function max(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.max(a[0], b[0]);
  dst[1] = Math.max(a[1], b[1]);
  dst[2] = Math.max(a[2], b[2]);
  return dst;
}

/**
 * Return min values of two vectors.
 * Given vectors a and b returns
 * [min(a[0], b[0]), min(a[1], b[1]), min(a[2], b[2])].
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The min components vector.
 * @memberOf module:twgl/v3
 */
function min(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = Math.min(a[0], b[0]);
  dst[1] = Math.min(a[1], b[1]);
  dst[2] = Math.min(a[2], b[2]);
  return dst;
}

/**
 * Multiplies a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function mulScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] * k;
  dst[1] = v[1] * k;
  dst[2] = v[2] * k;
  return dst;
}

/**
 * Divides a vector by a scalar.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {number} k The scalar.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The scaled vector.
 * @memberOf module:twgl/v3
 */
function divScalar(v, k, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0] / k;
  dst[1] = v[1] / k;
  dst[2] = v[2] / k;
  return dst;
}

/**
 * Computes the cross product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of a cross b.
 * @memberOf module:twgl/v3
 */
function cross(a, b, dst) {
  dst = dst || new VecType(3);
  const t1 = a[2] * b[0] - a[0] * b[2];
  const t2 = a[0] * b[1] - a[1] * b[0];
  dst[0] = a[1] * b[2] - a[2] * b[1];
  dst[1] = t1;
  dst[2] = t2;
  return dst;
}

/**
 * Computes the dot product of two vectors; assumes both vectors have
 * three entries.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @return {number} dot product
 * @memberOf module:twgl/v3
 */
function dot(a, b) {
  return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];
}

/**
 * Computes the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} length of vector.
 * @memberOf module:twgl/v3
 */
function length$1(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2]);
}

/**
 * Computes the square of the length of vector
 * @param {module:twgl/v3.Vec3} v vector.
 * @return {number} square of the length of vector.
 * @memberOf module:twgl/v3
 */
function lengthSq(v) {
  return v[0] * v[0] + v[1] * v[1] + v[2] * v[2];
}

/**
 * Computes the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} distance between a and b
 * @memberOf module:twgl/v3
 */
function distance(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return Math.sqrt(dx * dx + dy * dy + dz * dz);
}

/**
 * Computes the square of the distance between 2 points
 * @param {module:twgl/v3.Vec3} a vector.
 * @param {module:twgl/v3.Vec3} b vector.
 * @return {number} square of the distance between a and b
 * @memberOf module:twgl/v3
 */
function distanceSq(a, b) {
  const dx = a[0] - b[0];
  const dy = a[1] - b[1];
  const dz = a[2] - b[2];
  return dx * dx + dy * dy + dz * dz;
}

/**
 * Divides a vector by its Euclidean length and returns the quotient.
 * @param {module:twgl/v3.Vec3} a The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The normalized vector.
 * @memberOf module:twgl/v3
 */
function normalize(a, dst) {
  dst = dst || new VecType(3);
  const lenSq = a[0] * a[0] + a[1] * a[1] + a[2] * a[2];
  const len = Math.sqrt(lenSq);
  if (len > 0.00001) {
    dst[0] = a[0] / len;
    dst[1] = a[1] / len;
    dst[2] = a[2] / len;
  } else {
    dst[0] = 0;
    dst[1] = 0;
    dst[2] = 0;
  }
  return dst;
}

/**
 * Negates a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} -v.
 * @memberOf module:twgl/v3
 */
function negate(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = -v[0];
  dst[1] = -v[1];
  dst[2] = -v[2];
  return dst;
}

/**
 * Copies a vector.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} A copy of v.
 * @memberOf module:twgl/v3
 */
function copy(v, dst) {
  dst = dst || new VecType(3);
  dst[0] = v[0];
  dst[1] = v[1];
  dst[2] = v[2];
  return dst;
}

/**
 * Multiplies a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of products of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function multiply(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] * b[0];
  dst[1] = a[1] * b[1];
  dst[2] = a[2] * b[2];
  return dst;
}

/**
 * Divides a vector by another vector (component-wise); assumes a and
 * b have the same length.
 * @param {module:twgl/v3.Vec3} a Operand vector.
 * @param {module:twgl/v3.Vec3} b Operand vector.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not new one is created.
 * @return {module:twgl/v3.Vec3} The vector of quotients of entries of a and
 *     b.
 * @memberOf module:twgl/v3
 */
function divide(a, b, dst) {
  dst = dst || new VecType(3);
  dst[0] = a[0] / b[0];
  dst[1] = a[1] / b[1];
  dst[2] = a[2] / b[2];
  return dst;
}
var v3 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  add: add,
  copy: copy,
  create: create,
  cross: cross,
  distance: distance,
  distanceSq: distanceSq,
  divide: divide,
  divScalar: divScalar,
  dot: dot,
  lerp: lerp,
  lerpV: lerpV,
  length: length$1,
  lengthSq: lengthSq,
  max: max,
  min: min,
  mulScalar: mulScalar,
  multiply: multiply,
  negate: negate,
  normalize: normalize,
  setDefaultType: setDefaultType,
  subtract: subtract
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * 4x4 Matrix math math functions.
 *
 * Almost all functions take an optional `dst` argument. If it is not passed in the
 * functions will create a new matrix. In other words you can do this
 *
 *     const mat = m4.translation([1, 2, 3]);  // Creates a new translation matrix
 *
 * or
 *
 *     const mat = m4.create();
 *     m4.translation([1, 2, 3], mat);  // Puts translation matrix in mat.
 *
 * The first style is often easier but depending on where it's used it generates garbage where
 * as there is almost never allocation with the second style.
 *
 * It is always save to pass any matrix as the destination. So for example
 *
 *     const mat = m4.identity();
 *     const trans = m4.translation([1, 2, 3]);
 *     m4.multiply(mat, trans, mat);  // Multiplies mat * trans and puts result in mat.
 *
 * @module twgl/m4
 */
let MatType = Float32Array;

/**
 * A JavaScript array with 16 values or a Float32Array with 16 values.
 * When created by the library will create the default type which is `Float32Array`
 * but can be set by calling {@link module:twgl/m4.setDefaultType}.
 * @typedef {(number[]|Float32Array)} Mat4
 * @memberOf module:twgl/m4
 */

/**
 * Sets the type this library creates for a Mat4
 * @param {constructor} ctor the constructor for the type. Either `Float32Array` or `Array`
 * @return {constructor} previous constructor for Mat4
 * @memberOf module:twgl/m4
 */
function setDefaultType$1(ctor) {
  const oldType = MatType;
  MatType = ctor;
  return oldType;
}

/**
 * Negates a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} -m.
 * @memberOf module:twgl/m4
 */
function negate$1(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = -m[0];
  dst[1] = -m[1];
  dst[2] = -m[2];
  dst[3] = -m[3];
  dst[4] = -m[4];
  dst[5] = -m[5];
  dst[6] = -m[6];
  dst[7] = -m[7];
  dst[8] = -m[8];
  dst[9] = -m[9];
  dst[10] = -m[10];
  dst[11] = -m[11];
  dst[12] = -m[12];
  dst[13] = -m[13];
  dst[14] = -m[14];
  dst[15] = -m[15];
  return dst;
}

/**
 * Creates a matrix.
 * @return {module:twgl/m4.Mat4} A new matrix.
 * @memberOf module:twgl/m4
 */
function create$1() {
  return new MatType(16).fill(0);
}

/**
 * Copies a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] The matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A copy of m.
 * @memberOf module:twgl/m4
 */
function copy$1(m, dst) {
  dst = dst || new MatType(16);
  dst[0] = m[0];
  dst[1] = m[1];
  dst[2] = m[2];
  dst[3] = m[3];
  dst[4] = m[4];
  dst[5] = m[5];
  dst[6] = m[6];
  dst[7] = m[7];
  dst[8] = m[8];
  dst[9] = m[9];
  dst[10] = m[10];
  dst[11] = m[11];
  dst[12] = m[12];
  dst[13] = m[13];
  dst[14] = m[14];
  dst[15] = m[15];
  return dst;
}

/**
 * Creates an n-by-n identity matrix.
 *
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} An n-by-n identity matrix.
 * @memberOf module:twgl/m4
 */
function identity(dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Takes the transpose of a matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The transpose of m.
 * @memberOf module:twgl/m4
 */
function transpose(m, dst) {
  dst = dst || new MatType(16);
  if (dst === m) {
    let t;
    t = m[1];
    m[1] = m[4];
    m[4] = t;
    t = m[2];
    m[2] = m[8];
    m[8] = t;
    t = m[3];
    m[3] = m[12];
    m[12] = t;
    t = m[6];
    m[6] = m[9];
    m[9] = t;
    t = m[7];
    m[7] = m[13];
    m[13] = t;
    t = m[11];
    m[11] = m[14];
    m[14] = t;
    return dst;
  }
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  dst[0] = m00;
  dst[1] = m10;
  dst[2] = m20;
  dst[3] = m30;
  dst[4] = m01;
  dst[5] = m11;
  dst[6] = m21;
  dst[7] = m31;
  dst[8] = m02;
  dst[9] = m12;
  dst[10] = m22;
  dst[11] = m32;
  dst[12] = m03;
  dst[13] = m13;
  dst[14] = m23;
  dst[15] = m33;
  return dst;
}

/**
 * Computes the inverse of a 4-by-4 matrix.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The inverse of m.
 * @memberOf module:twgl/m4
 */
function inverse(m, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  const tmp_0 = m22 * m33;
  const tmp_1 = m32 * m23;
  const tmp_2 = m12 * m33;
  const tmp_3 = m32 * m13;
  const tmp_4 = m12 * m23;
  const tmp_5 = m22 * m13;
  const tmp_6 = m02 * m33;
  const tmp_7 = m32 * m03;
  const tmp_8 = m02 * m23;
  const tmp_9 = m22 * m03;
  const tmp_10 = m02 * m13;
  const tmp_11 = m12 * m03;
  const tmp_12 = m20 * m31;
  const tmp_13 = m30 * m21;
  const tmp_14 = m10 * m31;
  const tmp_15 = m30 * m11;
  const tmp_16 = m10 * m21;
  const tmp_17 = m20 * m11;
  const tmp_18 = m00 * m31;
  const tmp_19 = m30 * m01;
  const tmp_20 = m00 * m21;
  const tmp_21 = m20 * m01;
  const tmp_22 = m00 * m11;
  const tmp_23 = m10 * m01;
  const t0 = tmp_0 * m11 + tmp_3 * m21 + tmp_4 * m31 - (tmp_1 * m11 + tmp_2 * m21 + tmp_5 * m31);
  const t1 = tmp_1 * m01 + tmp_6 * m21 + tmp_9 * m31 - (tmp_0 * m01 + tmp_7 * m21 + tmp_8 * m31);
  const t2 = tmp_2 * m01 + tmp_7 * m11 + tmp_10 * m31 - (tmp_3 * m01 + tmp_6 * m11 + tmp_11 * m31);
  const t3 = tmp_5 * m01 + tmp_8 * m11 + tmp_11 * m21 - (tmp_4 * m01 + tmp_9 * m11 + tmp_10 * m21);
  const d = 1.0 / (m00 * t0 + m10 * t1 + m20 * t2 + m30 * t3);
  dst[0] = d * t0;
  dst[1] = d * t1;
  dst[2] = d * t2;
  dst[3] = d * t3;
  dst[4] = d * (tmp_1 * m10 + tmp_2 * m20 + tmp_5 * m30 - (tmp_0 * m10 + tmp_3 * m20 + tmp_4 * m30));
  dst[5] = d * (tmp_0 * m00 + tmp_7 * m20 + tmp_8 * m30 - (tmp_1 * m00 + tmp_6 * m20 + tmp_9 * m30));
  dst[6] = d * (tmp_3 * m00 + tmp_6 * m10 + tmp_11 * m30 - (tmp_2 * m00 + tmp_7 * m10 + tmp_10 * m30));
  dst[7] = d * (tmp_4 * m00 + tmp_9 * m10 + tmp_10 * m20 - (tmp_5 * m00 + tmp_8 * m10 + tmp_11 * m20));
  dst[8] = d * (tmp_12 * m13 + tmp_15 * m23 + tmp_16 * m33 - (tmp_13 * m13 + tmp_14 * m23 + tmp_17 * m33));
  dst[9] = d * (tmp_13 * m03 + tmp_18 * m23 + tmp_21 * m33 - (tmp_12 * m03 + tmp_19 * m23 + tmp_20 * m33));
  dst[10] = d * (tmp_14 * m03 + tmp_19 * m13 + tmp_22 * m33 - (tmp_15 * m03 + tmp_18 * m13 + tmp_23 * m33));
  dst[11] = d * (tmp_17 * m03 + tmp_20 * m13 + tmp_23 * m23 - (tmp_16 * m03 + tmp_21 * m13 + tmp_22 * m23));
  dst[12] = d * (tmp_14 * m22 + tmp_17 * m32 + tmp_13 * m12 - (tmp_16 * m32 + tmp_12 * m12 + tmp_15 * m22));
  dst[13] = d * (tmp_20 * m32 + tmp_12 * m02 + tmp_19 * m22 - (tmp_18 * m22 + tmp_21 * m32 + tmp_13 * m02));
  dst[14] = d * (tmp_18 * m12 + tmp_23 * m32 + tmp_15 * m02 - (tmp_22 * m32 + tmp_14 * m02 + tmp_19 * m12));
  dst[15] = d * (tmp_22 * m22 + tmp_16 * m02 + tmp_21 * m12 - (tmp_20 * m12 + tmp_23 * m22 + tmp_17 * m02));
  return dst;
}

/**
 * Multiplies two 4-by-4 matrices with a on the left and b on the right
 * @param {module:twgl/m4.Mat4} a The matrix on the left.
 * @param {module:twgl/m4.Mat4} b The matrix on the right.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix product of a and b.
 * @memberOf module:twgl/m4
 */
function multiply$1(a, b, dst) {
  dst = dst || new MatType(16);
  const a00 = a[0];
  const a01 = a[1];
  const a02 = a[2];
  const a03 = a[3];
  const a10 = a[4 + 0];
  const a11 = a[4 + 1];
  const a12 = a[4 + 2];
  const a13 = a[4 + 3];
  const a20 = a[8 + 0];
  const a21 = a[8 + 1];
  const a22 = a[8 + 2];
  const a23 = a[8 + 3];
  const a30 = a[12 + 0];
  const a31 = a[12 + 1];
  const a32 = a[12 + 2];
  const a33 = a[12 + 3];
  const b00 = b[0];
  const b01 = b[1];
  const b02 = b[2];
  const b03 = b[3];
  const b10 = b[4 + 0];
  const b11 = b[4 + 1];
  const b12 = b[4 + 2];
  const b13 = b[4 + 3];
  const b20 = b[8 + 0];
  const b21 = b[8 + 1];
  const b22 = b[8 + 2];
  const b23 = b[8 + 3];
  const b30 = b[12 + 0];
  const b31 = b[12 + 1];
  const b32 = b[12 + 2];
  const b33 = b[12 + 3];
  dst[0] = a00 * b00 + a10 * b01 + a20 * b02 + a30 * b03;
  dst[1] = a01 * b00 + a11 * b01 + a21 * b02 + a31 * b03;
  dst[2] = a02 * b00 + a12 * b01 + a22 * b02 + a32 * b03;
  dst[3] = a03 * b00 + a13 * b01 + a23 * b02 + a33 * b03;
  dst[4] = a00 * b10 + a10 * b11 + a20 * b12 + a30 * b13;
  dst[5] = a01 * b10 + a11 * b11 + a21 * b12 + a31 * b13;
  dst[6] = a02 * b10 + a12 * b11 + a22 * b12 + a32 * b13;
  dst[7] = a03 * b10 + a13 * b11 + a23 * b12 + a33 * b13;
  dst[8] = a00 * b20 + a10 * b21 + a20 * b22 + a30 * b23;
  dst[9] = a01 * b20 + a11 * b21 + a21 * b22 + a31 * b23;
  dst[10] = a02 * b20 + a12 * b21 + a22 * b22 + a32 * b23;
  dst[11] = a03 * b20 + a13 * b21 + a23 * b22 + a33 * b23;
  dst[12] = a00 * b30 + a10 * b31 + a20 * b32 + a30 * b33;
  dst[13] = a01 * b30 + a11 * b31 + a21 * b32 + a31 * b33;
  dst[14] = a02 * b30 + a12 * b31 + a22 * b32 + a32 * b33;
  dst[15] = a03 * b30 + a13 * b31 + a23 * b32 + a33 * b33;
  return dst;
}

/**
 * Sets the translation component of a 4-by-4 matrix to the given
 * vector.
 * @param {module:twgl/m4.Mat4} a The matrix.
 * @param {module:twgl/v3.Vec3} v The vector.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with translation set.
 * @memberOf module:twgl/m4
 */
function setTranslation(a, v, dst) {
  dst = dst || identity();
  if (a !== dst) {
    dst[0] = a[0];
    dst[1] = a[1];
    dst[2] = a[2];
    dst[3] = a[3];
    dst[4] = a[4];
    dst[5] = a[5];
    dst[6] = a[6];
    dst[7] = a[7];
    dst[8] = a[8];
    dst[9] = a[9];
    dst[10] = a[10];
    dst[11] = a[11];
  }
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Returns the translation component of a 4-by-4 matrix as a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} [dst] vector to hold result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The translation component of m.
 * @memberOf module:twgl/m4
 */
function getTranslation(m, dst) {
  dst = dst || create();
  dst[0] = m[12];
  dst[1] = m[13];
  dst[2] = m[14];
  return dst;
}

/**
 * Returns an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} axis The axis 0 = x, 1 = y, 2 = z;
 * @return {module:twgl/v3.Vec3} [dst] vector.
 * @return {module:twgl/v3.Vec3} The axis component of m.
 * @memberOf module:twgl/m4
 */
function getAxis(m, axis, dst) {
  dst = dst || create();
  const off = axis * 4;
  dst[0] = m[off + 0];
  dst[1] = m[off + 1];
  dst[2] = m[off + 2];
  return dst;
}

/**
 * Sets an axis of a 4x4 matrix as a vector with 3 entries
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v the axis vector
 * @param {number} axis The axis  0 = x, 1 = y, 2 = z;
 * @param {module:twgl/m4.Mat4} [dst] The matrix to set. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The matrix with axis set.
 * @memberOf module:twgl/m4
 */
function setAxis(a, v, axis, dst) {
  if (dst !== a) {
    dst = copy$1(a, dst);
  }
  const off = axis * 4;
  dst[off + 0] = v[0];
  dst[off + 1] = v[1];
  dst[off + 2] = v[2];
  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the angular height
 * of the frustum, the aspect ratio, and the near and far clipping planes.  The
 * arguments define a frustum extending in the negative z direction.  The given
 * angle is the vertical angle of the frustum, and the horizontal angle is
 * determined to produce the given aspect ratio.  The arguments near and far are
 * the distances to the near and far clipping planes.  Note that near and far
 * are not z coordinates, but rather they are distances along the negative
 * z-axis.  The matrix generated sends the viewing frustum to the unit box.
 * We assume a unit box extending from -1 to 1 in the x and y dimensions and
 * from 0 to 1 in the z dimension.
 * @param {number} fieldOfViewYInRadians The camera angle from top to bottom (in radians).
 * @param {number} aspect The aspect ratio width / height.
 * @param {number} zNear The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} zFar The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function perspective(fieldOfViewYInRadians, aspect, zNear, zFar, dst) {
  dst = dst || new MatType(16);
  const f = Math.tan(Math.PI * 0.5 - 0.5 * fieldOfViewYInRadians);
  const rangeInv = 1.0 / (zNear - zFar);
  dst[0] = f / aspect;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = f;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = (zNear + zFar) * rangeInv;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = zNear * zFar * rangeInv * 2;
  dst[15] = 0;
  return dst;
}

/**
 * Computes a 4-by-4 orthogonal transformation matrix given the left, right,
 * bottom, and top dimensions of the near clipping plane as well as the
 * near and far clipping plane distances.
 * @param {number} left Left side of the near clipping plane viewport.
 * @param {number} right Right side of the near clipping plane viewport.
 * @param {number} bottom Bottom of the near clipping plane viewport.
 * @param {number} top Top of the near clipping plane viewport.
 * @param {number} near The depth (negative z coordinate)
 *     of the near clipping plane.
 * @param {number} far The depth (negative z coordinate)
 *     of the far clipping plane.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective matrix.
 * @memberOf module:twgl/m4
 */
function ortho(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  dst[0] = 2 / (right - left);
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 / (top - bottom);
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 2 / (near - far);
  dst[11] = 0;
  dst[12] = (right + left) / (left - right);
  dst[13] = (top + bottom) / (bottom - top);
  dst[14] = (far + near) / (near - far);
  dst[15] = 1;
  return dst;
}

/**
 * Computes a 4-by-4 perspective transformation matrix given the left, right,
 * top, bottom, near and far clipping planes. The arguments define a frustum
 * extending in the negative z direction. The arguments near and far are the
 * distances to the near and far clipping planes. Note that near and far are not
 * z coordinates, but rather they are distances along the negative z-axis. The
 * matrix generated sends the viewing frustum to the unit box. We assume a unit
 * box extending from -1 to 1 in the x and y dimensions and from 0 to 1 in the z
 * dimension.
 * @param {number} left The x coordinate of the left plane of the box.
 * @param {number} right The x coordinate of the right plane of the box.
 * @param {number} bottom The y coordinate of the bottom plane of the box.
 * @param {number} top The y coordinate of the right plane of the box.
 * @param {number} near The negative z coordinate of the near plane of the box.
 * @param {number} far The negative z coordinate of the far plane of the box.
 * @param {module:twgl/m4.Mat4} [dst] Output matrix. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The perspective projection matrix.
 * @memberOf module:twgl/m4
 */
function frustum(left, right, bottom, top, near, far, dst) {
  dst = dst || new MatType(16);
  const dx = right - left;
  const dy = top - bottom;
  const dz = near - far;
  dst[0] = 2 * near / dx;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 2 * near / dy;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = (left + right) / dx;
  dst[9] = (top + bottom) / dy;
  dst[10] = far / dz;
  dst[11] = -1;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = near * far / dz;
  dst[15] = 0;
  return dst;
}
let xAxis;
let yAxis;
let zAxis;

/**
 * Computes a 4-by-4 look-at transformation.
 *
 * This is a matrix which positions the camera itself. If you want
 * a view matrix (a matrix which moves things in front of the camera)
 * take the inverse of this.
 *
 * @param {module:twgl/v3.Vec3} eye The position of the eye.
 * @param {module:twgl/v3.Vec3} target The position meant to be viewed.
 * @param {module:twgl/v3.Vec3} up A vector pointing up.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The look-at matrix.
 * @memberOf module:twgl/m4
 */
function lookAt(eye, target, up, dst) {
  dst = dst || new MatType(16);
  xAxis = xAxis || create();
  yAxis = yAxis || create();
  zAxis = zAxis || create();
  normalize(subtract(eye, target, zAxis), zAxis);
  normalize(cross(up, zAxis, xAxis), xAxis);
  normalize(cross(zAxis, xAxis, yAxis), yAxis);
  dst[0] = xAxis[0];
  dst[1] = xAxis[1];
  dst[2] = xAxis[2];
  dst[3] = 0;
  dst[4] = yAxis[0];
  dst[5] = yAxis[1];
  dst[6] = yAxis[2];
  dst[7] = 0;
  dst[8] = zAxis[0];
  dst[9] = zAxis[1];
  dst[10] = zAxis[2];
  dst[11] = 0;
  dst[12] = eye[0];
  dst[13] = eye[1];
  dst[14] = eye[2];
  dst[15] = 1;
  return dst;
}

/**
 * Creates a 4-by-4 matrix which translates by the given vector v.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translation matrix.
 * @memberOf module:twgl/m4
 */
function translation(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = v[0];
  dst[13] = v[1];
  dst[14] = v[2];
  dst[15] = 1;
  return dst;
}

/**
 * Translates the given 4-by-4 matrix by the given vector v.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The vector by
 *     which to translate.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The translated matrix.
 * @memberOf module:twgl/m4
 */
function translate(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const m30 = m[3 * 4 + 0];
  const m31 = m[3 * 4 + 1];
  const m32 = m[3 * 4 + 2];
  const m33 = m[3 * 4 + 3];
  if (m !== dst) {
    dst[0] = m00;
    dst[1] = m01;
    dst[2] = m02;
    dst[3] = m03;
    dst[4] = m10;
    dst[5] = m11;
    dst[6] = m12;
    dst[7] = m13;
    dst[8] = m20;
    dst[9] = m21;
    dst[10] = m22;
    dst[11] = m23;
  }
  dst[12] = m00 * v0 + m10 * v1 + m20 * v2 + m30;
  dst[13] = m01 * v0 + m11 * v1 + m21 * v2 + m31;
  dst[14] = m02 * v0 + m12 * v1 + m22 * v2 + m32;
  dst[15] = m03 * v0 + m13 * v1 + m23 * v2 + m33;
  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the x-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationX(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = 1;
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = c;
  dst[6] = s;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = -s;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the x-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateX(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[4] = c * m10 + s * m20;
  dst[5] = c * m11 + s * m21;
  dst[6] = c * m12 + s * m22;
  dst[7] = c * m13 + s * m23;
  dst[8] = c * m20 - s * m10;
  dst[9] = c * m21 - s * m11;
  dst[10] = c * m22 - s * m12;
  dst[11] = c * m23 - s * m13;
  if (m !== dst) {
    dst[0] = m[0];
    dst[1] = m[1];
    dst[2] = m[2];
    dst[3] = m[3];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the y-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationY(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = 0;
  dst[2] = -s;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = 1;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = s;
  dst[9] = 0;
  dst[10] = c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the y-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateY(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m20 = m[2 * 4 + 0];
  const m21 = m[2 * 4 + 1];
  const m22 = m[2 * 4 + 2];
  const m23 = m[2 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 - s * m20;
  dst[1] = c * m01 - s * m21;
  dst[2] = c * m02 - s * m22;
  dst[3] = c * m03 - s * m23;
  dst[8] = c * m20 + s * m00;
  dst[9] = c * m21 + s * m01;
  dst[10] = c * m22 + s * m02;
  dst[11] = c * m23 + s * m03;
  if (m !== dst) {
    dst[4] = m[4];
    dst[5] = m[5];
    dst[6] = m[6];
    dst[7] = m[7];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the z-axis by the given angle.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotation matrix.
 * @memberOf module:twgl/m4
 */
function rotationZ(angleInRadians, dst) {
  dst = dst || new MatType(16);
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c;
  dst[1] = s;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = -s;
  dst[5] = c;
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = 1;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the z-axis by the given
 * angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function rotateZ(m, angleInRadians, dst) {
  dst = dst || new MatType(16);
  const m00 = m[0 * 4 + 0];
  const m01 = m[0 * 4 + 1];
  const m02 = m[0 * 4 + 2];
  const m03 = m[0 * 4 + 3];
  const m10 = m[1 * 4 + 0];
  const m11 = m[1 * 4 + 1];
  const m12 = m[1 * 4 + 2];
  const m13 = m[1 * 4 + 3];
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  dst[0] = c * m00 + s * m10;
  dst[1] = c * m01 + s * m11;
  dst[2] = c * m02 + s * m12;
  dst[3] = c * m03 + s * m13;
  dst[4] = c * m10 - s * m00;
  dst[5] = c * m11 - s * m01;
  dst[6] = c * m12 - s * m02;
  dst[7] = c * m13 - s * m03;
  if (m !== dst) {
    dst[8] = m[8];
    dst[9] = m[9];
    dst[10] = m[10];
    dst[11] = m[11];
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}

/**
 * Creates a 4-by-4 matrix which rotates around the given axis by the given
 * angle.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} A matrix which rotates angle radians
 *     around the axis.
 * @memberOf module:twgl/m4
 */
function axisRotation(axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  dst[0] = xx + (1 - xx) * c;
  dst[1] = x * y * oneMinusCosine + z * s;
  dst[2] = x * z * oneMinusCosine - y * s;
  dst[3] = 0;
  dst[4] = x * y * oneMinusCosine - z * s;
  dst[5] = yy + (1 - yy) * c;
  dst[6] = y * z * oneMinusCosine + x * s;
  dst[7] = 0;
  dst[8] = x * z * oneMinusCosine + y * s;
  dst[9] = y * z * oneMinusCosine - x * s;
  dst[10] = zz + (1 - zz) * c;
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Rotates the given 4-by-4 matrix around the given axis by the
 * given angle.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} axis The axis
 *     about which to rotate.
 * @param {number} angleInRadians The angle by which to rotate (in radians).
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The rotated matrix.
 * @memberOf module:twgl/m4
 */
function axisRotate(m, axis, angleInRadians, dst) {
  dst = dst || new MatType(16);
  let x = axis[0];
  let y = axis[1];
  let z = axis[2];
  const n = Math.sqrt(x * x + y * y + z * z);
  x /= n;
  y /= n;
  z /= n;
  const xx = x * x;
  const yy = y * y;
  const zz = z * z;
  const c = Math.cos(angleInRadians);
  const s = Math.sin(angleInRadians);
  const oneMinusCosine = 1 - c;
  const r00 = xx + (1 - xx) * c;
  const r01 = x * y * oneMinusCosine + z * s;
  const r02 = x * z * oneMinusCosine - y * s;
  const r10 = x * y * oneMinusCosine - z * s;
  const r11 = yy + (1 - yy) * c;
  const r12 = y * z * oneMinusCosine + x * s;
  const r20 = x * z * oneMinusCosine + y * s;
  const r21 = y * z * oneMinusCosine - x * s;
  const r22 = zz + (1 - zz) * c;
  const m00 = m[0];
  const m01 = m[1];
  const m02 = m[2];
  const m03 = m[3];
  const m10 = m[4];
  const m11 = m[5];
  const m12 = m[6];
  const m13 = m[7];
  const m20 = m[8];
  const m21 = m[9];
  const m22 = m[10];
  const m23 = m[11];
  dst[0] = r00 * m00 + r01 * m10 + r02 * m20;
  dst[1] = r00 * m01 + r01 * m11 + r02 * m21;
  dst[2] = r00 * m02 + r01 * m12 + r02 * m22;
  dst[3] = r00 * m03 + r01 * m13 + r02 * m23;
  dst[4] = r10 * m00 + r11 * m10 + r12 * m20;
  dst[5] = r10 * m01 + r11 * m11 + r12 * m21;
  dst[6] = r10 * m02 + r11 * m12 + r12 * m22;
  dst[7] = r10 * m03 + r11 * m13 + r12 * m23;
  dst[8] = r20 * m00 + r21 * m10 + r22 * m20;
  dst[9] = r20 * m01 + r21 * m11 + r22 * m21;
  dst[10] = r20 * m02 + r21 * m12 + r22 * m22;
  dst[11] = r20 * m03 + r21 * m13 + r22 * m23;
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}

/**
 * Creates a 4-by-4 matrix which scales in each dimension by an amount given by
 * the corresponding entry in the given vector; assumes the vector has three
 * entries.
 * @param {module:twgl/v3.Vec3} v A vector of
 *     three entries specifying the factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaling matrix.
 * @memberOf module:twgl/m4
 */
function scaling(v, dst) {
  dst = dst || new MatType(16);
  dst[0] = v[0];
  dst[1] = 0;
  dst[2] = 0;
  dst[3] = 0;
  dst[4] = 0;
  dst[5] = v[1];
  dst[6] = 0;
  dst[7] = 0;
  dst[8] = 0;
  dst[9] = 0;
  dst[10] = v[2];
  dst[11] = 0;
  dst[12] = 0;
  dst[13] = 0;
  dst[14] = 0;
  dst[15] = 1;
  return dst;
}

/**
 * Scales the given 4-by-4 matrix in each dimension by an amount
 * given by the corresponding entry in the given vector; assumes the vector has
 * three entries.
 * @param {module:twgl/m4.Mat4} m The matrix to be modified.
 * @param {module:twgl/v3.Vec3} v A vector of three entries specifying the
 *     factor by which to scale in each dimension.
 * @param {module:twgl/m4.Mat4} [dst] matrix to hold result. If not passed a new one is created.
 * @return {module:twgl/m4.Mat4} The scaled matrix.
 * @memberOf module:twgl/m4
 */
function scale(m, v, dst) {
  dst = dst || new MatType(16);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2];
  dst[3] = v0 * m[0 * 4 + 3];
  dst[4] = v1 * m[1 * 4 + 0];
  dst[5] = v1 * m[1 * 4 + 1];
  dst[6] = v1 * m[1 * 4 + 2];
  dst[7] = v1 * m[1 * 4 + 3];
  dst[8] = v2 * m[2 * 4 + 0];
  dst[9] = v2 * m[2 * 4 + 1];
  dst[10] = v2 * m[2 * 4 + 2];
  dst[11] = v2 * m[2 * 4 + 3];
  if (m !== dst) {
    dst[12] = m[12];
    dst[13] = m[13];
    dst[14] = m[14];
    dst[15] = m[15];
  }
  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries,
 * interprets the vector as a point, transforms that point by the matrix, and
 * returns the result as a vector with 3 entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The point.
 * @param {module:twgl/v3.Vec3} [dst] optional vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed point.
 * @memberOf module:twgl/m4
 */
function transformPoint(m, v, dst) {
  dst = dst || create();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  const d = v0 * m[0 * 4 + 3] + v1 * m[1 * 4 + 3] + v2 * m[2 * 4 + 3] + m[3 * 4 + 3];
  dst[0] = (v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0] + m[3 * 4 + 0]) / d;
  dst[1] = (v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1] + m[3 * 4 + 1]) / d;
  dst[2] = (v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2] + m[3 * 4 + 2]) / d;
  return dst;
}

/**
 * Takes a 4-by-4 matrix and a vector with 3 entries, interprets the vector as a
 * direction, transforms that direction by the matrix, and returns the result;
 * assumes the transformation of 3-dimensional space represented by the matrix
 * is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion. Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The direction.
 * @param {module:twgl/v3.Vec3} [dst] optional Vec3 to store result. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed direction.
 * @memberOf module:twgl/m4
 */
function transformDirection(m, v, dst) {
  dst = dst || create();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * m[0 * 4 + 0] + v1 * m[1 * 4 + 0] + v2 * m[2 * 4 + 0];
  dst[1] = v0 * m[0 * 4 + 1] + v1 * m[1 * 4 + 1] + v2 * m[2 * 4 + 1];
  dst[2] = v0 * m[0 * 4 + 2] + v1 * m[1 * 4 + 2] + v2 * m[2 * 4 + 2];
  return dst;
}

/**
 * Takes a 4-by-4 matrix m and a vector v with 3 entries, interprets the vector
 * as a normal to a surface, and computes a vector which is normal upon
 * transforming that surface by the matrix. The effect of this function is the
 * same as transforming v (as a direction) by the inverse-transpose of m.  This
 * function assumes the transformation of 3-dimensional space represented by the
 * matrix is parallel-preserving, i.e. any combination of rotation, scaling and
 * translation, but not a perspective distortion.  Returns a vector with 3
 * entries.
 * @param {module:twgl/m4.Mat4} m The matrix.
 * @param {module:twgl/v3.Vec3} v The normal.
 * @param {module:twgl/v3.Vec3} [dst] The direction. If not passed a new one is created.
 * @return {module:twgl/v3.Vec3} The transformed normal.
 * @memberOf module:twgl/m4
 */
function transformNormal(m, v, dst) {
  dst = dst || create();
  const mi = inverse(m);
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}
var m4 = /*#__PURE__*/Object.freeze({
  __proto__: null,
  axisRotate: axisRotate,
  axisRotation: axisRotation,
  copy: copy$1,
  create: create$1,
  frustum: frustum,
  getAxis: getAxis,
  getTranslation: getTranslation,
  identity: identity,
  inverse: inverse,
  lookAt: lookAt,
  multiply: multiply$1,
  negate: negate$1,
  ortho: ortho,
  perspective: perspective,
  rotateX: rotateX,
  rotateY: rotateY,
  rotateZ: rotateZ,
  rotationX: rotationX,
  rotationY: rotationY,
  rotationZ: rotationZ,
  scale: scale,
  scaling: scaling,
  setAxis: setAxis,
  setDefaultType: setDefaultType$1,
  setTranslation: setTranslation,
  transformDirection: transformDirection,
  transformNormal: transformNormal,
  transformPoint: transformPoint,
  translate: translate,
  translation: translation,
  transpose: transpose
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* DataType */
const BYTE = 0x1400;
const UNSIGNED_BYTE = 0x1401;
const SHORT = 0x1402;
const UNSIGNED_SHORT = 0x1403;
const INT = 0x1404;
const UNSIGNED_INT = 0x1405;
const FLOAT = 0x1406;
const UNSIGNED_SHORT_4_4_4_4 = 0x8033;
const UNSIGNED_SHORT_5_5_5_1 = 0x8034;
const UNSIGNED_SHORT_5_6_5 = 0x8363;
const HALF_FLOAT = 0x140B;
const UNSIGNED_INT_2_10_10_10_REV = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV = 0x8DAD;
const UNSIGNED_INT_24_8 = 0x84FA;
const glTypeToTypedArray = {};
{
  const tt = glTypeToTypedArray;
  tt[BYTE] = Int8Array;
  tt[UNSIGNED_BYTE] = Uint8Array;
  tt[SHORT] = Int16Array;
  tt[UNSIGNED_SHORT] = Uint16Array;
  tt[INT] = Int32Array;
  tt[UNSIGNED_INT] = Uint32Array;
  tt[FLOAT] = Float32Array;
  tt[UNSIGNED_SHORT_4_4_4_4] = Uint16Array;
  tt[UNSIGNED_SHORT_5_5_5_1] = Uint16Array;
  tt[UNSIGNED_SHORT_5_6_5] = Uint16Array;
  tt[HALF_FLOAT] = Uint16Array;
  tt[UNSIGNED_INT_2_10_10_10_REV] = Uint32Array;
  tt[UNSIGNED_INT_10F_11F_11F_REV] = Uint32Array;
  tt[UNSIGNED_INT_5_9_9_9_REV] = Uint32Array;
  tt[FLOAT_32_UNSIGNED_INT_24_8_REV] = Uint32Array;
  tt[UNSIGNED_INT_24_8] = Uint32Array;
}

/**
 * Get the GL type for a typedArray
 * @param {ArrayBufferView} typedArray a typedArray
 * @return {number} the GL type for array. For example pass in an `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in a `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return BYTE;
  } // eslint-disable-line
  if (typedArray instanceof Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line
  if (typedArray instanceof Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line
  if (typedArray instanceof Int16Array) {
    return SHORT;
  } // eslint-disable-line
  if (typedArray instanceof Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line
  if (typedArray instanceof Int32Array) {
    return INT;
  } // eslint-disable-line
  if (typedArray instanceof Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line
  if (typedArray instanceof Float32Array) {
    return FLOAT;
  } // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the GL type for a typedArray type
 * @param {ArrayBufferView} typedArrayType a typedArray constructor
 * @return {number} the GL type for type. For example pass in `Int8Array` and `gl.BYTE` will
 *   be returned. Pass in `Uint32Array` and `gl.UNSIGNED_INT` will be returned
 * @memberOf module:twgl/typedArray
 */
function getGLTypeForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return BYTE;
  } // eslint-disable-line
  if (typedArrayType === Uint8Array) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line
  if (typedArrayType === Uint8ClampedArray) {
    return UNSIGNED_BYTE;
  } // eslint-disable-line
  if (typedArrayType === Int16Array) {
    return SHORT;
  } // eslint-disable-line
  if (typedArrayType === Uint16Array) {
    return UNSIGNED_SHORT;
  } // eslint-disable-line
  if (typedArrayType === Int32Array) {
    return INT;
  } // eslint-disable-line
  if (typedArrayType === Uint32Array) {
    return UNSIGNED_INT;
  } // eslint-disable-line
  if (typedArrayType === Float32Array) {
    return FLOAT;
  } // eslint-disable-line
  throw new Error('unsupported typed array type');
}

/**
 * Get the typed array constructor for a given GL type
 * @param {number} type the GL type. (eg: `gl.UNSIGNED_INT`)
 * @return {function} the constructor for a the corresponding typed array. (eg. `Uint32Array`).
 * @memberOf module:twgl/typedArray
 */
function getTypedArrayTypeForGLType(type) {
  const CTOR = glTypeToTypedArray[type];
  if (!CTOR) {
    throw new Error('unknown gl type');
  }
  return CTOR;
}
const isArrayBuffer = typeof SharedArrayBuffer !== 'undefined' ? function isArrayBufferOrSharedArrayBuffer(a) {
  return a && a.buffer && (a.buffer instanceof ArrayBuffer || a.buffer instanceof SharedArrayBuffer);
} : function isArrayBuffer(a) {
  return a && a.buffer && a.buffer instanceof ArrayBuffer;
};
var typedarrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  getGLTypeForTypedArray: getGLTypeForTypedArray,
  getGLTypeForTypedArrayType: getGLTypeForTypedArrayType,
  getTypedArrayTypeForGLType: getTypedArrayTypeForGLType,
  isArrayBuffer: isArrayBuffer
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/* eslint no-console: "off" */

/**
 * Copy named properties
 *
 * @param {string[]} names names of properties to copy
 * @param {object} src object to copy properties from
 * @param {object} dst object to copy properties to
 * @private
 */
function copyNamedProperties(names, src, dst) {
  names.forEach(function (name) {
    const value = src[name];
    if (value !== undefined) {
      dst[name] = value;
    }
  });
}

/**
 * Copies properties from source to dest only if a matching key is in dest
 *
 * @param {Object.<string, ?>} src the source
 * @param {Object.<string, ?>} dst the dest
 * @private
 */
function copyExistingProperties(src, dst) {
  Object.keys(dst).forEach(function (key) {
    if (dst.hasOwnProperty(key) && src.hasOwnProperty(key)) {
      /* eslint no-prototype-builtins: 0 */
      dst[key] = src[key];
    }
  });
}
function error() {
  console.error(...arguments);
}
function warn() {
  console.warn(...arguments);
}
function isBuffer(gl, t) {
  return typeof WebGLBuffer !== 'undefined' && t instanceof WebGLBuffer;
}
function isRenderbuffer(gl, t) {
  return typeof WebGLRenderbuffer !== 'undefined' && t instanceof WebGLRenderbuffer;
}
function isShader(gl, t) {
  return typeof WebGLShader !== 'undefined' && t instanceof WebGLShader;
}
function isTexture(gl, t) {
  return typeof WebGLTexture !== 'undefined' && t instanceof WebGLTexture;
}
function isSampler(gl, t) {
  return typeof WebGLSampler !== 'undefined' && t instanceof WebGLSampler;
}

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const STATIC_DRAW = 0x88e4;
const ARRAY_BUFFER = 0x8892;
const ELEMENT_ARRAY_BUFFER = 0x8893;
const BUFFER_SIZE = 0x8764;
const BYTE$1 = 0x1400;
const UNSIGNED_BYTE$1 = 0x1401;
const SHORT$1 = 0x1402;
const UNSIGNED_SHORT$1 = 0x1403;
const INT$1 = 0x1404;
const UNSIGNED_INT$1 = 0x1405;
const FLOAT$1 = 0x1406;
const defaults = {
  attribPrefix: ""
};

/**
 * Sets the default attrib prefix
 *
 * When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 * as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 * In other words I'll create arrays of geometry like this
 *
 *     var arrays = {
 *       position: ...
 *       normal: ...
 *       texcoord: ...
 *     };
 *
 * But need those mapped to attributes and my attributes start with `a_`.
 *
 * @deprecated see {@link module:twgl.setDefaults}
 * @param {string} prefix prefix for attribs
 * @memberOf module:twgl/attributes
 */
function setAttributePrefix(prefix) {
  defaults.attribPrefix = prefix;
}
function setDefaults(newDefaults) {
  copyExistingProperties(newDefaults, defaults);
}
function setBufferFromTypedArray(gl, type, buffer, array, drawType) {
  gl.bindBuffer(type, buffer);
  gl.bufferData(type, array, drawType || STATIC_DRAW);
}

/**
 * Given typed array creates a WebGLBuffer and copies the typed array
 * into it.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {ArrayBuffer|SharedArrayBuffer|ArrayBufferView|WebGLBuffer} typedArray the typed array. Note: If a WebGLBuffer is passed in it will just be returned. No action will be taken
 * @param {number} [type] the GL bind type for the buffer. Default = `gl.ARRAY_BUFFER`.
 * @param {number} [drawType] the GL draw type for the buffer. Default = 'gl.STATIC_DRAW`.
 * @return {WebGLBuffer} the created WebGLBuffer
 * @memberOf module:twgl/attributes
 */
function createBufferFromTypedArray(gl, typedArray, type, drawType) {
  if (isBuffer(gl, typedArray)) {
    return typedArray;
  }
  type = type || ARRAY_BUFFER;
  const buffer = gl.createBuffer();
  setBufferFromTypedArray(gl, type, buffer, typedArray, drawType);
  return buffer;
}
function isIndices(name) {
  return name === "indices";
}

// This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?
function getNormalizationForTypedArray(typedArray) {
  if (typedArray instanceof Int8Array) {
    return true;
  } // eslint-disable-line
  if (typedArray instanceof Uint8Array) {
    return true;
  } // eslint-disable-line
  return false;
}

// This is really just a guess. Though I can't really imagine using
// anything else? Maybe for some compression?
function getNormalizationForTypedArrayType(typedArrayType) {
  if (typedArrayType === Int8Array) {
    return true;
  } // eslint-disable-line
  if (typedArrayType === Uint8Array) {
    return true;
  } // eslint-disable-line
  return false;
}
function getArray(array) {
  return array.length ? array : array.data;
}
const texcoordRE = /coord|texture/i;
const colorRE = /color|colour/i;
function guessNumComponentsFromName(name, length) {
  let numComponents;
  if (texcoordRE.test(name)) {
    numComponents = 2;
  } else if (colorRE.test(name)) {
    numComponents = 4;
  } else {
    numComponents = 3; // position, normals, indices ...
  }
  if (length % numComponents > 0) {
    throw new Error("Can not guess numComponents for attribute '".concat(name, "'. Tried ").concat(numComponents, " but ").concat(length, " values is not evenly divisible by ").concat(numComponents, ". You should specify it."));
  }
  return numComponents;
}
function getNumComponents(array, arrayName) {
  return array.numComponents || array.size || guessNumComponentsFromName(arrayName, getArray(array).length);
}
function makeTypedArray(array, name) {
  if (isArrayBuffer(array)) {
    return array;
  }
  if (isArrayBuffer(array.data)) {
    return array.data;
  }
  if (Array.isArray(array)) {
    array = {
      data: array
    };
  }
  let Type = array.type;
  if (!Type) {
    if (isIndices(name)) {
      Type = Uint16Array;
    } else {
      Type = Float32Array;
    }
  }
  return new Type(array.data);
}

/**
 * The info for an attribute. This is effectively just the arguments to `gl.vertexAttribPointer` plus the WebGLBuffer
 * for the attribute.
 *
 * @typedef {Object} AttribInfo
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {number} [numComponents] the number of components for this attribute.
 * @property {number} [size] synonym for `numComponents`.
 * @property {number} [type] the type of the attribute (eg. `gl.FLOAT`, `gl.UNSIGNED_BYTE`, etc...) Default = `gl.FLOAT`
 * @property {boolean} [normalize] whether or not to normalize the data. Default = false
 * @property {number} [offset] offset into buffer in bytes. Default = 0
 * @property {number} [stride] the stride in bytes per element. Default = 0
 * @property {number} [divisor] the divisor in instances. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {WebGLBuffer} buffer the buffer that contains the data for this attribute
 * @property {number} [drawType] the draw type passed to gl.bufferData. Default = gl.STATIC_DRAW
 * @memberOf module:twgl
 */

/**
 * Use this type of array spec when TWGL can't guess the type or number of components of an array
 * @typedef {Object} FullArraySpec
 * @property {number[]|ArrayBufferView} [value] a constant value for the attribute. Note: if this is set the attribute will be
 *    disabled and set to this constant value and all other values will be ignored.
 * @property {(number|number[]|ArrayBufferView)} data The data of the array. A number alone becomes the number of elements of type.
 * @property {number} [numComponents] number of components for `vertexAttribPointer`. Default is based on the name of the array.
 *    If `coord` is in the name assumes `numComponents = 2`.
 *    If `color` is in the name assumes `numComponents = 4`.
 *    otherwise assumes `numComponents = 3`
 * @property {constructor} [type] type. This is only used if `data` is a JavaScript array. It is the constructor for the typedarray. (eg. `Uint8Array`).
 * For example if you want colors in a `Uint8Array` you might have a `FullArraySpec` like `{ type: Uint8Array, data: [255,0,255,255, ...], }`.
 * @property {number} [size] synonym for `numComponents`.
 * @property {boolean} [normalize] normalize for `vertexAttribPointer`. Default is true if type is `Int8Array` or `Uint8Array` otherwise false.
 * @property {number} [stride] stride for `vertexAttribPointer`. Default = 0
 * @property {number} [offset] offset for `vertexAttribPointer`. Default = 0
 * @property {number} [divisor] divisor for `vertexAttribDivisor`. Default = undefined. Note: undefined = don't call gl.vertexAttribDivisor
 *    where as anything else = do call it with this value
 * @property {string} [attrib] name of attribute this array maps to. Defaults to same name as array prefixed by the default attribPrefix.
 * @property {string} [name] synonym for `attrib`.
 * @property {string} [attribName] synonym for `attrib`.
 * @property {WebGLBuffer} [buffer] Buffer to use for this attribute. This lets you use your own buffer
 *    but you will need to supply `numComponents` and `type`. You can effectively pass an `AttribInfo`
 *    to provide this. Example:
 *
 *         const bufferInfo1 = twgl.createBufferInfoFromArrays(gl, {
 *           position: [1, 2, 3, ... ],
 *         });
 *         const bufferInfo2 = twgl.createBufferInfoFromArrays(gl, {
 *           position: bufferInfo1.attribs.position,  // use the same buffer from bufferInfo1
 *         });
 *
 * @memberOf module:twgl
 */

/**
 * An individual array in {@link module:twgl.Arrays}
 *
 * When passed to {@link module:twgl.createBufferInfoFromArrays} if an ArraySpec is `number[]` or `ArrayBufferView`
 * the types will be guessed based on the name. `indices` will be `Uint16Array`, everything else will
 * be `Float32Array`. If an ArraySpec is a number it's the number of floats for an empty (zeroed) buffer.
 *
 * @typedef {(number|number[]|ArrayBufferView|module:twgl.FullArraySpec)} ArraySpec
 * @memberOf module:twgl
 */

/**
 * This is a JavaScript object of arrays by name. The names should match your shader's attributes. If your
 * attributes have a common prefix you can specify it by calling {@link module:twgl.setAttributePrefix}.
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * Objects with various fields. See {@link module:twgl.FullArraySpec}.
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 * @typedef {Object.<string, module:twgl.ArraySpec>} Arrays
 * @memberOf module:twgl
 */

/**
 * Creates a set of attribute data and WebGLBuffers from set of arrays
 *
 * Given
 *
 *      var arrays = {
 *        position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *        texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *        normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *        color:    { numComponents: 4, data: [255, 255, 255, 255, 255, 0, 0, 255, 0, 0, 255, 255], type: Uint8Array, },
 *        indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *      };
 *
 * returns something like
 *
 *      var attribs = {
 *        position: { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        texcoord: { numComponents: 2, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        normal:   { numComponents: 3, type: gl.FLOAT,         normalize: false, buffer: WebGLBuffer, },
 *        color:    { numComponents: 4, type: gl.UNSIGNED_BYTE, normalize: true,  buffer: WebGLBuffer, },
 *      };
 *
 * notes:
 *
 * *   Arrays can take various forms
 *
 *     Bare JavaScript Arrays
 *
 *         var arrays = {
 *            position: [-1, 1, 0],
 *            normal: [0, 1, 0],
 *            ...
 *         }
 *
 *     Bare TypedArrays
 *
 *         var arrays = {
 *            position: new Float32Array([-1, 1, 0]),
 *            color: new Uint8Array([255, 128, 64, 255]),
 *            ...
 *         }
 *
 * *   Will guess at `numComponents` if not specified based on name.
 *
 *     If `coord` is in the name assumes `numComponents = 2`
 *
 *     If `color` is in the name assumes `numComponents = 4`
 *
 *     otherwise assumes `numComponents = 3`
 *
 * @param {WebGLRenderingContext} gl The webgl rendering context.
 * @param {module:twgl.Arrays} arrays The arrays
 * @param {module:twgl.BufferInfo} [srcBufferInfo] a BufferInfo to copy from
 *   This lets you share buffers. Any arrays you supply will override
 *   the buffers from srcBufferInfo.
 * @return {Object.<string, module:twgl.AttribInfo>} the attribs
 * @memberOf module:twgl/attributes
 */
function createAttribsFromArrays(gl, arrays) {
  const attribs = {};
  Object.keys(arrays).forEach(function (arrayName) {
    if (!isIndices(arrayName)) {
      const array = arrays[arrayName];
      const attribName = array.attrib || array.name || array.attribName || defaults.attribPrefix + arrayName;
      if (array.value) {
        if (!Array.isArray(array.value) && !isArrayBuffer(array.value)) {
          throw new Error('array.value is not array or typedarray');
        }
        attribs[attribName] = {
          value: array.value
        };
      } else {
        let buffer;
        let type;
        let normalization;
        let numComponents;
        if (array.buffer && array.buffer instanceof WebGLBuffer) {
          buffer = array.buffer;
          numComponents = array.numComponents || array.size;
          type = array.type;
          normalization = array.normalize;
        } else if (typeof array === "number" || typeof array.data === "number") {
          const numValues = array.data || array;
          const arrayType = array.type || Float32Array;
          const numBytes = numValues * arrayType.BYTES_PER_ELEMENT;
          type = getGLTypeForTypedArrayType(arrayType);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArrayType(arrayType);
          numComponents = array.numComponents || array.size || guessNumComponentsFromName(arrayName, numValues);
          buffer = gl.createBuffer();
          gl.bindBuffer(ARRAY_BUFFER, buffer);
          gl.bufferData(ARRAY_BUFFER, numBytes, array.drawType || STATIC_DRAW);
        } else {
          const typedArray = makeTypedArray(array, arrayName);
          buffer = createBufferFromTypedArray(gl, typedArray, undefined, array.drawType);
          type = getGLTypeForTypedArray(typedArray);
          normalization = array.normalize !== undefined ? array.normalize : getNormalizationForTypedArray(typedArray);
          numComponents = getNumComponents(array, arrayName);
        }
        attribs[attribName] = {
          buffer: buffer,
          numComponents: numComponents,
          type: type,
          normalize: normalization,
          stride: array.stride || 0,
          offset: array.offset || 0,
          divisor: array.divisor === undefined ? undefined : array.divisor,
          drawType: array.drawType
        };
      }
    }
  });
  gl.bindBuffer(ARRAY_BUFFER, null);
  return attribs;
}

/**
 * Sets the contents of a buffer attached to an attribInfo
 *
 * This is helper function to dynamically update a buffer.
 *
 * Let's say you make a bufferInfo
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *     var bufferInfo = twgl.createBufferInfoFromArrays(gl, arrays);
 *
 *  And you want to dynamically update the positions. You could do this
 *
 *     // assuming arrays.position has already been updated with new data.
 *     twgl.setAttribInfoBufferFromArray(gl, bufferInfo.attribs.position, arrays.position);
 *
 * @param {WebGLRenderingContext} gl
 * @param {AttribInfo} attribInfo The attribInfo who's buffer contents to set. NOTE: If you have an attribute prefix
 *   the name of the attribute will include the prefix.
 * @param {ArraySpec} array Note: it is arguably inefficient to pass in anything but a typed array because anything
 *    else will have to be converted to a typed array before it can be used by WebGL. During init time that
 *    inefficiency is usually not important but if you're updating data dynamically best to be efficient.
 * @param {number} [offset] an optional offset into the buffer. This is only an offset into the WebGL buffer
 *    not the array. To pass in an offset into the array itself use a typed array and create an `ArrayBufferView`
 *    for the portion of the array you want to use.
 *
 *        var someArray = new Float32Array(1000); // an array with 1000 floats
 *        var someSubArray = new Float32Array(someArray.buffer, offsetInBytes, sizeInUnits); // a view into someArray
 *
 *    Now you can pass `someSubArray` into setAttribInfoBufferFromArray`
 * @memberOf module:twgl/attributes
 */
function setAttribInfoBufferFromArray(gl, attribInfo, array, offset) {
  array = makeTypedArray(array);
  if (offset !== undefined) {
    gl.bindBuffer(ARRAY_BUFFER, attribInfo.buffer);
    gl.bufferSubData(ARRAY_BUFFER, offset, array);
  } else {
    setBufferFromTypedArray(gl, ARRAY_BUFFER, attribInfo.buffer, array, attribInfo.drawType);
  }
}
function getBytesPerValueForGLType(gl, type) {
  if (type === BYTE$1) return 1; // eslint-disable-line
  if (type === UNSIGNED_BYTE$1) return 1; // eslint-disable-line
  if (type === SHORT$1) return 2; // eslint-disable-line
  if (type === UNSIGNED_SHORT$1) return 2; // eslint-disable-line
  if (type === INT$1) return 4; // eslint-disable-line
  if (type === UNSIGNED_INT$1) return 4; // eslint-disable-line
  if (type === FLOAT$1) return 4; // eslint-disable-line
  return 0;
}

// Tries to get the number of elements from a set of arrays.
const positionKeys = ['position', 'positions', 'a_position'];
function getNumElementsFromNonIndexedArrays(arrays) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in arrays) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(arrays)[0];
  }
  const array = arrays[key];
  const length = getArray(array).length;
  if (length === undefined) {
    return 1; // There's no arrays
  }
  const numComponents = getNumComponents(array, key);
  const numElements = length / numComponents;
  if (length % numComponents > 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }
  return numElements;
}
function getNumElementsFromAttributes(gl, attribs) {
  let key;
  let ii;
  for (ii = 0; ii < positionKeys.length; ++ii) {
    key = positionKeys[ii];
    if (key in attribs) {
      break;
    }
    key = defaults.attribPrefix + key;
    if (key in attribs) {
      break;
    }
  }
  if (ii === positionKeys.length) {
    key = Object.keys(attribs)[0];
  }
  const attrib = attribs[key];
  if (!attrib.buffer) {
    return 1; // There's no buffer
  }
  gl.bindBuffer(ARRAY_BUFFER, attrib.buffer);
  const numBytes = gl.getBufferParameter(ARRAY_BUFFER, BUFFER_SIZE);
  gl.bindBuffer(ARRAY_BUFFER, null);
  const bytesPerValue = getBytesPerValueForGLType(gl, attrib.type);
  const totalElements = numBytes / bytesPerValue;
  const numComponents = attrib.numComponents || attrib.size;
  // TODO: check stride
  const numElements = totalElements / numComponents;
  if (numElements % 1 !== 0) {
    throw new Error("numComponents ".concat(numComponents, " not correct for length ").concat(length));
  }
  return numElements;
}

/**
 * @typedef {Object} BufferInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLBuffer} [indices] The indices `ELEMENT_ARRAY_BUFFER` if any indices exist.
 * @property {Object.<string, module:twgl.AttribInfo>} [attribs] The attribs appropriate to call `setAttributes`
 * @memberOf module:twgl
 */

/**
 * Creates a BufferInfo from an object of arrays.
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * Given an object like
 *
 *     var arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *       normal:   { numComponents: 3, data: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],     },
 *       indices:  { numComponents: 3, data: [0, 1, 2, 1, 2, 3],                       },
 *     };
 *
 *  Creates an BufferInfo like this
 *
 *     bufferInfo = {
 *       numElements: 4,        // or whatever the number of elements is
 *       indices: WebGLBuffer,  // this property will not exist if there are no indices
 *       attribs: {
 *         position: { buffer: WebGLBuffer, numComponents: 3, },
 *         normal:   { buffer: WebGLBuffer, numComponents: 3, },
 *         texcoord: { buffer: WebGLBuffer, numComponents: 2, },
 *       },
 *     };
 *
 *  The properties of arrays can be JavaScript arrays in which case the number of components
 *  will be guessed.
 *
 *     var arrays = {
 *        position: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0],
 *        texcoord: [0, 0, 0, 1, 1, 0, 1, 1],
 *        normal:   [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
 *        indices:  [0, 1, 2, 1, 2, 3],
 *     };
 *
 *  They can also be TypedArrays
 *
 *     var arrays = {
 *        position: new Float32Array([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]),
 *        texcoord: new Float32Array([0, 0, 0, 1, 1, 0, 1, 1]),
 *        normal:   new Float32Array([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]),
 *        indices:  new Uint16Array([0, 1, 2, 1, 2, 3]),
 *     };
 *
 *  Or AugmentedTypedArrays
 *
 *     var positions = createAugmentedTypedArray(3, 4);
 *     var texcoords = createAugmentedTypedArray(2, 4);
 *     var normals   = createAugmentedTypedArray(3, 4);
 *     var indices   = createAugmentedTypedArray(3, 2, Uint16Array);
 *
 *     positions.push([0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0]);
 *     texcoords.push([0, 0, 0, 1, 1, 0, 1, 1]);
 *     normals.push([0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1]);
 *     indices.push([0, 1, 2, 1, 2, 3]);
 *
 *     var arrays = {
 *        position: positions,
 *        texcoord: texcoords,
 *        normal:   normals,
 *        indices:  indices,
 *     };
 *
 * For the last example it is equivalent to
 *
 *     var bufferInfo = {
 *       attribs: {
 *         position: { numComponents: 3, buffer: gl.createBuffer(), },
 *         texcoord: { numComponents: 2, buffer: gl.createBuffer(), },
 *         normal: { numComponents: 3, buffer: gl.createBuffer(), },
 *       },
 *       indices: gl.createBuffer(),
 *       numElements: 6,
 *     };
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.position.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.position, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.texcoord.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.texcoord, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, bufferInfo.attribs.normal.buffer);
 *     gl.bufferData(gl.ARRAY_BUFFER, arrays.normal, gl.STATIC_DRAW);
 *     gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferInfo.indices);
 *     gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, arrays.indices, gl.STATIC_DRAW);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.Arrays} arrays Your data
 * @param {module:twgl.BufferInfo} [srcBufferInfo] An existing
 *        buffer info to start from. WebGLBuffers etc specified
 *        in the srcBufferInfo will be used in a new BufferInfo
 *        with any arrays specified overriding the ones in
 *        srcBufferInfo.
 * @return {module:twgl.BufferInfo} A BufferInfo
 * @memberOf module:twgl/attributes
 */
function createBufferInfoFromArrays(gl, arrays, srcBufferInfo) {
  const newAttribs = createAttribsFromArrays(gl, arrays);
  const bufferInfo = Object.assign({}, srcBufferInfo ? srcBufferInfo : {});
  bufferInfo.attribs = Object.assign({}, srcBufferInfo ? srcBufferInfo.attribs : {}, newAttribs);
  const indices = arrays.indices;
  if (indices) {
    const newIndices = makeTypedArray(indices, "indices");
    bufferInfo.indices = createBufferFromTypedArray(gl, newIndices, ELEMENT_ARRAY_BUFFER);
    bufferInfo.numElements = newIndices.length;
    bufferInfo.elementType = getGLTypeForTypedArray(newIndices);
  } else if (!bufferInfo.numElements) {
    bufferInfo.numElements = getNumElementsFromAttributes(gl, bufferInfo.attribs);
  }
  return bufferInfo;
}

/**
 * Creates a buffer from an array, typed array, or array spec
 *
 * Given something like this
 *
 *     [1, 2, 3],
 *
 * or
 *
 *     new Uint16Array([1,2,3]);
 *
 * or
 *
 *     {
 *        data: [1, 2, 3],
 *        type: Uint8Array,
 *     }
 *
 * returns a WebGLBuffer that contains the given data.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.ArraySpec} array an array, typed array, or array spec.
 * @param {string} arrayName name of array. Used to guess the type if type can not be derived otherwise.
 * @return {WebGLBuffer} a WebGLBuffer containing the data in array.
 * @memberOf module:twgl/attributes
 */
function createBufferFromArray(gl, array, arrayName) {
  const type = arrayName === "indices" ? ELEMENT_ARRAY_BUFFER : ARRAY_BUFFER;
  const typedArray = makeTypedArray(array, arrayName);
  return createBufferFromTypedArray(gl, typedArray, type);
}

/**
 * Creates buffers from arrays or typed arrays
 *
 * Given something like this
 *
 *     var arrays = {
 *        positions: [1, 2, 3],
 *        normals: [0, 0, 1],
 *     }
 *
 * returns something like
 *
 *     buffers = {
 *       positions: WebGLBuffer,
 *       normals: WebGLBuffer,
 *     }
 *
 * If the buffer is named 'indices' it will be made an ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {module:twgl.Arrays} arrays
 * @return {Object<string, WebGLBuffer>} returns an object with one WebGLBuffer per array
 * @memberOf module:twgl/attributes
 */
function createBuffersFromArrays(gl, arrays) {
  const buffers = {};
  Object.keys(arrays).forEach(function (key) {
    buffers[key] = createBufferFromArray(gl, arrays[key], key);
  });

  // Ugh!
  if (arrays.indices) {
    buffers.numElements = arrays.indices.length;
    buffers.elementType = getGLTypeForTypedArray(makeTypedArray(arrays.indices));
  } else {
    buffers.numElements = getNumElementsFromNonIndexedArrays(arrays);
  }
  return buffers;
}
var attributes = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttribsFromArrays: createAttribsFromArrays,
  createBuffersFromArrays: createBuffersFromArrays,
  createBufferFromArray: createBufferFromArray,
  createBufferFromTypedArray: createBufferFromTypedArray,
  createBufferInfoFromArrays: createBufferInfoFromArrays,
  setAttribInfoBufferFromArray: setAttribInfoBufferFromArray,
  setAttributePrefix: setAttributePrefix,
  setAttributeDefaults_: setDefaults,
  getNumComponents_: getNumComponents,
  getArray_: getArray
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const getArray$1 = getArray; // eslint-disable-line
const getNumComponents$1 = getNumComponents; // eslint-disable-line

/**
 * @typedef {(Int8Array|Uint8Array|Int16Array|Uint16Array|Int32Array|Uint32Array|Float32Array)} TypedArray
 */

/**
 * Add `push` to a typed array. It just keeps a 'cursor'
 * and allows use to `push` values into the array so we
 * don't have to manually compute offsets
 * @param {TypedArray} typedArray TypedArray to augment
 * @param {number} numComponents number of components.
 * @private
 */
function augmentTypedArray(typedArray, numComponents) {
  let cursor = 0;
  typedArray.push = function () {
    for (let ii = 0; ii < arguments.length; ++ii) {
      const value = arguments[ii];
      if (value instanceof Array || isArrayBuffer(value)) {
        for (let jj = 0; jj < value.length; ++jj) {
          typedArray[cursor++] = value[jj];
        }
      } else {
        typedArray[cursor++] = value;
      }
    }
  };
  typedArray.reset = function (opt_index) {
    cursor = opt_index || 0;
  };
  typedArray.numComponents = numComponents;
  Object.defineProperty(typedArray, 'numElements', {
    get: function get() {
      return this.length / this.numComponents | 0;
    }
  });
  return typedArray;
}

/**
 * creates a typed array with a `push` function attached
 * so that you can easily *push* values.
 *
 * `push` can take multiple arguments. If an argument is an array each element
 * of the array will be added to the typed array.
 *
 * Example:
 *
 *     const array = createAugmentedTypedArray(3, 2);  // creates a Float32Array with 6 values
 *     array.push(1, 2, 3);
 *     array.push([4, 5, 6]);
 *     // array now contains [1, 2, 3, 4, 5, 6]
 *
 * Also has `numComponents` and `numElements` properties.
 *
 * @param {number} numComponents number of components
 * @param {number} numElements number of elements. The total size of the array will be `numComponents * numElements`.
 * @param {constructor} opt_type A constructor for the type. Default = `Float32Array`.
 * @return {ArrayBufferView} A typed array.
 * @memberOf module:twgl/primitives
 */
function createAugmentedTypedArray(numComponents, numElements, opt_type) {
  const Type = opt_type || Float32Array;
  return augmentTypedArray(new Type(numComponents * numElements), numComponents);
}
function allButIndices(name) {
  return name !== "indices";
}

/**
 * Given indexed vertices creates a new set of vertices un-indexed by expanding the indexed vertices.
 * @param {Object.<string, TypedArray>} vertices The indexed vertices to deindex
 * @return {Object.<string, TypedArray>} The deindexed vertices
 * @memberOf module:twgl/primitives
 */
function deindexVertices(vertices) {
  const indices = vertices.indices;
  const newVertices = {};
  const numElements = indices.length;
  function expandToUnindexed(channel) {
    const srcBuffer = vertices[channel];
    const numComponents = srcBuffer.numComponents;
    const dstBuffer = createAugmentedTypedArray(numComponents, numElements, srcBuffer.constructor);
    for (let ii = 0; ii < numElements; ++ii) {
      const ndx = indices[ii];
      const offset = ndx * numComponents;
      for (let jj = 0; jj < numComponents; ++jj) {
        dstBuffer.push(srcBuffer[offset + jj]);
      }
    }
    newVertices[channel] = dstBuffer;
  }
  Object.keys(vertices).filter(allButIndices).forEach(expandToUnindexed);
  return newVertices;
}

/**
 * flattens the normals of deindexed vertices in place.
 * @param {Object.<string, TypedArray>} vertices The deindexed vertices who's normals to flatten
 * @return {Object.<string, TypedArray>} The flattened vertices (same as was passed in)
 * @memberOf module:twgl/primitives
 */
function flattenNormals(vertices) {
  if (vertices.indices) {
    throw new Error('can not flatten normals of indexed vertices. deindex them first');
  }
  const normals = vertices.normal;
  const numNormals = normals.length;
  for (let ii = 0; ii < numNormals; ii += 9) {
    // pull out the 3 normals for this triangle
    const nax = normals[ii + 0];
    const nay = normals[ii + 1];
    const naz = normals[ii + 2];
    const nbx = normals[ii + 3];
    const nby = normals[ii + 4];
    const nbz = normals[ii + 5];
    const ncx = normals[ii + 6];
    const ncy = normals[ii + 7];
    const ncz = normals[ii + 8];

    // add them
    let nx = nax + nbx + ncx;
    let ny = nay + nby + ncy;
    let nz = naz + nbz + ncz;

    // normalize them
    const length = Math.sqrt(nx * nx + ny * ny + nz * nz);
    nx /= length;
    ny /= length;
    nz /= length;

    // copy them back in
    normals[ii + 0] = nx;
    normals[ii + 1] = ny;
    normals[ii + 2] = nz;
    normals[ii + 3] = nx;
    normals[ii + 4] = ny;
    normals[ii + 5] = nz;
    normals[ii + 6] = nx;
    normals[ii + 7] = ny;
    normals[ii + 8] = nz;
  }
  return vertices;
}
function applyFuncToV3Array(array, matrix, fn) {
  const len = array.length;
  const tmp = new Float32Array(3);
  for (let ii = 0; ii < len; ii += 3) {
    fn(matrix, [array[ii], array[ii + 1], array[ii + 2]], tmp);
    array[ii] = tmp[0];
    array[ii + 1] = tmp[1];
    array[ii + 2] = tmp[2];
  }
}
function transformNormal$1(mi, v, dst) {
  dst = dst || create();
  const v0 = v[0];
  const v1 = v[1];
  const v2 = v[2];
  dst[0] = v0 * mi[0 * 4 + 0] + v1 * mi[0 * 4 + 1] + v2 * mi[0 * 4 + 2];
  dst[1] = v0 * mi[1 * 4 + 0] + v1 * mi[1 * 4 + 1] + v2 * mi[1 * 4 + 2];
  dst[2] = v0 * mi[2 * 4 + 0] + v1 * mi[2 * 4 + 1] + v2 * mi[2 * 4 + 2];
  return dst;
}

/**
 * Reorients directions by the given matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientDirections(array, matrix) {
  applyFuncToV3Array(array, matrix, transformDirection);
  return array;
}

/**
 * Reorients normals by the inverse-transpose of the given
 * matrix..
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientNormals(array, matrix) {
  applyFuncToV3Array(array, inverse(matrix), transformNormal$1);
  return array;
}

/**
 * Reorients positions by the given matrix. In other words, it
 * multiplies each vertex by the given matrix.
 * @param {(number[]|TypedArray)} array The array. Assumes value floats per element.
 * @param {module:twgl/m4.Mat4} matrix A matrix to multiply by.
 * @return {(number[]|TypedArray)} the same array that was passed in
 * @memberOf module:twgl/primitives
 */
function reorientPositions(array, matrix) {
  applyFuncToV3Array(array, matrix, transformPoint);
  return array;
}

/**
 * @typedef {(number[]|TypedArray)} NativeArrayOrTypedArray
 */

/**
 * Reorients arrays by the given matrix. Assumes arrays have
 * names that contains 'pos' could be reoriented as positions,
 * 'binorm' or 'tan' as directions, and 'norm' as normals.
 *
 * @param {Object.<string, NativeArrayOrTypedArray>} arrays The vertices to reorient
 * @param {module:twgl/m4.Mat4} matrix matrix to reorient by.
 * @return {Object.<string, NativeArrayOrTypedArray>} same arrays that were passed in.
 * @memberOf module:twgl/primitives
 */
function reorientVertices(arrays, matrix) {
  Object.keys(arrays).forEach(function (name) {
    const array = arrays[name];
    if (name.indexOf("pos") >= 0) {
      reorientPositions(array, matrix);
    } else if (name.indexOf("tan") >= 0 || name.indexOf("binorm") >= 0) {
      reorientDirections(array, matrix);
    } else if (name.indexOf("norm") >= 0) {
      reorientNormals(array, matrix);
    }
  });
  return arrays;
}

/**
 * Creates XY quad BufferInfo
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, WebGLBuffer>} the created XY Quad BufferInfo
 * @memberOf module:twgl/primitives
 * @function createXYQuadBuffers
 */

/**
 * Creates XY quad Buffers
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadBufferInfo(gl, 1, 0, 0.5);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {module:twgl.BufferInfo} the created XY Quad buffers
 * @memberOf module:twgl/primitives
 * @function createXYQuadBufferInfo
 */

/**
 * Creates XY quad vertices
 *
 * The default with no parameters will return a 2x2 quad with values from -1 to +1.
 * If you want a unit quad with that goes from 0 to 1 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0.5, 0.5);
 *
 * If you want a unit quad centered above 0,0 you'd call it with
 *
 *     twgl.primitives.createXYQuadVertices(1, 0, 0.5);
 *
 * @param {number} [size] the size across the quad. Defaults to 2 which means vertices will go from -1 to +1
 * @param {number} [xOffset] the amount to offset the quad in X
 * @param {number} [yOffset] the amount to offset the quad in Y
 * @return {Object.<string, TypedArray>} the created XY Quad vertices
 * @memberOf module:twgl/primitives
 */
function createXYQuadVertices(size, xOffset, yOffset) {
  size = size || 2;
  xOffset = xOffset || 0;
  yOffset = yOffset || 0;
  size *= 0.5;
  return {
    position: {
      numComponents: 2,
      data: [xOffset + -1 * size, yOffset + -1 * size, xOffset + 1 * size, yOffset + -1 * size, xOffset + -1 * size, yOffset + 1 * size, xOffset + 1 * size, yOffset + 1 * size]
    },
    normal: [0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1],
    texcoord: [0, 0, 1, 0, 0, 1, 1, 1],
    indices: [0, 1, 2, 2, 1, 3]
  };
}

/**
 * Creates XZ plane BufferInfo.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {module:twgl.BufferInfo} The created plane BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createPlaneBufferInfo
 */

/**
 * Creates XZ plane buffers.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, WebGLBuffer>} The created plane buffers.
 * @memberOf module:twgl/primitives
 * @function createPlaneBuffers
 */

/**
 * Creates XZ plane vertices.
 *
 * The created plane has position, normal, and texcoord data
 *
 * @param {number} [width] Width of the plane. Default = 1
 * @param {number} [depth] Depth of the plane. Default = 1
 * @param {number} [subdivisionsWidth] Number of steps across the plane. Default = 1
 * @param {number} [subdivisionsDepth] Number of steps down the plane. Default = 1
 * @param {module:twgl/m4.Mat4} [matrix] A matrix by which to multiply all the vertices.
 * @return {Object.<string, TypedArray>} The created plane vertices.
 * @memberOf module:twgl/primitives
 */
function createPlaneVertices(width, depth, subdivisionsWidth, subdivisionsDepth, matrix) {
  width = width || 1;
  depth = depth || 1;
  subdivisionsWidth = subdivisionsWidth || 1;
  subdivisionsDepth = subdivisionsDepth || 1;
  matrix = matrix || identity();
  const numVertices = (subdivisionsWidth + 1) * (subdivisionsDepth + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  for (let z = 0; z <= subdivisionsDepth; z++) {
    for (let x = 0; x <= subdivisionsWidth; x++) {
      const u = x / subdivisionsWidth;
      const v = z / subdivisionsDepth;
      positions.push(width * u - width * 0.5, 0, depth * v - depth * 0.5);
      normals.push(0, 1, 0);
      texcoords.push(u, v);
    }
  }
  const numVertsAcross = subdivisionsWidth + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsWidth * subdivisionsDepth * 2, Uint16Array);
  for (let z = 0; z < subdivisionsDepth; z++) {
    // eslint-disable-line
    for (let x = 0; x < subdivisionsWidth; x++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((z + 0) * numVertsAcross + x, (z + 1) * numVertsAcross + x, (z + 0) * numVertsAcross + x + 1);

      // Make triangle 2 of quad.
      indices.push((z + 1) * numVertsAcross + x, (z + 1) * numVertsAcross + x + 1, (z + 0) * numVertsAcross + x + 1);
    }
  }
  const arrays = reorientVertices({
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  }, matrix);
  return arrays;
}

/**
 * Creates sphere BufferInfo.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {module:twgl.BufferInfo} The created sphere BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createSphereBufferInfo
 */

/**
 * Creates sphere buffers.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, WebGLBuffer>} The created sphere buffers.
 * @memberOf module:twgl/primitives
 * @function createSphereBuffers
 */

/**
 * Creates sphere vertices.
 *
 * The created sphere has position, normal, and texcoord data
 *
 * @param {number} radius radius of the sphere.
 * @param {number} subdivisionsAxis number of steps around the sphere.
 * @param {number} subdivisionsHeight number of vertically on the sphere.
 * @param {number} [opt_startLatitudeInRadians] where to start the
 *     top of the sphere. Default = 0.
 * @param {number} [opt_endLatitudeInRadians] Where to end the
 *     bottom of the sphere. Default = Math.PI.
 * @param {number} [opt_startLongitudeInRadians] where to start
 *     wrapping the sphere. Default = 0.
 * @param {number} [opt_endLongitudeInRadians] where to end
 *     wrapping the sphere. Default = 2 * Math.PI.
 * @return {Object.<string, TypedArray>} The created sphere vertices.
 * @memberOf module:twgl/primitives
 */
function createSphereVertices(radius, subdivisionsAxis, subdivisionsHeight, opt_startLatitudeInRadians, opt_endLatitudeInRadians, opt_startLongitudeInRadians, opt_endLongitudeInRadians) {
  if (subdivisionsAxis <= 0 || subdivisionsHeight <= 0) {
    throw new Error('subdivisionAxis and subdivisionHeight must be > 0');
  }
  opt_startLatitudeInRadians = opt_startLatitudeInRadians || 0;
  opt_endLatitudeInRadians = opt_endLatitudeInRadians || Math.PI;
  opt_startLongitudeInRadians = opt_startLongitudeInRadians || 0;
  opt_endLongitudeInRadians = opt_endLongitudeInRadians || Math.PI * 2;
  const latRange = opt_endLatitudeInRadians - opt_startLatitudeInRadians;
  const longRange = opt_endLongitudeInRadians - opt_startLongitudeInRadians;

  // We are going to generate our sphere by iterating through its
  // spherical coordinates and generating 2 triangles for each quad on a
  // ring of the sphere.
  const numVertices = (subdivisionsAxis + 1) * (subdivisionsHeight + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);

  // Generate the individual vertices in our vertex buffer.
  for (let y = 0; y <= subdivisionsHeight; y++) {
    for (let x = 0; x <= subdivisionsAxis; x++) {
      // Generate a vertex based on its spherical coordinates
      const u = x / subdivisionsAxis;
      const v = y / subdivisionsHeight;
      const theta = longRange * u + opt_startLongitudeInRadians;
      const phi = latRange * v + opt_startLatitudeInRadians;
      const sinTheta = Math.sin(theta);
      const cosTheta = Math.cos(theta);
      const sinPhi = Math.sin(phi);
      const cosPhi = Math.cos(phi);
      const ux = cosTheta * sinPhi;
      const uy = cosPhi;
      const uz = sinTheta * sinPhi;
      positions.push(radius * ux, radius * uy, radius * uz);
      normals.push(ux, uy, uz);
      texcoords.push(1 - u, v);
    }
  }
  const numVertsAround = subdivisionsAxis + 1;
  const indices = createAugmentedTypedArray(3, subdivisionsAxis * subdivisionsHeight * 2, Uint16Array);
  for (let x = 0; x < subdivisionsAxis; x++) {
    // eslint-disable-line
    for (let y = 0; y < subdivisionsHeight; y++) {
      // eslint-disable-line
      // Make triangle 1 of quad.
      indices.push((y + 0) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x);

      // Make triangle 2 of quad.
      indices.push((y + 1) * numVertsAround + x, (y + 0) * numVertsAround + x + 1, (y + 1) * numVertsAround + x + 1);
    }
  }
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * Array of the indices of corners of each face of a cube.
 * @type {Array.<number[]>}
 * @private
 */
const CUBE_FACE_INDICES = [[3, 7, 5, 1],
// right
[6, 2, 0, 4],
// left
[6, 7, 3, 2],
// ??
[0, 1, 5, 4],
// ??
[7, 6, 4, 5],
// front
[2, 3, 1, 0] // back
];

/**
 * Creates a BufferInfo for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCubeBufferInfo
 */

/**
 * Creates the buffers and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCubeBuffers
 */

/**
 * Creates the vertices and indices for a cube.
 *
 * The cube is created around the origin. (-size / 2, size / 2).
 *
 * @param {number} [size] width, height and depth of the cube.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createCubeVertices(size) {
  size = size || 1;
  const k = size / 2;
  const cornerVertices = [[-k, -k, -k], [+k, -k, -k], [-k, +k, -k], [+k, +k, -k], [-k, -k, +k], [+k, -k, +k], [-k, +k, +k], [+k, +k, +k]];
  const faceNormals = [[+1, +0, +0], [-1, +0, +0], [+0, +1, +0], [+0, -1, +0], [+0, +0, +1], [+0, +0, -1]];
  const uvCoords = [[1, 0], [0, 0], [0, 1], [1, 1]];
  const numVertices = 6 * 4;
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices = createAugmentedTypedArray(3, 6 * 2, Uint16Array);
  for (let f = 0; f < 6; ++f) {
    const faceIndices = CUBE_FACE_INDICES[f];
    for (let v = 0; v < 4; ++v) {
      const position = cornerVertices[faceIndices[v]];
      const normal = faceNormals[f];
      const uv = uvCoords[v];

      // Each face needs all four vertices because the normals and texture
      // coordinates are not all the same.
      positions.push(position);
      normals.push(normal);
      texcoords.push(uv);
    }
    // Two triangles make a square face.
    const offset = 4 * f;
    indices.push(offset + 0, offset + 1, offset + 2);
    indices.push(offset + 0, offset + 2, offset + 3);
  }
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * Creates a BufferInfo for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created cone BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBufferInfo
 */

/**
 * Creates buffers for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created cone buffers.
 * @memberOf module:twgl/primitives
 * @function createTruncatedConeBuffers
 */

/**
 * Creates vertices for a truncated cone, which is like a cylinder
 * except that it has different top and bottom radii. A truncated cone
 * can also be used to create cylinders and regular cones. The
 * truncated cone will be created centered about the origin, with the
 * y axis as its vertical axis. .
 *
 * @param {number} bottomRadius Bottom radius of truncated cone.
 * @param {number} topRadius Top radius of truncated cone.
 * @param {number} height Height of truncated cone.
 * @param {number} radialSubdivisions The number of subdivisions around the
 *     truncated cone.
 * @param {number} verticalSubdivisions The number of subdivisions down the
 *     truncated cone.
 * @param {boolean} [opt_topCap] Create top cap. Default = true.
 * @param {boolean} [opt_bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created cone vertices.
 * @memberOf module:twgl/primitives
 */
function createTruncatedConeVertices(bottomRadius, topRadius, height, radialSubdivisions, verticalSubdivisions, opt_topCap, opt_bottomCap) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }
  if (verticalSubdivisions < 1) {
    throw new Error('verticalSubdivisions must be 1 or greater');
  }
  const topCap = opt_topCap === undefined ? true : opt_topCap;
  const bottomCap = opt_bottomCap === undefined ? true : opt_bottomCap;
  const extra = (topCap ? 2 : 0) + (bottomCap ? 2 : 0);
  const numVertices = (radialSubdivisions + 1) * (verticalSubdivisions + 1 + extra);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices = createAugmentedTypedArray(3, radialSubdivisions * (verticalSubdivisions + extra / 2) * 2, Uint16Array);
  const vertsAroundEdge = radialSubdivisions + 1;

  // The slant of the cone is constant across its surface
  const slant = Math.atan2(bottomRadius - topRadius, height);
  const cosSlant = Math.cos(slant);
  const sinSlant = Math.sin(slant);
  const start = topCap ? -2 : 0;
  const end = verticalSubdivisions + (bottomCap ? 2 : 0);
  for (let yy = start; yy <= end; ++yy) {
    let v = yy / verticalSubdivisions;
    let y = height * v;
    let ringRadius;
    if (yy < 0) {
      y = 0;
      v = 1;
      ringRadius = bottomRadius;
    } else if (yy > verticalSubdivisions) {
      y = height;
      v = 1;
      ringRadius = topRadius;
    } else {
      ringRadius = bottomRadius + (topRadius - bottomRadius) * (yy / verticalSubdivisions);
    }
    if (yy === -2 || yy === verticalSubdivisions + 2) {
      ringRadius = 0;
      v = 0;
    }
    y -= height / 2;
    for (let ii = 0; ii < vertsAroundEdge; ++ii) {
      const sin = Math.sin(ii * Math.PI * 2 / radialSubdivisions);
      const cos = Math.cos(ii * Math.PI * 2 / radialSubdivisions);
      positions.push(sin * ringRadius, y, cos * ringRadius);
      if (yy < 0) {
        normals.push(0, -1, 0);
      } else if (yy > verticalSubdivisions) {
        normals.push(0, 1, 0);
      } else if (ringRadius === 0.0) {
        normals.push(0, 0, 0);
      } else {
        normals.push(sin * cosSlant, sinSlant, cos * cosSlant);
      }
      texcoords.push(ii / radialSubdivisions, 1 - v);
    }
  }
  for (let yy = 0; yy < verticalSubdivisions + extra; ++yy) {
    // eslint-disable-line
    if (yy === 1 && topCap || yy === verticalSubdivisions + extra - 2 && bottomCap) {
      continue;
    }
    for (let ii = 0; ii < radialSubdivisions; ++ii) {
      // eslint-disable-line
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 0) + 1 + ii, vertsAroundEdge * (yy + 1) + 1 + ii);
      indices.push(vertsAroundEdge * (yy + 0) + 0 + ii, vertsAroundEdge * (yy + 1) + 1 + ii, vertsAroundEdge * (yy + 1) + 0 + ii);
    }
  }
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * Expands RLE data
 * @param {number[]} rleData data in format of run-length, x, y, z, run-length, x, y, z
 * @param {number[]} [padding] value to add each entry with.
 * @return {number[]} the expanded rleData
 * @private
 */
function expandRLEData(rleData, padding) {
  padding = padding || [];
  const data = [];
  for (let ii = 0; ii < rleData.length; ii += 4) {
    const runLength = rleData[ii];
    const element = rleData.slice(ii + 1, ii + 4);
    element.push.apply(element, padding);
    for (let jj = 0; jj < runLength; ++jj) {
      data.push.apply(data, element);
    }
  }
  return data;
}

/**
 * Creates 3D 'F' BufferInfo.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function create3DFBufferInfo
 */

/**
 * Creates 3D 'F' buffers.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function create3DFBuffers
 */

/**
 * Creates 3D 'F' vertices.
 * An 'F' is useful because you can easily tell which way it is oriented.
 * The created 'F' has position, normal, texcoord, and color arrays.
 *
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function create3DFVertices() {
  const positions = [
  // left column front
  0, 0, 0, 0, 150, 0, 30, 0, 0, 0, 150, 0, 30, 150, 0, 30, 0, 0,
  // top rung front
  30, 0, 0, 30, 30, 0, 100, 0, 0, 30, 30, 0, 100, 30, 0, 100, 0, 0,
  // middle rung front
  30, 60, 0, 30, 90, 0, 67, 60, 0, 30, 90, 0, 67, 90, 0, 67, 60, 0,
  // left column back
  0, 0, 30, 30, 0, 30, 0, 150, 30, 0, 150, 30, 30, 0, 30, 30, 150, 30,
  // top rung back
  30, 0, 30, 100, 0, 30, 30, 30, 30, 30, 30, 30, 100, 0, 30, 100, 30, 30,
  // middle rung back
  30, 60, 30, 67, 60, 30, 30, 90, 30, 30, 90, 30, 67, 60, 30, 67, 90, 30,
  // top
  0, 0, 0, 100, 0, 0, 100, 0, 30, 0, 0, 0, 100, 0, 30, 0, 0, 30,
  // top rung front
  100, 0, 0, 100, 30, 0, 100, 30, 30, 100, 0, 0, 100, 30, 30, 100, 0, 30,
  // under top rung
  30, 30, 0, 30, 30, 30, 100, 30, 30, 30, 30, 0, 100, 30, 30, 100, 30, 0,
  // between top rung and middle
  30, 30, 0, 30, 60, 30, 30, 30, 30, 30, 30, 0, 30, 60, 0, 30, 60, 30,
  // top of middle rung
  30, 60, 0, 67, 60, 30, 30, 60, 30, 30, 60, 0, 67, 60, 0, 67, 60, 30,
  // front of middle rung
  67, 60, 0, 67, 90, 30, 67, 60, 30, 67, 60, 0, 67, 90, 0, 67, 90, 30,
  // bottom of middle rung.
  30, 90, 0, 30, 90, 30, 67, 90, 30, 30, 90, 0, 67, 90, 30, 67, 90, 0,
  // front of bottom
  30, 90, 0, 30, 150, 30, 30, 90, 30, 30, 90, 0, 30, 150, 0, 30, 150, 30,
  // bottom
  0, 150, 0, 0, 150, 30, 30, 150, 30, 0, 150, 0, 30, 150, 30, 30, 150, 0,
  // left side
  0, 0, 0, 0, 0, 30, 0, 150, 30, 0, 0, 0, 0, 150, 30, 0, 150, 0];
  const texcoords = [
  // left column front
  0.22, 0.19, 0.22, 0.79, 0.34, 0.19, 0.22, 0.79, 0.34, 0.79, 0.34, 0.19,
  // top rung front
  0.34, 0.19, 0.34, 0.31, 0.62, 0.19, 0.34, 0.31, 0.62, 0.31, 0.62, 0.19,
  // middle rung front
  0.34, 0.43, 0.34, 0.55, 0.49, 0.43, 0.34, 0.55, 0.49, 0.55, 0.49, 0.43,
  // left column back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,
  // top rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,
  // middle rung back
  0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1,
  // top
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
  // top rung front
  0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 0, 1,
  // under top rung
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
  // between top rung and middle
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,
  // top of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,
  // front of middle rung
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,
  // bottom of middle rung.
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
  // front of bottom
  0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1,
  // bottom
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0,
  // left side
  0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 1, 0];
  const normals = expandRLEData([
  // left column front
  // top rung front
  // middle rung front
  18, 0, 0, 1,
  // left column back
  // top rung back
  // middle rung back
  18, 0, 0, -1,
  // top
  6, 0, 1, 0,
  // top rung front
  6, 1, 0, 0,
  // under top rung
  6, 0, -1, 0,
  // between top rung and middle
  6, 1, 0, 0,
  // top of middle rung
  6, 0, 1, 0,
  // front of middle rung
  6, 1, 0, 0,
  // bottom of middle rung.
  6, 0, -1, 0,
  // front of bottom
  6, 1, 0, 0,
  // bottom
  6, 0, -1, 0,
  // left side
  6, -1, 0, 0]);
  const colors = expandRLEData([
  // left column front
  // top rung front
  // middle rung front
  18, 200, 70, 120,
  // left column back
  // top rung back
  // middle rung back
  18, 80, 70, 200,
  // top
  6, 70, 200, 210,
  // top rung front
  6, 200, 200, 70,
  // under top rung
  6, 210, 100, 70,
  // between top rung and middle
  6, 210, 160, 70,
  // top of middle rung
  6, 70, 180, 210,
  // front of middle rung
  6, 100, 70, 210,
  // bottom of middle rung.
  6, 76, 210, 100,
  // front of bottom
  6, 140, 210, 80,
  // bottom
  6, 90, 130, 110,
  // left side
  6, 160, 160, 220], [255]);
  const numVerts = positions.length / 3;
  const arrays = {
    position: createAugmentedTypedArray(3, numVerts),
    texcoord: createAugmentedTypedArray(2, numVerts),
    normal: createAugmentedTypedArray(3, numVerts),
    color: createAugmentedTypedArray(4, numVerts, Uint8Array),
    indices: createAugmentedTypedArray(3, numVerts / 3, Uint16Array)
  };
  arrays.position.push(positions);
  arrays.texcoord.push(texcoords);
  arrays.normal.push(normals);
  arrays.color.push(colors);
  for (let ii = 0; ii < numVerts; ++ii) {
    arrays.indices.push(ii);
  }
  return arrays;
}

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCresentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 * @function createCresentBuffers
 */

/**
 * Creates crescent BufferInfo.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCrescentBufferInfo
 */

/**
 * Creates crescent buffers.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCrescentBuffers
 */

/**
 * Creates crescent vertices.
 *
 * @param {number} verticalRadius The vertical radius of the crescent.
 * @param {number} outerRadius The outer radius of the crescent.
 * @param {number} innerRadius The inner radius of the crescent.
 * @param {number} thickness The thickness of the crescent.
 * @param {number} subdivisionsDown number of steps around the crescent.
 * @param {number} [startOffset] Where to start arc. Default 0.
 * @param {number} [endOffset] Where to end arg. Default 1.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createCrescentVertices(verticalRadius, outerRadius, innerRadius, thickness, subdivisionsDown, startOffset, endOffset) {
  if (subdivisionsDown <= 0) {
    throw new Error('subdivisionDown must be > 0');
  }
  startOffset = startOffset || 0;
  endOffset = endOffset || 1;
  const subdivisionsThick = 2;
  const offsetRange = endOffset - startOffset;
  const numVertices = (subdivisionsDown + 1) * 2 * (2 + subdivisionsThick);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  function lerp(a, b, s) {
    return a + (b - a) * s;
  }
  function createArc(arcRadius, x, normalMult, normalAdd, uMult, uAdd) {
    for (let z = 0; z <= subdivisionsDown; z++) {
      const uBack = x / (subdivisionsThick - 1);
      const v = z / subdivisionsDown;
      const xBack = (uBack - 0.5) * 2;
      const angle = (startOffset + v * offsetRange) * Math.PI;
      const s = Math.sin(angle);
      const c = Math.cos(angle);
      const radius = lerp(verticalRadius, arcRadius, s);
      const px = xBack * thickness;
      const py = c * verticalRadius;
      const pz = s * radius;
      positions.push(px, py, pz);
      const n = add(multiply([0, s, c], normalMult), normalAdd);
      normals.push(n);
      texcoords.push(uBack * uMult + uAdd, v);
    }
  }

  // Generate the individual vertices in our vertex buffer.
  for (let x = 0; x < subdivisionsThick; x++) {
    const uBack = (x / (subdivisionsThick - 1) - 0.5) * 2;
    createArc(outerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(outerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 0);
    createArc(innerRadius, x, [1, 1, 1], [0, 0, 0], 1, 0);
    createArc(innerRadius, x, [0, 0, 0], [uBack, 0, 0], 0, 1);
  }

  // Do outer surface.
  const indices = createAugmentedTypedArray(3, subdivisionsDown * 2 * (2 + subdivisionsThick), Uint16Array);
  function createSurface(leftArcOffset, rightArcOffset) {
    for (let z = 0; z < subdivisionsDown; ++z) {
      // Make triangle 1 of quad.
      indices.push(leftArcOffset + z + 0, leftArcOffset + z + 1, rightArcOffset + z + 0);

      // Make triangle 2 of quad.
      indices.push(leftArcOffset + z + 1, rightArcOffset + z + 1, rightArcOffset + z + 0);
    }
  }
  const numVerticesDown = subdivisionsDown + 1;
  // front
  createSurface(numVerticesDown * 0, numVerticesDown * 4);
  // right
  createSurface(numVerticesDown * 5, numVerticesDown * 7);
  // back
  createSurface(numVerticesDown * 6, numVerticesDown * 2);
  // left
  createSurface(numVerticesDown * 3, numVerticesDown * 1);
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * Creates cylinder BufferInfo. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createCylinderBufferInfo
 */

/**
 * Creates cylinder buffers. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createCylinderBuffers
 */

/**
 * Creates cylinder vertices. The cylinder will be created around the origin
 * along the y-axis.
 *
 * @param {number} radius Radius of cylinder.
 * @param {number} height Height of cylinder.
 * @param {number} radialSubdivisions The number of subdivisions around the cylinder.
 * @param {number} verticalSubdivisions The number of subdivisions down the cylinder.
 * @param {boolean} [topCap] Create top cap. Default = true.
 * @param {boolean} [bottomCap] Create bottom cap. Default = true.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createCylinderVertices(radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap) {
  return createTruncatedConeVertices(radius, radius, height, radialSubdivisions, verticalSubdivisions, topCap, bottomCap);
}

/**
 * Creates BufferInfo for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createTorusBufferInfo
 */

/**
 * Creates buffers for a torus
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createTorusBuffers
 */

/**
 * Creates vertices for a torus
 *
 * @param {number} radius radius of center of torus circle.
 * @param {number} thickness radius of torus ring.
 * @param {number} radialSubdivisions The number of subdivisions around the torus.
 * @param {number} bodySubdivisions The number of subdivisions around the body torus.
 * @param {boolean} [startAngle] start angle in radians. Default = 0.
 * @param {boolean} [endAngle] end angle in radians. Default = Math.PI * 2.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createTorusVertices(radius, thickness, radialSubdivisions, bodySubdivisions, startAngle, endAngle) {
  if (radialSubdivisions < 3) {
    throw new Error('radialSubdivisions must be 3 or greater');
  }
  if (bodySubdivisions < 3) {
    throw new Error('verticalSubdivisions must be 3 or greater');
  }
  startAngle = startAngle || 0;
  endAngle = endAngle || Math.PI * 2;
  const range = endAngle - startAngle;
  const radialParts = radialSubdivisions + 1;
  const bodyParts = bodySubdivisions + 1;
  const numVertices = radialParts * bodyParts;
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices = createAugmentedTypedArray(3, radialSubdivisions * bodySubdivisions * 2, Uint16Array);
  for (let slice = 0; slice < bodyParts; ++slice) {
    const v = slice / bodySubdivisions;
    const sliceAngle = v * Math.PI * 2;
    const sliceSin = Math.sin(sliceAngle);
    const ringRadius = radius + sliceSin * thickness;
    const ny = Math.cos(sliceAngle);
    const y = ny * thickness;
    for (let ring = 0; ring < radialParts; ++ring) {
      const u = ring / radialSubdivisions;
      const ringAngle = startAngle + u * range;
      const xSin = Math.sin(ringAngle);
      const zCos = Math.cos(ringAngle);
      const x = xSin * ringRadius;
      const z = zCos * ringRadius;
      const nx = xSin * sliceSin;
      const nz = zCos * sliceSin;
      positions.push(x, y, z);
      normals.push(nx, ny, nz);
      texcoords.push(u, 1 - v);
    }
  }
  for (let slice = 0; slice < bodySubdivisions; ++slice) {
    // eslint-disable-line
    for (let ring = 0; ring < radialSubdivisions; ++ring) {
      // eslint-disable-line
      const nextRingIndex = 1 + ring;
      const nextSliceIndex = 1 + slice;
      indices.push(radialParts * slice + ring, radialParts * nextSliceIndex + ring, radialParts * slice + nextRingIndex);
      indices.push(radialParts * nextSliceIndex + ring, radialParts * nextSliceIndex + nextRingIndex, radialParts * slice + nextRingIndex);
    }
  }
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * Creates a disc BufferInfo. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {module:twgl.BufferInfo} The created BufferInfo.
 * @memberOf module:twgl/primitives
 * @function createDiscBufferInfo
 */

/**
 * Creates disc buffers. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext.
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, WebGLBuffer>} The created buffers.
 * @memberOf module:twgl/primitives
 * @function createDiscBuffers
 */

/**
 * Creates disc vertices. The disc will be in the xz plane, centered at
 * the origin. When creating, at least 3 divisions, or pie
 * pieces, need to be specified, otherwise the triangles making
 * up the disc will be degenerate. You can also specify the
 * number of radial pieces `stacks`. A value of 1 for
 * stacks will give you a simple disc of pie pieces.  If you
 * want to create an annulus you can set `innerRadius` to a
 * value > 0. Finally, `stackPower` allows you to have the widths
 * increase or decrease as you move away from the center. This
 * is particularly useful when using the disc as a ground plane
 * with a fixed camera such that you don't need the resolution
 * of small triangles near the perimeter. For example, a value
 * of 2 will produce stacks whose outside radius increases with
 * the square of the stack index. A value of 1 will give uniform
 * stacks.
 *
 * @param {number} radius Radius of the ground plane.
 * @param {number} divisions Number of triangles in the ground plane (at least 3).
 * @param {number} [stacks] Number of radial divisions (default=1).
 * @param {number} [innerRadius] Default 0.
 * @param {number} [stackPower] Power to raise stack size to for decreasing width.
 * @return {Object.<string, TypedArray>} The created vertices.
 * @memberOf module:twgl/primitives
 */
function createDiscVertices(radius, divisions, stacks, innerRadius, stackPower) {
  if (divisions < 3) {
    throw new Error('divisions must be at least 3');
  }
  stacks = stacks ? stacks : 1;
  stackPower = stackPower ? stackPower : 1;
  innerRadius = innerRadius ? innerRadius : 0;

  // Note: We don't share the center vertex because that would
  // mess up texture coordinates.
  const numVertices = (divisions + 1) * (stacks + 1);
  const positions = createAugmentedTypedArray(3, numVertices);
  const normals = createAugmentedTypedArray(3, numVertices);
  const texcoords = createAugmentedTypedArray(2, numVertices);
  const indices = createAugmentedTypedArray(3, stacks * divisions * 2, Uint16Array);
  let firstIndex = 0;
  const radiusSpan = radius - innerRadius;
  const pointsPerStack = divisions + 1;

  // Build the disk one stack at a time.
  for (let stack = 0; stack <= stacks; ++stack) {
    const stackRadius = innerRadius + radiusSpan * Math.pow(stack / stacks, stackPower);
    for (let i = 0; i <= divisions; ++i) {
      const theta = 2.0 * Math.PI * i / divisions;
      const x = stackRadius * Math.cos(theta);
      const z = stackRadius * Math.sin(theta);
      positions.push(x, 0, z);
      normals.push(0, 1, 0);
      texcoords.push(1 - i / divisions, stack / stacks);
      if (stack > 0 && i !== divisions) {
        // a, b, c and d are the indices of the vertices of a quad.  unless
        // the current stack is the one closest to the center, in which case
        // the vertices a and b connect to the center vertex.
        const a = firstIndex + (i + 1);
        const b = firstIndex + i;
        const c = firstIndex + i - pointsPerStack;
        const d = firstIndex + (i + 1) - pointsPerStack;

        // Make a quad of the vertices a, b, c, d.
        indices.push(a, b, c);
        indices.push(a, c, d);
      }
    }
    firstIndex += divisions + 1;
  }
  return {
    position: positions,
    normal: normals,
    texcoord: texcoords,
    indices: indices
  };
}

/**
 * creates a random integer between 0 and range - 1 inclusive.
 * @param {number} range
 * @return {number} random value between 0 and range - 1 inclusive.
 * @private
 */
function randInt(range) {
  return Math.random() * range | 0;
}

/**
 * Used to supply random colors
 * @callback RandomColorFunc
 * @param {number} ndx index of triangle/quad if unindexed or index of vertex if indexed
 * @param {number} channel 0 = red, 1 = green, 2 = blue, 3 = alpha
 * @return {number} a number from 0 to 255
 * @memberOf module:twgl/primitives
 */

/**
 * @typedef {Object} RandomVerticesOptions
 * @property {number} [vertsPerColor] Defaults to 3 for non-indexed vertices
 * @property {module:twgl/primitives.RandomColorFunc} [rand] A function to generate random numbers
 * @memberOf module:twgl/primitives
 */

/**
 * Creates an augmentedTypedArray of random vertex colors.
 * If the vertices are indexed (have an indices array) then will
 * just make random colors. Otherwise assumes they are triangles
 * and makes one random color for every 3 vertices.
 * @param {Object.<string, AugmentedTypedArray>} vertices Vertices as returned from one of the createXXXVertices functions.
 * @param {module:twgl/primitives.RandomVerticesOptions} [options] options.
 * @return {Object.<string, AugmentedTypedArray>} same vertices as passed in with `color` added.
 * @memberOf module:twgl/primitives
 */
function makeRandomVertexColors(vertices, options) {
  options = options || {};
  const numElements = vertices.position.numElements;
  const vColors = createAugmentedTypedArray(4, numElements, Uint8Array);
  const rand = options.rand || function (ndx, channel) {
    return channel < 3 ? randInt(256) : 255;
  };
  vertices.color = vColors;
  if (vertices.indices) {
    // just make random colors if index
    for (let ii = 0; ii < numElements; ++ii) {
      vColors.push(rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3));
    }
  } else {
    // make random colors per triangle
    const numVertsPerColor = options.vertsPerColor || 3;
    const numSets = numElements / numVertsPerColor;
    for (let ii = 0; ii < numSets; ++ii) {
      // eslint-disable-line
      const color = [rand(ii, 0), rand(ii, 1), rand(ii, 2), rand(ii, 3)];
      for (let jj = 0; jj < numVertsPerColor; ++jj) {
        vColors.push(color);
      }
    }
  }
  return vertices;
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a buffers for them
 * @private
 */
function createBufferFunc(fn) {
  return function (gl) {
    const arrays = fn.apply(this, Array.prototype.slice.call(arguments, 1));
    return createBuffersFromArrays(gl, arrays);
  };
}

/**
 * creates a function that calls fn to create vertices and then
 * creates a bufferInfo object for them
 * @private
 */
function createBufferInfoFunc(fn) {
  return function (gl) {
    const arrays = fn.apply(null, Array.prototype.slice.call(arguments, 1));
    return createBufferInfoFromArrays(gl, arrays);
  };
}
const arraySpecPropertyNames = ["numComponents", "size", "type", "normalize", "stride", "offset", "attrib", "name", "attribName"];

/**
 * Copy elements from one array to another
 *
 * @param {Array|TypedArray} src source array
 * @param {Array|TypedArray} dst dest array
 * @param {number} dstNdx index in dest to copy src
 * @param {number} [offset] offset to add to copied values
 * @private
 */
function copyElements(src, dst, dstNdx, offset) {
  offset = offset || 0;
  const length = src.length;
  for (let ii = 0; ii < length; ++ii) {
    dst[dstNdx + ii] = src[ii] + offset;
  }
}

/**
 * Creates an array of the same time
 *
 * @param {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} srcArray array who's type to copy
 * @param {number} length size of new array
 * @return {(number[]|ArrayBufferView|module:twgl.FullArraySpec)} array with same type as srcArray
 * @private
 */
function createArrayOfSameType(srcArray, length) {
  const arraySrc = getArray$1(srcArray);
  const newArray = new arraySrc.constructor(length);
  let newArraySpec = newArray;
  // If it appears to have been augmented make new one augmented
  if (arraySrc.numComponents && arraySrc.numElements) {
    augmentTypedArray(newArray, arraySrc.numComponents);
  }
  // If it was a full spec make new one a full spec
  if (srcArray.data) {
    newArraySpec = {
      data: newArray
    };
    copyNamedProperties(arraySpecPropertyNames, srcArray, newArraySpec);
  }
  return newArraySpec;
}

/**
 * Concatenates sets of vertices
 *
 * Assumes the vertices match in composition. For example
 * if one set of vertices has positions, normals, and indices
 * all sets of vertices must have positions, normals, and indices
 * and of the same type.
 *
 * Example:
 *
 *      const cubeVertices = twgl.primitives.createCubeVertices(2);
 *      const sphereVertices = twgl.primitives.createSphereVertices(1, 10, 10);
 *      // move the sphere 2 units up
 *      twgl.primitives.reorientVertices(
 *          sphereVertices, twgl.m4.translation([0, 2, 0]));
 *      // merge the sphere with the cube
 *      const cubeSphereVertices = twgl.primitives.concatVertices(
 *          [cubeVertices, sphereVertices]);
 *      // turn them into WebGL buffers and attrib data
 *      const bufferInfo = twgl.createBufferInfoFromArrays(gl, cubeSphereVertices);
 *
 * @param {module:twgl.Arrays[]} arrays Array of arrays of vertices
 * @return {module:twgl.Arrays} The concatenated vertices.
 * @memberOf module:twgl/primitives
 */
function concatVertices(arrayOfArrays) {
  const names = {};
  let baseName;
  // get names of all arrays.
  // and numElements for each set of vertices
  for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
    const arrays = arrayOfArrays[ii];
    Object.keys(arrays).forEach(function (name) {
      // eslint-disable-line
      if (!names[name]) {
        names[name] = [];
      }
      if (!baseName && name !== 'indices') {
        baseName = name;
      }
      const arrayInfo = arrays[name];
      const numComponents = getNumComponents$1(arrayInfo, name);
      const array = getArray$1(arrayInfo);
      const numElements = array.length / numComponents;
      names[name].push(numElements);
    });
  }

  // compute length of combined array
  // and return one for reference
  function getLengthOfCombinedArrays(name) {
    let length = 0;
    let arraySpec;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray$1(arrayInfo);
      length += array.length;
      if (!arraySpec || arrayInfo.data) {
        arraySpec = arrayInfo;
      }
    }
    return {
      length: length,
      spec: arraySpec
    };
  }
  function copyArraysToNewArray(name, base, newArray) {
    let baseIndex = 0;
    let offset = 0;
    for (let ii = 0; ii < arrayOfArrays.length; ++ii) {
      const arrays = arrayOfArrays[ii];
      const arrayInfo = arrays[name];
      const array = getArray$1(arrayInfo);
      if (name === 'indices') {
        copyElements(array, newArray, offset, baseIndex);
        baseIndex += base[ii];
      } else {
        copyElements(array, newArray, offset);
      }
      offset += array.length;
    }
  }
  const base = names[baseName];
  const newArrays = {};
  Object.keys(names).forEach(function (name) {
    const info = getLengthOfCombinedArrays(name);
    const newArraySpec = createArrayOfSameType(info.spec, info.length);
    copyArraysToNewArray(name, base, getArray$1(newArraySpec));
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}

/**
 * Creates a duplicate set of vertices
 *
 * This is useful for calling reorientVertices when you
 * also want to keep the original available
 *
 * @param {module:twgl.Arrays} arrays of vertices
 * @return {module:twgl.Arrays} The duplicated vertices.
 * @memberOf module:twgl/primitives
 */
function duplicateVertices(arrays) {
  const newArrays = {};
  Object.keys(arrays).forEach(function (name) {
    const arraySpec = arrays[name];
    const srcArray = getArray$1(arraySpec);
    const newArraySpec = createArrayOfSameType(arraySpec, srcArray.length);
    copyElements(srcArray, getArray$1(newArraySpec), 0);
    newArrays[name] = newArraySpec;
  });
  return newArrays;
}
const create3DFBufferInfo = createBufferInfoFunc(create3DFVertices);
const create3DFBuffers = createBufferFunc(create3DFVertices);
const createCubeBufferInfo = createBufferInfoFunc(createCubeVertices);
const createCubeBuffers = createBufferFunc(createCubeVertices);
const createPlaneBufferInfo = createBufferInfoFunc(createPlaneVertices);
const createPlaneBuffers = createBufferFunc(createPlaneVertices);
const createSphereBufferInfo = createBufferInfoFunc(createSphereVertices);
const createSphereBuffers = createBufferFunc(createSphereVertices);
const createTruncatedConeBufferInfo = createBufferInfoFunc(createTruncatedConeVertices);
const createTruncatedConeBuffers = createBufferFunc(createTruncatedConeVertices);
const createXYQuadBufferInfo = createBufferInfoFunc(createXYQuadVertices);
const createXYQuadBuffers = createBufferFunc(createXYQuadVertices);
const createCrescentBufferInfo = createBufferInfoFunc(createCrescentVertices);
const createCrescentBuffers = createBufferFunc(createCrescentVertices);
const createCylinderBufferInfo = createBufferInfoFunc(createCylinderVertices);
const createCylinderBuffers = createBufferFunc(createCylinderVertices);
const createTorusBufferInfo = createBufferInfoFunc(createTorusVertices);
const createTorusBuffers = createBufferFunc(createTorusVertices);
const createDiscBufferInfo = createBufferInfoFunc(createDiscVertices);
const createDiscBuffers = createBufferFunc(createDiscVertices);

// these were mis-spelled until 4.12
const createCresentBufferInfo = createCrescentBufferInfo;
const createCresentBuffers = createCrescentBuffers;
const createCresentVertices = createCrescentVertices;
var primitives = /*#__PURE__*/Object.freeze({
  __proto__: null,
  create3DFBufferInfo: create3DFBufferInfo,
  create3DFBuffers: create3DFBuffers,
  create3DFVertices: create3DFVertices,
  createAugmentedTypedArray: createAugmentedTypedArray,
  createCubeBufferInfo: createCubeBufferInfo,
  createCubeBuffers: createCubeBuffers,
  createCubeVertices: createCubeVertices,
  createPlaneBufferInfo: createPlaneBufferInfo,
  createPlaneBuffers: createPlaneBuffers,
  createPlaneVertices: createPlaneVertices,
  createSphereBufferInfo: createSphereBufferInfo,
  createSphereBuffers: createSphereBuffers,
  createSphereVertices: createSphereVertices,
  createTruncatedConeBufferInfo: createTruncatedConeBufferInfo,
  createTruncatedConeBuffers: createTruncatedConeBuffers,
  createTruncatedConeVertices: createTruncatedConeVertices,
  createXYQuadBufferInfo: createXYQuadBufferInfo,
  createXYQuadBuffers: createXYQuadBuffers,
  createXYQuadVertices: createXYQuadVertices,
  createCresentBufferInfo: createCresentBufferInfo,
  createCresentBuffers: createCresentBuffers,
  createCresentVertices: createCresentVertices,
  createCrescentBufferInfo: createCrescentBufferInfo,
  createCrescentBuffers: createCrescentBuffers,
  createCrescentVertices: createCrescentVertices,
  createCylinderBufferInfo: createCylinderBufferInfo,
  createCylinderBuffers: createCylinderBuffers,
  createCylinderVertices: createCylinderVertices,
  createTorusBufferInfo: createTorusBufferInfo,
  createTorusBuffers: createTorusBuffers,
  createTorusVertices: createTorusVertices,
  createDiscBufferInfo: createDiscBufferInfo,
  createDiscBuffers: createDiscBuffers,
  createDiscVertices: createDiscVertices,
  deindexVertices: deindexVertices,
  flattenNormals: flattenNormals,
  makeRandomVertexColors: makeRandomVertexColors,
  reorientDirections: reorientDirections,
  reorientNormals: reorientNormals,
  reorientPositions: reorientPositions,
  reorientVertices: reorientVertices,
  concatVertices: concatVertices,
  duplicateVertices: duplicateVertices
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Gets the gl version as a number
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {number} version of gl
 * @private
 */
//function getVersionAsNumber(gl) {
//  return parseFloat(gl.getParameter(gl.VERSION).substr(6));
//}

/**
 * Check if context is WebGL 2.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 2.0
 * @memberOf module:twgl
 */
function isWebGL2(gl) {
  // This is the correct check but it's slow
  //  return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0") === 0;
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGL2RenderingContext;
  return !!gl.texStorage2D;
}

/**
 * Check if context is WebGL 1.0
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @return {bool} true if it's WebGL 1.0
 * @memberOf module:twgl
 */
function isWebGL1(gl) {
  // This is the correct check but it's slow
  // const version = getVersionAsNumber(gl);
  // return version <= 1.0 && version > 0.0;  // because as of 2016/5 Edge returns 0.96
  // This might also be the correct check but I'm assuming it's slow-ish
  // return gl instanceof WebGLRenderingContext;
  return !gl.texStorage2D;
}

/**
 * Gets a string for WebGL enum
 *
 * Note: Several enums are the same. Without more
 * context (which function) it's impossible to always
 * give the correct enum. As it is, for matching values
 * it gives all enums. Checking the WebGL2RenderingContext
 * that means
 *
 *      0     = ZERO | POINT | NONE | NO_ERROR
 *      1     = ONE | LINES | SYNC_FLUSH_COMMANDS_BIT
 *      32777 = BLEND_EQUATION_RGB | BLEND_EQUATION_RGB
 *      36662 = COPY_READ_BUFFER | COPY_READ_BUFFER_BINDING
 *      36663 = COPY_WRITE_BUFFER | COPY_WRITE_BUFFER_BINDING
 *      36006 = FRAMEBUFFER_BINDING | DRAW_FRAMEBUFFER_BINDING
 *
 * It's also not useful for bits really unless you pass in individual bits.
 * In other words
 *
 *     const bits = gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT;
 *     twgl.glEnumToString(gl, bits);  // not going to work
 *
 * Note that some enums only exist on extensions. If you
 * want them to show up you need to pass the extension at least
 * once. For example
 *
 *     const ext = gl.getExtension('WEBGL_compressed_texture_s3tc');
 *     if (ext) {
 *        twgl.glEnumToString(ext, 0);  // just prime the function
 *
 *        ..later..
 *
 *        const internalFormat = ext.COMPRESSED_RGB_S3TC_DXT1_EXT;
 *        console.log(twgl.glEnumToString(gl, internalFormat));
 *
 * Notice I didn't have to pass the extension the second time. This means
 * you can have place that generically gets an enum for texture formats for example.
 * and as long as you primed the function with the extensions
 *
 * If you're using `twgl.addExtensionsToContext` to enable your extensions
 * then twgl will automatically get the extension's enums.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext or any extension object
 * @param {number} value the value of the enum you want to look up.
 * @return {string} enum string or hex value
 * @memberOf module:twgl
 * @function glEnumToString
 */
const glEnumToString = function () {
  const haveEnumsForType = {};
  const enums = {};
  function addEnums(gl) {
    const type = gl.constructor.name;
    if (!haveEnumsForType[type]) {
      for (const key in gl) {
        if (typeof gl[key] === 'number') {
          const existing = enums[gl[key]];
          enums[gl[key]] = existing ? "".concat(existing, " | ").concat(key) : key;
        }
      }
      haveEnumsForType[type] = true;
    }
  }
  return function glEnumToString(gl, value) {
    addEnums(gl);
    return enums[value] || (typeof value === 'number' ? "0x".concat(value.toString(16)) : value);
  };
}();
var utils = /*#__PURE__*/Object.freeze({
  __proto__: null,
  glEnumToString: glEnumToString,
  isWebGL1: isWebGL1,
  isWebGL2: isWebGL2
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults$1 = {
  textureColor: new Uint8Array([128, 192, 255, 255]),
  textureOptions: {},
  crossOrigin: undefined
};
const isArrayBuffer$1 = isArrayBuffer;

// Should we make this on demand?
const getShared2DContext = function () {
  let s_ctx;
  return function getShared2DContext() {
    s_ctx = s_ctx || (typeof document !== 'undefined' && document.createElement ? document.createElement("canvas").getContext("2d") : null);
    return s_ctx;
  };
}();

// NOTE: Chrome supports 2D canvas in a Worker (behind flag as of v64 but
//       not only does Firefox NOT support it but Firefox freezes immediately
//       if you try to create one instead of just returning null and continuing.
//  : (global.OffscreenCanvas && (new global.OffscreenCanvas(1, 1)).getContext("2d"));  // OffscreenCanvas may not support 2d

// NOTE: We can maybe remove some of the need for the 2d canvas. In WebGL2
// we can use the various unpack settings. Otherwise we could try using
// the ability of an ImageBitmap to be cut. Unfortunately cutting an ImageBitmap
// is async and the current TWGL code expects a non-Async result though that
// might not be a problem. ImageBitmap though is not available in Edge or Safari
// as of 2018-01-02

/* PixelFormat */
const ALPHA = 0x1906;
const RGB = 0x1907;
const RGBA = 0x1908;
const LUMINANCE = 0x1909;
const LUMINANCE_ALPHA = 0x190A;
const DEPTH_COMPONENT = 0x1902;
const DEPTH_STENCIL = 0x84F9;

/* TextureWrapMode */
// const REPEAT                         = 0x2901;
// const MIRRORED_REPEAT                = 0x8370;
const CLAMP_TO_EDGE = 0x812f;

/* TextureMagFilter */
const NEAREST = 0x2600;
const LINEAR = 0x2601;

/* TextureMinFilter */
// const NEAREST_MIPMAP_NEAREST         = 0x2700;
// const LINEAR_MIPMAP_NEAREST          = 0x2701;
// const NEAREST_MIPMAP_LINEAR          = 0x2702;
// const LINEAR_MIPMAP_LINEAR           = 0x2703;

/* Texture Target */
const TEXTURE_2D = 0x0de1;
const TEXTURE_CUBE_MAP = 0x8513;
const TEXTURE_3D = 0x806f;
const TEXTURE_2D_ARRAY = 0x8c1a;

/* Cubemap Targets */
const TEXTURE_CUBE_MAP_POSITIVE_X = 0x8515;
const TEXTURE_CUBE_MAP_NEGATIVE_X = 0x8516;
const TEXTURE_CUBE_MAP_POSITIVE_Y = 0x8517;
const TEXTURE_CUBE_MAP_NEGATIVE_Y = 0x8518;
const TEXTURE_CUBE_MAP_POSITIVE_Z = 0x8519;
const TEXTURE_CUBE_MAP_NEGATIVE_Z = 0x851a;

/* Texture Parameters */
const TEXTURE_MIN_FILTER = 0x2801;
const TEXTURE_MAG_FILTER = 0x2800;
const TEXTURE_WRAP_S = 0x2802;
const TEXTURE_WRAP_T = 0x2803;
const TEXTURE_WRAP_R = 0x8072;
const TEXTURE_MIN_LOD = 0x813a;
const TEXTURE_MAX_LOD = 0x813b;
const TEXTURE_BASE_LEVEL = 0x813c;
const TEXTURE_MAX_LEVEL = 0x813d;

/* Pixel store */
const UNPACK_ALIGNMENT = 0x0cf5;
const UNPACK_ROW_LENGTH = 0x0cf2;
const UNPACK_IMAGE_HEIGHT = 0x806e;
const UNPACK_SKIP_PIXELS = 0x0cf4;
const UNPACK_SKIP_ROWS = 0x0cf3;
const UNPACK_SKIP_IMAGES = 0x806d;
const UNPACK_COLORSPACE_CONVERSION_WEBGL = 0x9243;
const UNPACK_PREMULTIPLY_ALPHA_WEBGL = 0x9241;
const UNPACK_FLIP_Y_WEBGL = 0x9240;
const R8 = 0x8229;
const R8_SNORM = 0x8F94;
const R16F = 0x822D;
const R32F = 0x822E;
const R8UI = 0x8232;
const R8I = 0x8231;
const RG16UI = 0x823A;
const RG16I = 0x8239;
const RG32UI = 0x823C;
const RG32I = 0x823B;
const RG8 = 0x822B;
const RG8_SNORM = 0x8F95;
const RG16F = 0x822F;
const RG32F = 0x8230;
const RG8UI = 0x8238;
const RG8I = 0x8237;
const R16UI = 0x8234;
const R16I = 0x8233;
const R32UI = 0x8236;
const R32I = 0x8235;
const RGB8 = 0x8051;
const SRGB8 = 0x8C41;
const RGB565 = 0x8D62;
const RGB8_SNORM = 0x8F96;
const R11F_G11F_B10F = 0x8C3A;
const RGB9_E5 = 0x8C3D;
const RGB16F = 0x881B;
const RGB32F = 0x8815;
const RGB8UI = 0x8D7D;
const RGB8I = 0x8D8F;
const RGB16UI = 0x8D77;
const RGB16I = 0x8D89;
const RGB32UI = 0x8D71;
const RGB32I = 0x8D83;
const RGBA8 = 0x8058;
const SRGB8_ALPHA8 = 0x8C43;
const RGBA8_SNORM = 0x8F97;
const RGB5_A1 = 0x8057;
const RGBA4 = 0x8056;
const RGB10_A2 = 0x8059;
const RGBA16F = 0x881A;
const RGBA32F = 0x8814;
const RGBA8UI = 0x8D7C;
const RGBA8I = 0x8D8E;
const RGB10_A2UI = 0x906F;
const RGBA16UI = 0x8D76;
const RGBA16I = 0x8D88;
const RGBA32I = 0x8D82;
const RGBA32UI = 0x8D70;
const DEPTH_COMPONENT16 = 0x81A5;
const DEPTH_COMPONENT24 = 0x81A6;
const DEPTH_COMPONENT32F = 0x8CAC;
const DEPTH32F_STENCIL8 = 0x8CAD;
const DEPTH24_STENCIL8 = 0x88F0;

/* DataType */
const BYTE$2 = 0x1400;
const UNSIGNED_BYTE$2 = 0x1401;
const SHORT$2 = 0x1402;
const UNSIGNED_SHORT$2 = 0x1403;
const INT$2 = 0x1404;
const UNSIGNED_INT$2 = 0x1405;
const FLOAT$2 = 0x1406;
const UNSIGNED_SHORT_4_4_4_4$1 = 0x8033;
const UNSIGNED_SHORT_5_5_5_1$1 = 0x8034;
const UNSIGNED_SHORT_5_6_5$1 = 0x8363;
const HALF_FLOAT$1 = 0x140B;
const HALF_FLOAT_OES = 0x8D61; // Thanks Khronos for making this different >:(
const UNSIGNED_INT_2_10_10_10_REV$1 = 0x8368;
const UNSIGNED_INT_10F_11F_11F_REV$1 = 0x8C3B;
const UNSIGNED_INT_5_9_9_9_REV$1 = 0x8C3E;
const FLOAT_32_UNSIGNED_INT_24_8_REV$1 = 0x8DAD;
const UNSIGNED_INT_24_8$1 = 0x84FA;
const RG = 0x8227;
const RG_INTEGER = 0x8228;
const RED = 0x1903;
const RED_INTEGER = 0x8D94;
const RGB_INTEGER = 0x8D98;
const RGBA_INTEGER = 0x8D99;
const formatInfo = {};
{
  // NOTE: this is named `numColorComponents` vs `numComponents` so we can let Uglify mangle
  // the name.
  const f = formatInfo;
  f[ALPHA] = {
    numColorComponents: 1
  };
  f[LUMINANCE] = {
    numColorComponents: 1
  };
  f[LUMINANCE_ALPHA] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RED] = {
    numColorComponents: 1
  };
  f[RED_INTEGER] = {
    numColorComponents: 1
  };
  f[RG] = {
    numColorComponents: 2
  };
  f[RG_INTEGER] = {
    numColorComponents: 2
  };
  f[RGB] = {
    numColorComponents: 3
  };
  f[RGB_INTEGER] = {
    numColorComponents: 3
  };
  f[RGBA] = {
    numColorComponents: 4
  };
  f[RGBA_INTEGER] = {
    numColorComponents: 4
  };
  f[DEPTH_COMPONENT] = {
    numColorComponents: 1
  };
  f[DEPTH_STENCIL] = {
    numColorComponents: 2
  };
}

/**
 * @typedef {Object} TextureFormatDetails
 * @property {number} textureFormat format to pass texImage2D and similar functions.
 * @property {boolean} colorRenderable true if you can render to this format of texture.
 * @property {boolean} textureFilterable true if you can filter the texture, false if you can ony use `NEAREST`.
 * @property {number[]} type Array of possible types you can pass to texImage2D and similar function
 * @property {Object.<number,number>} bytesPerElementMap A map of types to bytes per element
 * @private
 */

let s_textureInternalFormatInfo;
function getTextureInternalFormatInfo(internalFormat) {
  if (!s_textureInternalFormatInfo) {
    // NOTE: these properties need unique names so we can let Uglify mangle the name.
    const t = {};
    // unsized formats
    t[ALPHA] = {
      textureFormat: ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2]
    };
    t[LUMINANCE] = {
      textureFormat: LUMINANCE,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1, 2, 2, 4],
      type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2]
    };
    t[LUMINANCE_ALPHA] = {
      textureFormat: LUMINANCE_ALPHA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2, 4, 4, 8],
      type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2]
    };
    t[RGB] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 6, 6, 12, 2],
      type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2, UNSIGNED_SHORT_5_6_5$1]
    };
    t[RGBA] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 8, 8, 16, 2, 2],
      type: [UNSIGNED_BYTE$2, HALF_FLOAT$1, HALF_FLOAT_OES, FLOAT$2, UNSIGNED_SHORT_4_4_4_4$1, UNSIGNED_SHORT_5_5_5_1$1]
    };
    t[DEPTH_COMPONENT] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_INT$2, UNSIGNED_SHORT$2]
    };

    // sized formats
    t[R8] = {
      textureFormat: RED,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE$2]
    };
    t[R8_SNORM] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [1],
      type: [BYTE$2]
    };
    t[R16F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [FLOAT$2, HALF_FLOAT$1]
    };
    t[R32F] = {
      textureFormat: RED,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT$2]
    };
    t[R8UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [UNSIGNED_BYTE$2]
    };
    t[R8I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [1],
      type: [BYTE$2]
    };
    t[R16UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_SHORT$2]
    };
    t[R16I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [SHORT$2]
    };
    t[R32UI] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT$2]
    };
    t[R32I] = {
      textureFormat: RED_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [INT$2]
    };
    t[RG8] = {
      textureFormat: RG,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE$2]
    };
    t[RG8_SNORM] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [2],
      type: [BYTE$2]
    };
    t[RG16F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [8, 4],
      type: [FLOAT$2, HALF_FLOAT$1]
    };
    t[RG32F] = {
      textureFormat: RG,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [FLOAT$2]
    };
    t[RG8UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [UNSIGNED_BYTE$2]
    };
    t[RG8I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2],
      type: [BYTE$2]
    };
    t[RG16UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_SHORT$2]
    };
    t[RG16I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [SHORT$2]
    };
    t[RG32UI] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_INT$2]
    };
    t[RG32I] = {
      textureFormat: RG_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [INT$2]
    };
    t[RGB8] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE$2]
    };
    t[SRGB8] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE$2]
    };
    t[RGB565] = {
      textureFormat: RGB,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [3, 2],
      type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_5_6_5$1]
    };
    t[RGB8_SNORM] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [3],
      type: [BYTE$2]
    };
    t[R11F_G11F_B10F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT$2, HALF_FLOAT$1, UNSIGNED_INT_10F_11F_11F_REV$1]
    };
    t[RGB9_E5] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6, 4],
      type: [FLOAT$2, HALF_FLOAT$1, UNSIGNED_INT_5_9_9_9_REV$1]
    };
    t[RGB16F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [12, 6],
      type: [FLOAT$2, HALF_FLOAT$1]
    };
    t[RGB32F] = {
      textureFormat: RGB,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [FLOAT$2]
    };
    t[RGB8UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [UNSIGNED_BYTE$2]
    };
    t[RGB8I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [3],
      type: [BYTE$2]
    };
    t[RGB16UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [UNSIGNED_SHORT$2]
    };
    t[RGB16I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [6],
      type: [SHORT$2]
    };
    t[RGB32UI] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [UNSIGNED_INT$2]
    };
    t[RGB32I] = {
      textureFormat: RGB_INTEGER,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [12],
      type: [INT$2]
    };
    t[RGBA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE$2]
    };
    t[SRGB8_ALPHA8] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE$2]
    };
    t[RGBA8_SNORM] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [BYTE$2]
    };
    t[RGB5_A1] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2, 4],
      type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_5_5_5_1$1, UNSIGNED_INT_2_10_10_10_REV$1]
    };
    t[RGBA4] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4, 2],
      type: [UNSIGNED_BYTE$2, UNSIGNED_SHORT_4_4_4_4$1]
    };
    t[RGB10_A2] = {
      textureFormat: RGBA,
      colorRenderable: true,
      textureFilterable: true,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV$1]
    };
    t[RGBA16F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: true,
      bytesPerElement: [16, 8],
      type: [FLOAT$2, HALF_FLOAT$1]
    };
    t[RGBA32F] = {
      textureFormat: RGBA,
      colorRenderable: false,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [FLOAT$2]
    };
    t[RGBA8UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_BYTE$2]
    };
    t[RGBA8I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [BYTE$2]
    };
    t[RGB10_A2UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_2_10_10_10_REV$1]
    };
    t[RGBA16UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [UNSIGNED_SHORT$2]
    };
    t[RGBA16I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [8],
      type: [SHORT$2]
    };
    t[RGBA32I] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [INT$2]
    };
    t[RGBA32UI] = {
      textureFormat: RGBA_INTEGER,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [16],
      type: [UNSIGNED_INT$2]
    };
    // Sized Internal
    t[DEPTH_COMPONENT16] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [2, 4],
      type: [UNSIGNED_SHORT$2, UNSIGNED_INT$2]
    };
    t[DEPTH_COMPONENT24] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT$2]
    };
    t[DEPTH_COMPONENT32F] = {
      textureFormat: DEPTH_COMPONENT,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT$2]
    };
    t[DEPTH24_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [UNSIGNED_INT_24_8$1]
    };
    t[DEPTH32F_STENCIL8] = {
      textureFormat: DEPTH_STENCIL,
      colorRenderable: true,
      textureFilterable: false,
      bytesPerElement: [4],
      type: [FLOAT_32_UNSIGNED_INT_24_8_REV$1]
    };
    Object.keys(t).forEach(function (internalFormat) {
      const info = t[internalFormat];
      info.bytesPerElementMap = {};
      info.bytesPerElement.forEach(function (bytesPerElement, ndx) {
        const type = info.type[ndx];
        info.bytesPerElementMap[type] = bytesPerElement;
      });
    });
    s_textureInternalFormatInfo = t;
  }
  return s_textureInternalFormatInfo[internalFormat];
}

/**
 * Gets the number of bytes per element for a given internalFormat / type
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @param {number} type The type parameter for texImage2D etc..
 * @return {number} the number of bytes per element for the given internalFormat, type combo
 * @memberOf module:twgl/textures
 */
function getBytesPerElementForInternalFormat(internalFormat, type) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  const bytesPerElement = info.bytesPerElementMap[type];
  if (bytesPerElement === undefined) {
    throw "unknown internal format";
  }
  return bytesPerElement;
}

/**
 * Info related to a specific texture internalFormat as returned
 * from {@link module:twgl/textures.getFormatAndTypeForInternalFormat}.
 *
 * @typedef {Object} TextureFormatInfo
 * @property {number} format Format to pass to texImage2D and related functions
 * @property {number} type Type to pass to texImage2D and related functions
 * @memberOf module:twgl/textures
 */

/**
 * Gets the format and type for a given internalFormat
 *
 * @param {number} internalFormat The internal format
 * @return {module:twgl/textures.TextureFormatInfo} the corresponding format and type,
 * @memberOf module:twgl/textures
 */
function getFormatAndTypeForInternalFormat(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return {
    format: info.textureFormat,
    type: info.type[0]
  };
}

/**
 * Returns true if value is power of 2
 * @param {number} value number to check.
 * @return true if value is power of 2
 * @private
 */
function isPowerOf2(value) {
  return (value & value - 1) === 0;
}

/**
 * Gets whether or not we can generate mips for the given
 * internal format.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number} width The width parameter from texImage2D etc..
 * @param {number} height The height parameter from texImage2D etc..
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canGenerateMipmap(gl, width, height, internalFormat) {
  if (!isWebGL2(gl)) {
    return isPowerOf2(width) && isPowerOf2(height);
  }
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.colorRenderable && info.textureFilterable;
}

/**
 * Gets whether or not we can generate mips for the given format
 * @param {number} internalFormat The internalFormat parameter from texImage2D etc..
 * @return {boolean} true if we can generate mips
 * @memberOf module:twgl/textures
 */
function canFilter(internalFormat) {
  const info = getTextureInternalFormatInfo(internalFormat);
  if (!info) {
    throw "unknown internal format";
  }
  return info.textureFilterable;
}

/**
 * Gets the number of components for a given image format.
 * @param {number} format the format.
 * @return {number} the number of components for the format.
 * @memberOf module:twgl/textures
 */
function getNumComponentsForFormat(format) {
  const info = formatInfo[format];
  if (!info) {
    throw "unknown format: " + format;
  }
  return info.numColorComponents;
}

/**
 * Gets the texture type for a given array type.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @return {number} the gl texture type
 * @private
 */
function getTextureTypeForArrayType(gl, src, defaultType) {
  if (isArrayBuffer$1(src)) {
    return getGLTypeForTypedArray(src);
  }
  return defaultType || UNSIGNED_BYTE$2;
}
function guessDimensions(gl, target, width, height, numElements) {
  if (numElements % 1 !== 0) {
    throw "can't guess dimensions";
  }
  if (!width && !height) {
    const size = Math.sqrt(numElements / (target === TEXTURE_CUBE_MAP ? 6 : 1));
    if (size % 1 === 0) {
      width = size;
      height = size;
    } else {
      width = numElements;
      height = 1;
    }
  } else if (!height) {
    height = numElements / width;
    if (height % 1) {
      throw "can't guess dimensions";
    }
  } else if (!width) {
    width = numElements / height;
    if (width % 1) {
      throw "can't guess dimensions";
    }
  }
  return {
    width: width,
    height: height
  };
}

/**
 * Sets the default texture color.
 *
 * The default texture color is used when loading textures from
 * urls. Because the URL will be loaded async we'd like to be
 * able to use the texture immediately. By putting a 1x1 pixel
 * color in the texture we can start using the texture before
 * the URL has loaded.
 *
 * @param {number[]} color Array of 4 values in the range 0 to 1
 * @deprecated see {@link module:twgl.setDefaults}
 * @memberOf module:twgl/textures
 */
function setDefaultTextureColor(color) {
  defaults$1.textureColor = new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}
function setDefaults$1(newDefaults) {
  copyExistingProperties(newDefaults, defaults$1);
  if (newDefaults.textureColor) {
    setDefaultTextureColor(newDefaults.textureColor);
  }
}

/**
 * A function to generate the source for a texture.
 * @callback TextureFunc
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options the texture options
 * @return {*} Returns any of the things documented for `src` for {@link module:twgl.TextureOptions}.
 * @memberOf module:twgl
 */

/**
 * Texture options passed to most texture functions. Each function will use whatever options
 * are appropriate for its needs. This lets you pass the same options to all functions.
 *
 * Note: A `TexImageSource` is defined in the WebGL spec as a `HTMLImageElement`, `HTMLVideoElement`,
 * `HTMLCanvasElement`, `ImageBitmap`, or `ImageData`.
 *
 * @typedef {Object} TextureOptions
 * @property {number} [target] the type of texture `gl.TEXTURE_2D` or `gl.TEXTURE_CUBE_MAP`. Defaults to `gl.TEXTURE_2D`.
 * @property {number} [level] the mip level to affect. Defaults to 0. Note, if set auto will be considered false unless explicitly set to true.
 * @property {number} [width] the width of the texture. Only used if src is an array or typed array or null.
 * @property {number} [height] the height of a texture. Only used if src is an array or typed array or null.
 * @property {number} [depth] the depth of a texture. Only used if src is an array or type array or null and target is `TEXTURE_3D` .
 * @property {number} [min] the min filter setting (eg. `gl.LINEAR`). Defaults to `gl.NEAREST_MIPMAP_LINEAR`
 *     or if texture is not a power of 2 on both dimensions then defaults to `gl.LINEAR`.
 * @property {number} [mag] the mag filter setting (eg. `gl.LINEAR`). Defaults to `gl.LINEAR`
 * @property {number} [minMag] both the min and mag filter settings.
 * @property {number} [internalFormat] internal format for texture. Defaults to `gl.RGBA`
 * @property {number} [format] format for texture. Defaults to `gl.RGBA`.
 * @property {number} [type] type for texture. Defaults to `gl.UNSIGNED_BYTE` unless `src` is ArrayBufferView. If `src`
 *     is ArrayBufferView defaults to type that matches ArrayBufferView type.
 * @property {number} [wrap] Texture wrapping for both S and T (and R if TEXTURE_3D or WebGLSampler). Defaults to `gl.REPEAT` for 2D unless src is WebGL1 and src not npot and `gl.CLAMP_TO_EDGE` for cube
 * @property {number} [wrapS] Texture wrapping for S. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapT] Texture wrapping for T. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [wrapR] Texture wrapping for R. Defaults to `gl.REPEAT` and `gl.CLAMP_TO_EDGE` for cube. If set takes precedence over `wrap`.
 * @property {number} [minLod] TEXTURE_MIN_LOD setting
 * @property {number} [maxLod] TEXTURE_MAX_LOD setting
 * @property {number} [baseLevel] TEXTURE_BASE_LEVEL setting
 * @property {number} [maxLevel] TEXTURE_MAX_LEVEL setting
 * @property {number} [unpackAlignment] The `gl.UNPACK_ALIGNMENT` used when uploading an array. Defaults to 1.
 * @property {number[]|ArrayBufferView} [color] Color to initialize this texture with if loading an image asynchronously.
 *     The default use a blue 1x1 pixel texture. You can set another default by calling `twgl.setDefaults`
 *     or you can set an individual texture's initial color by setting this property. Example: `[1, .5, .5, 1]` = pink
 * @property {number} [premultiplyAlpha] Whether or not to premultiply alpha. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [flipY] Whether or not to flip the texture vertically on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {number} [colorspaceConversion] Whether or not to let the browser do colorspace conversion of the texture on upload. Defaults to whatever the current setting is.
 *     This lets you set it once before calling `twgl.createTexture` or `twgl.createTextures` and only override
 *     the current setting for specific textures.
 * @property {boolean} [auto] If `undefined` or `true`, in WebGL1, texture filtering is set automatically for non-power of 2 images and
 *    mips are generated for power of 2 images. In WebGL2 mips are generated if they can be. Note: if `level` is set above
 *    then then `auto` is assumed to be `false` unless explicity set to `true`.
 * @property {number[]} [cubeFaceOrder] The order that cube faces are pulled out of an img or set of images. The default is
 *
 *     [gl.TEXTURE_CUBE_MAP_POSITIVE_X,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
 *      gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
 *      gl.TEXTURE_CUBE_MAP_NEGATIVE_Z]
 *
 * @property {(number[]|ArrayBufferView|TexImageSource|TexImageSource[]|string|string[]|module:twgl.TextureFunc)} [src] source for texture
 *
 *    If `string` then it's assumed to be a URL to an image. The image will be downloaded async. A usable
 *    1x1 pixel texture will be returned immediately. The texture will be updated once the image has downloaded.
 *    If `target` is `gl.TEXTURE_CUBE_MAP` will attempt to divide image into 6 square pieces. 1x6, 6x1, 3x2, 2x3.
 *    The pieces will be uploaded in `cubeFaceOrder`
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_CUBE_MAP` then it must have 6 entries, one for each face of a cube map.
 *
 *    If `string[]` or `TexImageSource[]` and target is `gl.TEXTURE_2D_ARRAY` then each entry is a slice of the a 2d array texture
 *    and will be scaled to the specified width and height OR to the size of the first image that loads.
 *
 *    If `TexImageSource` then it wil be used immediately to create the contents of the texture. Examples `HTMLImageElement`,
 *    `HTMLCanvasElement`, `HTMLVideoElement`.
 *
 *    If `number[]` or `ArrayBufferView` it's assumed to be data for a texture. If `width` or `height` is
 *    not specified it is guessed as follows. First the number of elements is computed by `src.length / numComponents`
 *    where `numComponents` is derived from `format`. If `target` is `gl.TEXTURE_CUBE_MAP` then `numElements` is divided
 *    by 6. Then
 *
 *    *   If neither `width` nor `height` are specified and `sqrt(numElements)` is an integer then width and height
 *        are set to `sqrt(numElements)`. Otherwise `width = numElements` and `height = 1`.
 *
 *    *   If only one of `width` or `height` is specified then the other equals `numElements / specifiedDimension`.
 *
 * If `number[]` will be converted to `type`.
 *
 * If `src` is a function it will be called with a `WebGLRenderingContext` and these options.
 * Whatever it returns is subject to these rules. So it can return a string url, an `HTMLElement`
 * an array etc...
 *
 * If `src` is undefined then an empty texture will be created of size `width` by `height`.
 *
 * @property {string} [crossOrigin] What to set the crossOrigin property of images when they are downloaded.
 *    default: undefined. Also see {@link module:twgl.setDefaults}.
 *
 * @memberOf module:twgl
 */

/**
 * Sets any packing state that will be set based on the options.
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setPackState(gl, options) {
  if (options.colorspaceConversion !== undefined) {
    gl.pixelStorei(UNPACK_COLORSPACE_CONVERSION_WEBGL, options.colorspaceConversion);
  }
  if (options.premultiplyAlpha !== undefined) {
    gl.pixelStorei(UNPACK_PREMULTIPLY_ALPHA_WEBGL, options.premultiplyAlpha);
  }
  if (options.flipY !== undefined) {
    gl.pixelStorei(UNPACK_FLIP_Y_WEBGL, options.flipY);
  }
}

/**
 * Set skip state to defaults
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @private
 */
function setSkipStateToDefault(gl) {
  gl.pixelStorei(UNPACK_ALIGNMENT, 4);
  if (isWebGL2(gl)) {
    gl.pixelStorei(UNPACK_ROW_LENGTH, 0);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_PIXELS, 0);
    gl.pixelStorei(UNPACK_SKIP_ROWS, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
  }
}

/**
 * Sets the parameters of a texture or sampler
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {number|WebGLSampler} target texture target or sampler
 * @param {function()} parameteriFn texParameteri or samplerParameteri fn
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @private
 */
function setTextureSamplerParameters(gl, target, parameteriFn, options) {
  if (options.minMag) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.minMag);
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.minMag);
  }
  if (options.min) {
    parameteriFn.call(gl, target, TEXTURE_MIN_FILTER, options.min);
  }
  if (options.mag) {
    parameteriFn.call(gl, target, TEXTURE_MAG_FILTER, options.mag);
  }
  if (options.wrap) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrap);
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrap);
    if (target === TEXTURE_3D || isSampler(gl, target)) {
      parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrap);
    }
  }
  if (options.wrapR) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_R, options.wrapR);
  }
  if (options.wrapS) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_S, options.wrapS);
  }
  if (options.wrapT) {
    parameteriFn.call(gl, target, TEXTURE_WRAP_T, options.wrapT);
  }
  if (options.minLod) {
    parameteriFn.call(gl, target, TEXTURE_MIN_LOD, options.minLod);
  }
  if (options.maxLod) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LOD, options.maxLod);
  }
  if (options.baseLevel) {
    parameteriFn.call(gl, target, TEXTURE_BASE_LEVEL, options.baseLevel);
  }
  if (options.maxLevel) {
    parameteriFn.call(gl, target, TEXTURE_MAX_LEVEL, options.maxLevel);
  }
}

/**
 * Sets the texture parameters of a texture.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureParameters(gl, tex, options) {
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  setTextureSamplerParameters(gl, target, gl.texParameteri, options);
}

/**
 * Sets the sampler parameters of a sampler.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLSampler} sampler the WebGLSampler to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setSamplerParameters(gl, sampler, options) {
  setTextureSamplerParameters(gl, sampler, gl.samplerParameteri, options);
}

/**
 * Creates a new sampler object and sets parameters.
 *
 * Example:
 *
 *      const sampler = twgl.createSampler(gl, {
 *        minMag: gl.NEAREST,         // sets both TEXTURE_MIN_FILTER and TEXTURE_MAG_FILTER
 *        wrap: gl.CLAMP_TO_NEAREST,  // sets both TEXTURE_WRAP_S and TEXTURE_WRAP_T and TEXTURE_WRAP_R
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per sampler.
 * @return {Object.<string,WebGLSampler>} the created samplers by name
 * @private
 */
function createSampler(gl, options) {
  const sampler = gl.createSampler();
  setSamplerParameters(gl, sampler, options);
  return sampler;
}

/**
 * Creates a multiple sampler objects and sets parameters on each.
 *
 * Example:
 *
 *      const samplers = twgl.createSamplers(gl, {
 *        nearest: {
 *          minMag: gl.NEAREST,
 *        },
 *        nearestClampS: {
 *          minMag: gl.NEAREST,
 *          wrapS: gl.CLAMP_TO_NEAREST,
 *        },
 *        linear: {
 *          minMag: gl.LINEAR,
 *        },
 *        nearestClamp: {
 *          minMag: gl.NEAREST,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClamp: {
 *          minMag: gl.LINEAR,
 *          wrap: gl.CLAMP_TO_EDGE,
 *        },
 *        linearClampT: {
 *          minMag: gl.LINEAR,
 *          wrapT: gl.CLAMP_TO_EDGE,
 *        },
 *      });
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set on the sampler
 * @private
 */
function createSamplers(gl, samplerOptions) {
  const samplers = {};
  Object.keys(samplerOptions).forEach(function (name) {
    samplers[name] = createSampler(gl, samplerOptions[name]);
  });
  return samplers;
}

/**
 * Makes a 1x1 pixel
 * If no color is passed in uses the default color which can be set by calling `setDefaultTextureColor`.
 * @param {(number[]|ArrayBufferView)} [color] The color using 0-1 values
 * @return {Uint8Array} Unit8Array with color.
 * @private
 */
function make1Pixel(color) {
  color = color || defaults$1.textureColor;
  if (isArrayBuffer$1(color)) {
    return color;
  }
  return new Uint8Array([color[0] * 255, color[1] * 255, color[2] * 255, color[3] * 255]);
}

/**
 * Sets filtering or generates mips for texture based on width or height
 * If width or height is not passed in uses `options.width` and//or `options.height`
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @param {number} [width] width of texture
 * @param {number} [height] height of texture
 * @param {number} [internalFormat] The internalFormat parameter from texImage2D etc..
 * @memberOf module:twgl/textures
 */
function setTextureFilteringForSize(gl, tex, options, width, height, internalFormat) {
  options = options || defaults$1.textureOptions;
  internalFormat = internalFormat || RGBA;
  const target = options.target || TEXTURE_2D;
  width = width || options.width;
  height = height || options.height;
  gl.bindTexture(target, tex);
  if (canGenerateMipmap(gl, width, height, internalFormat)) {
    gl.generateMipmap(target);
  } else {
    const filtering = canFilter(internalFormat) ? LINEAR : NEAREST;
    gl.texParameteri(target, TEXTURE_MIN_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_MAG_FILTER, filtering);
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
}
function shouldAutomaticallySetTextureFilteringForSize(options) {
  return options.auto === true || options.auto === undefined && options.level === undefined;
}

/**
 * Gets an array of cubemap face enums
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @return {number[]} cubemap face enums
 * @private
 */
function getCubeFaceOrder(gl, options) {
  options = options || {};
  return options.cubeFaceOrder || [TEXTURE_CUBE_MAP_POSITIVE_X, TEXTURE_CUBE_MAP_NEGATIVE_X, TEXTURE_CUBE_MAP_POSITIVE_Y, TEXTURE_CUBE_MAP_NEGATIVE_Y, TEXTURE_CUBE_MAP_POSITIVE_Z, TEXTURE_CUBE_MAP_NEGATIVE_Z];
}

/**
 * @typedef {Object} FaceInfo
 * @property {number} face gl enum for texImage2D
 * @property {number} ndx face index (0 - 5) into source data
 * @ignore
 */

/**
 * Gets an array of FaceInfos
 * There's a bug in some NVidia drivers that will crash the driver if
 * `gl.TEXTURE_CUBE_MAP_POSITIVE_X` is not uploaded first. So, we take
 * the user's desired order from his faces to WebGL and make sure we
 * do the faces in WebGL order
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @return {FaceInfo[]} cubemap face infos. Arguably the `face` property of each element is redundant but
 *    it's needed internally to sort the array of `ndx` properties by `face`.
 * @private
 */
function getCubeFacesWithNdx(gl, options) {
  const faces = getCubeFaceOrder(gl, options);
  // work around bug in NVidia drivers. We have to upload the first face first else the driver crashes :(
  const facesWithNdx = faces.map(function (face, ndx) {
    return {
      face: face,
      ndx: ndx
    };
  });
  facesWithNdx.sort(function (a, b) {
    return a.face - b.face;
  });
  return facesWithNdx;
}

/**
 * Set a texture from the contents of an element. Will also set
 * texture filtering or generate mips based on the dimensions of the element
 * unless `options.auto === false`. If `target === gl.TEXTURE_CUBE_MAP` will
 * attempt to slice image into 1x6, 2x3, 3x2, or 6x1 images, one for each face.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {HTMLElement} element a canvas, img, or video element.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @kind function
 */
function setTextureFromElement(gl, tex, element, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  const level = options.level || 0;
  let width = element.width;
  let height = element.height;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP) {
    // guess the parts
    const imgWidth = element.width;
    const imgHeight = element.height;
    let size;
    let slices;
    if (imgWidth / 6 === imgHeight) {
      // It's 6x1
      size = imgHeight;
      slices = [0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0];
    } else if (imgHeight / 6 === imgWidth) {
      // It's 1x6
      size = imgWidth;
      slices = [0, 0, 0, 1, 0, 2, 0, 3, 0, 4, 0, 5];
    } else if (imgWidth / 3 === imgHeight / 2) {
      // It's 3x2
      size = imgWidth / 3;
      slices = [0, 0, 1, 0, 2, 0, 0, 1, 1, 1, 2, 1];
    } else if (imgWidth / 2 === imgHeight / 3) {
      // It's 2x3
      size = imgWidth / 2;
      slices = [0, 0, 1, 0, 0, 1, 1, 1, 0, 2, 1, 2];
    } else {
      throw "can't figure out cube map from element: " + (element.src ? element.src : element.nodeName);
    }
    const ctx = getShared2DContext();
    if (ctx) {
      ctx.canvas.width = size;
      ctx.canvas.height = size;
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        ctx.drawImage(element, xOffset, yOffset, size, size, 0, 0, size, size);
        gl.texImage2D(f.face, level, internalFormat, format, type, ctx.canvas);
      });
      // Free up the canvas memory
      ctx.canvas.width = 1;
      ctx.canvas.height = 1;
    } else if (typeof createImageBitmap !== 'undefined') {
      // NOTE: It seems like we should prefer ImageBitmap because unlike canvas it's
      // note lossy? (alpha is not premultiplied? although I'm not sure what
      width = size;
      height = size;
      getCubeFacesWithNdx(gl, options).forEach(function (f) {
        const xOffset = slices[f.ndx * 2 + 0] * size;
        const yOffset = slices[f.ndx * 2 + 1] * size;
        // We can't easily use a default texture color here as it would have to match
        // the type across all faces where as with a 2D one there's only one face
        // so we're replacing everything all at once. It also has to be the correct size.
        // On the other hand we need all faces to be the same size so as one face loads
        // the rest match else the texture will be un-renderable.
        gl.texImage2D(f.face, level, internalFormat, size, size, 0, format, type, null);
        createImageBitmap(element, xOffset, yOffset, size, size, {
          premultiplyAlpha: 'none',
          colorSpaceConversion: 'none'
        }).then(function (imageBitmap) {
          setPackState(gl, options);
          gl.bindTexture(target, tex);
          gl.texImage2D(f.face, level, internalFormat, format, type, imageBitmap);
          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
          }
        });
      });
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    const smallest = Math.min(element.width, element.height);
    const largest = Math.max(element.width, element.height);
    const depth = largest / smallest;
    if (depth % 1 !== 0) {
      throw "can not compute 3D dimensions of element";
    }
    const xMult = element.width === largest ? 1 : 0;
    const yMult = element.height === largest ? 1 : 0;
    gl.pixelStorei(UNPACK_ALIGNMENT, 1);
    gl.pixelStorei(UNPACK_ROW_LENGTH, element.width);
    gl.pixelStorei(UNPACK_IMAGE_HEIGHT, 0);
    gl.pixelStorei(UNPACK_SKIP_IMAGES, 0);
    gl.texImage3D(target, level, internalFormat, smallest, smallest, smallest, 0, format, type, null);
    for (let d = 0; d < depth; ++d) {
      const srcX = d * smallest * xMult;
      const srcY = d * smallest * yMult;
      gl.pixelStorei(UNPACK_SKIP_PIXELS, srcX);
      gl.pixelStorei(UNPACK_SKIP_ROWS, srcY);
      gl.texSubImage3D(target, level, 0, 0, d, smallest, smallest, 1, format, type, element);
    }
    setSkipStateToDefault(gl);
  } else {
    gl.texImage2D(target, level, internalFormat, format, type, element);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
}
function noop() {}

/**
 * Checks whether the url's origin is the same so that we can set the `crossOrigin`
 * @param {string} url url to image
 * @returns {boolean} true if the window's origin is the same as image's url
 * @private
 */
function urlIsSameOrigin(url) {
  if (typeof document !== 'undefined') {
    // for IE really
    const a = document.createElement('a');
    a.href = url;
    return a.hostname === location.hostname && a.port === location.port && a.protocol === location.protocol;
  } else {
    const localOrigin = new URL(location.href).origin;
    const urlOrigin = new URL(url, location.href).origin;
    return urlOrigin === localOrigin;
  }
}
function setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin) {
  return crossOrigin === undefined && !urlIsSameOrigin(url) ? 'anonymous' : crossOrigin;
}

/**
 * Loads an image
 * @param {string} url url to image
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @return {HTMLImageElement} the image being loaded.
 * @private
 */
function loadImage(url, crossOrigin, callback) {
  callback = callback || noop;
  let img;
  crossOrigin = crossOrigin !== undefined ? crossOrigin : defaults$1.crossOrigin;
  crossOrigin = setToAnonymousIfUndefinedAndURLIsNotSameOrigin(url, crossOrigin);
  if (typeof Image !== 'undefined') {
    img = new Image();
    if (crossOrigin !== undefined) {
      img.crossOrigin = crossOrigin;
    }
    const clearEventHandlers = function clearEventHandlers() {
      img.removeEventListener('error', onError); // eslint-disable-line
      img.removeEventListener('load', onLoad); // eslint-disable-line
      img = null;
    };
    const onError = function onError() {
      const msg = "couldn't load image: " + url;
      error(msg);
      callback(msg, img);
      clearEventHandlers();
    };
    const onLoad = function onLoad() {
      callback(null, img);
      clearEventHandlers();
    };
    img.addEventListener('error', onError);
    img.addEventListener('load', onLoad);
    img.src = url;
    return img;
  } else if (typeof ImageBitmap !== 'undefined') {
    let err;
    let bm;
    const cb = function cb() {
      callback(err, bm);
    };
    const options = {};
    if (crossOrigin) {
      options.mode = 'cors'; // TODO: not sure how to translate image.crossOrigin
    }
    fetch(url, options).then(function (response) {
      if (!response.ok) {
        throw response;
      }
      return response.blob();
    }).then(function (blob) {
      return createImageBitmap(blob, {
        premultiplyAlpha: 'none',
        colorSpaceConversion: 'none'
      });
    }).then(function (bitmap) {
      // not sure if this works. We don't want
      // to catch the user's error. So, call
      // the callback in a timeout so we're
      // not in this scope inside the promise.
      bm = bitmap;
      setTimeout(cb);
    }).catch(function (e) {
      err = e;
      setTimeout(cb);
    });
    img = null;
  }
  return img;
}

/**
 * check if object is a TexImageSource
 *
 * @param {Object} obj Object to test
 * @return {boolean} true if object is a TexImageSource
 * @private
 */
function isTexImageSource(obj) {
  return typeof ImageBitmap !== 'undefined' && obj instanceof ImageBitmap || typeof ImageData !== 'undefined' && obj instanceof ImageData || typeof HTMLElement !== 'undefined' && obj instanceof HTMLElement;
}

/**
 * if obj is an TexImageSource then just
 * uses it otherwise if obj is a string
 * then load it first.
 *
 * @param {string|TexImageSource} obj
 * @param {string} crossOrigin
 * @param {function(err, img)} [callback] a callback that's passed an error and the image. The error will be non-null
 *     if there was an error
 * @private
 */
function loadAndUseImage(obj, crossOrigin, callback) {
  if (isTexImageSource(obj)) {
    setTimeout(function () {
      callback(null, obj);
    });
    return obj;
  }
  return loadImage(obj, crossOrigin, callback);
}

/**
 * Sets a texture to a 1x1 pixel color. If `options.color === false` is nothing happens. If it's not set
 * the default texture color is used which can be set by calling `setDefaultTextureColor`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 * @private
 */
function setTextureTo1PixelColor(gl, tex, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  if (options.color === false) {
    return;
  }
  // Assume it's a URL
  // Put 1x1 pixels in texture. That makes it renderable immediately regardless of filtering.
  const color = make1Pixel(options.color);
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, 0, RGBA, 1, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
  } else {
    gl.texImage2D(target, 0, RGBA, 1, 1, 0, RGBA, UNSIGNED_BYTE$2, color);
  }
}

/**
 * The src image(s) used to create a texture.
 *
 * When you call {@link module:twgl.createTexture} or {@link module:twgl.createTextures}
 * you can pass in urls for images to load into the textures. If it's a single url
 * then this will be a single HTMLImageElement. If it's an array of urls used for a cubemap
 * this will be a corresponding array of images for the cubemap.
 *
 * @typedef {HTMLImageElement|HTMLImageElement[]} TextureSrc
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback TextureReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} texture the texture.
 * @param {module:twgl.TextureSrc} source image(s) used to as the src for the texture
 * @memberOf module:twgl
 */

/**
 * A callback for when all images have finished downloading and been uploaded into their respective textures
 * @callback TexturesReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {Object.<string, WebGLTexture>} textures the created textures by name. Same as returned by {@link module:twgl.createTextures}.
 * @param {Object.<string, module:twgl.TextureSrc>} sources the image(s) used for the texture by name.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback CubemapReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each face.
 * @memberOf module:twgl
 */

/**
 * A callback for when an image finished downloading and been uploaded into a texture
 * @callback ThreeDReadyCallback
 * @param {*} err If truthy there was an error.
 * @param {WebGLTexture} tex the texture.
 * @param {HTMLImageElement[]} imgs the images for each slice.
 * @memberOf module:twgl
 */

/**
 * Loads a texture from an image from a Url as specified in `options.src`
 * If `options.color !== false` will set the texture to a 1x1 pixel color so that the texture is
 * immediately useable. It will be updated with the contents of the image once the image has finished
 * downloading. Filtering options will be set as appropriate for image unless `options.auto === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A function to be called when the image has finished loading. err will
 *    be non null if there was an error.
 * @return {HTMLImageElement} the image being downloaded.
 * @memberOf module:twgl/textures
 */
function loadTextureFromUrl(gl, tex, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  const img = loadAndUseImage(options.src, options.crossOrigin, function (err, img) {
    if (err) {
      callback(err, tex, img);
    } else {
      setTextureFromElement(gl, tex, img, options);
      callback(null, tex, img);
    }
  });
  return img;
}

/**
 * Loads a cubemap from 6 urls or TexImageSources as specified in `options.src`. Will set the cubemap to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.CubemapReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 * @private
 */
function loadCubemapFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  if (urls.length !== 6) {
    throw "there must be 6 urls for a cubemap";
  }
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$2;
  const target = options.target || TEXTURE_2D;
  if (target !== TEXTURE_CUBE_MAP) {
    throw "target must be TEXTURE_CUBE_MAP";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = 6;
  const errors = [];
  const faces = getCubeFaceOrder(gl, options);
  let imgs; // eslint-disable-line

  function uploadImg(faceTarget) {
    return function (err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        if (img.width !== img.height) {
          errors.push("cubemap face img is not a square: " + img.src);
        } else {
          setPackState(gl, options);
          gl.bindTexture(target, tex);

          // So assuming this is the first image we now have one face that's img sized
          // and 5 faces that are 1x1 pixel so size the other faces
          if (numToLoad === 5) {
            // use the default order
            getCubeFaceOrder().forEach(function (otherTarget) {
              // Should we re-use the same face or a color?
              gl.texImage2D(otherTarget, level, internalFormat, format, type, img);
            });
          } else {
            gl.texImage2D(faceTarget, level, internalFormat, format, type, img);
          }
          if (shouldAutomaticallySetTextureFilteringForSize(options)) {
            gl.generateMipmap(target);
          }
        }
      }
      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }
  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(faces[ndx]));
  });
}

/**
 * Loads a 2d array or 3d texture from urls OR TexImageSources as specified in `options.src`.
 * Will set the texture to a 1x1 pixel color
 * so that it is usable immediately unless `option.color === false`.
 *
 * If the width and height is not specified the width and height of the first
 * image loaded will be used. Note that since images are loaded async
 * which image downloads first is unknown.
 *
 * If an image is not the same size as the width and height it will be scaled
 * to that width and height.
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.ThreeDReadyCallback} [callback] A function to be called when all the images have finished loading. err will
 *    be non null if there was an error.
 * @memberOf module:twgl/textures
 * @private
 */
function loadSlicesFromUrls(gl, tex, options, callback) {
  callback = callback || noop;
  const urls = options.src;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || UNSIGNED_BYTE$2;
  const target = options.target || TEXTURE_2D_ARRAY;
  if (target !== TEXTURE_3D && target !== TEXTURE_2D_ARRAY) {
    throw "target must be TEXTURE_3D or TEXTURE_2D_ARRAY";
  }
  setTextureTo1PixelColor(gl, tex, options);
  // Because it's async we need to copy the options.
  options = Object.assign({}, options);
  let numToLoad = urls.length;
  const errors = [];
  let imgs; // eslint-disable-line
  const level = options.level || 0;
  let width = options.width;
  let height = options.height;
  const depth = urls.length;
  let firstImage = true;
  function uploadImg(slice) {
    return function (err, img) {
      --numToLoad;
      if (err) {
        errors.push(err);
      } else {
        setPackState(gl, options);
        gl.bindTexture(target, tex);
        if (firstImage) {
          firstImage = false;
          width = options.width || img.width;
          height = options.height || img.height;
          gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);

          // put it in every slice otherwise some slices will be 0,0,0,0
          for (let s = 0; s < depth; ++s) {
            gl.texSubImage3D(target, level, 0, 0, s, width, height, 1, format, type, img);
          }
        } else {
          let src = img;
          let ctx;
          if (img.width !== width || img.height !== height) {
            // Size the image to fix
            ctx = getShared2DContext();
            src = ctx.canvas;
            ctx.canvas.width = width;
            ctx.canvas.height = height;
            ctx.drawImage(img, 0, 0, width, height);
          }
          gl.texSubImage3D(target, level, 0, 0, slice, width, height, 1, format, type, src);

          // free the canvas memory
          if (ctx && src === ctx.canvas) {
            ctx.canvas.width = 0;
            ctx.canvas.height = 0;
          }
        }
        if (shouldAutomaticallySetTextureFilteringForSize(options)) {
          gl.generateMipmap(target);
        }
      }
      if (numToLoad === 0) {
        callback(errors.length ? errors : undefined, tex, imgs);
      }
    };
  }
  imgs = urls.map(function (url, ndx) {
    return loadAndUseImage(url, options.crossOrigin, uploadImg(ndx));
  });
}

/**
 * Sets a texture from an array or typed array. If the width or height is not provided will attempt to
 * guess the size. See {@link module:twgl.TextureOptions}.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {(number[]|ArrayBufferView)} src An array or typed arry with texture data.
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 *   This is often the same options you passed in when you created the texture.
 * @memberOf module:twgl/textures
 */
function setTextureFromArray(gl, tex, src, options) {
  options = options || defaults$1.textureOptions;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  let width = options.width;
  let height = options.height;
  let depth = options.depth;
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  if (!isArrayBuffer$1(src)) {
    const Type = getTypedArrayTypeForGLType(type);
    src = new Type(src);
  } else if (src instanceof Uint8ClampedArray) {
    src = new Uint8Array(src.buffer);
  }
  const bytesPerElement = getBytesPerElementForInternalFormat(internalFormat, type);
  const numElements = src.byteLength / bytesPerElement; // TODO: check UNPACK_ALIGNMENT?
  if (numElements % 1) {
    throw "length wrong size for format: " + glEnumToString(gl, format);
  }
  let dimensions;
  if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    if (!width && !height && !depth) {
      const size = Math.cbrt(numElements);
      if (size % 1 !== 0) {
        throw "can't guess cube size of array of numElements: " + numElements;
      }
      width = size;
      height = size;
      depth = size;
    } else if (width && (!height || !depth)) {
      dimensions = guessDimensions(gl, target, height, depth, numElements / width);
      height = dimensions.width;
      depth = dimensions.height;
    } else if (height && (!width || !depth)) {
      dimensions = guessDimensions(gl, target, width, depth, numElements / height);
      width = dimensions.width;
      depth = dimensions.height;
    } else {
      dimensions = guessDimensions(gl, target, width, height, numElements / depth);
      width = dimensions.width;
      height = dimensions.height;
    }
  } else {
    dimensions = guessDimensions(gl, target, width, height, numElements);
    width = dimensions.width;
    height = dimensions.height;
  }
  setSkipStateToDefault(gl);
  gl.pixelStorei(UNPACK_ALIGNMENT, options.unpackAlignment || 1);
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP) {
    const elementsPerElement = bytesPerElement / src.BYTES_PER_ELEMENT;
    const faceSize = numElements / 6 * elementsPerElement;
    getCubeFacesWithNdx(gl, options).forEach(f => {
      const offset = faceSize * f.ndx;
      const data = src.subarray(offset, offset + faceSize);
      gl.texImage2D(f.face, level, internalFormat, width, height, 0, format, type, data);
    });
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, src);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, src);
  }
  return {
    width: width,
    height: height,
    depth: depth,
    type: type
  };
}

/**
 * Sets a texture with no contents of a certain size. In other words calls `gl.texImage2D` with `null`.
 * You must set `options.width` and `options.height`.
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the WebGLTexture to set parameters for
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @memberOf module:twgl/textures
 */
function setEmptyTexture(gl, tex, options) {
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  const type = options.type || formatType.type;
  setPackState(gl, options);
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, options.width, options.height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, options.width, options.height, options.depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, options.width, options.height, 0, format, type, null);
  }
}

/**
 * Creates a texture based on the options passed in.
 *
 * Note: may reset UNPACK_ALIGNMENT, UNPACK_ROW_LENGTH, UNPACK_IMAGE_HEIGHT, UNPACK_SKIP_IMAGES
 * UNPACK_SKIP_PIXELS, and UNPACK_SKIP_ROWS
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.TextureOptions} [options] A TextureOptions object with whatever parameters you want set.
 * @param {module:twgl.TextureReadyCallback} [callback] A callback called when an image has been downloaded and uploaded to the texture.
 * @return {WebGLTexture} the created texture.
 * @memberOf module:twgl/textures
 */
function createTexture(gl, options, callback) {
  callback = callback || noop;
  options = options || defaults$1.textureOptions;
  const tex = gl.createTexture();
  const target = options.target || TEXTURE_2D;
  let width = options.width || 1;
  let height = options.height || 1;
  const internalFormat = options.internalFormat || RGBA;
  gl.bindTexture(target, tex);
  if (target === TEXTURE_CUBE_MAP) {
    // this should have been the default for cubemaps :(
    gl.texParameteri(target, TEXTURE_WRAP_S, CLAMP_TO_EDGE);
    gl.texParameteri(target, TEXTURE_WRAP_T, CLAMP_TO_EDGE);
  }
  let src = options.src;
  if (src) {
    if (typeof src === "function") {
      src = src(gl, options);
    }
    if (typeof src === "string") {
      loadTextureFromUrl(gl, tex, options, callback);
    } else if (isArrayBuffer$1(src) || Array.isArray(src) && (typeof src[0] === 'number' || Array.isArray(src[0]) || isArrayBuffer$1(src[0]))) {
      const dimensions = setTextureFromArray(gl, tex, src, options);
      width = dimensions.width;
      height = dimensions.height;
    } else if (Array.isArray(src) && (typeof src[0] === 'string' || isTexImageSource(src[0]))) {
      if (target === TEXTURE_CUBE_MAP) {
        loadCubemapFromUrls(gl, tex, options, callback);
      } else {
        loadSlicesFromUrls(gl, tex, options, callback);
      }
    } else {
      // if (isTexImageSource(src))
      setTextureFromElement(gl, tex, src, options);
      width = src.width;
      height = src.height;
    }
  } else {
    setEmptyTexture(gl, tex, options);
  }
  if (shouldAutomaticallySetTextureFilteringForSize(options)) {
    setTextureFilteringForSize(gl, tex, options, width, height, internalFormat);
  }
  setTextureParameters(gl, tex, options);
  return tex;
}

/**
 * Resizes a texture based on the options passed in.
 *
 * Note: This is not a generic resize anything function.
 * It's mostly used by {@link module:twgl.resizeFramebufferInfo}
 * It will use `options.src` if it exists to try to determine a `type`
 * otherwise it will assume `gl.UNSIGNED_BYTE`. No data is provided
 * for the texture. Texture parameters will be set accordingly
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {WebGLTexture} tex the texture to resize
 * @param {module:twgl.TextureOptions} options A TextureOptions object with whatever parameters you want set.
 * @param {number} [width] the new width. If not passed in will use `options.width`
 * @param {number} [height] the new height. If not passed in will use `options.height`
 * @param {number} [depth] the new depth. If not passed in will use `options.depth`
 * @memberOf module:twgl/textures
 */
function resizeTexture(gl, tex, options, width, height, depth) {
  width = width || options.width;
  height = height || options.height;
  depth = depth || options.depth;
  const target = options.target || TEXTURE_2D;
  gl.bindTexture(target, tex);
  const level = options.level || 0;
  const internalFormat = options.internalFormat || options.format || RGBA;
  const formatType = getFormatAndTypeForInternalFormat(internalFormat);
  const format = options.format || formatType.format;
  let type;
  const src = options.src;
  if (!src) {
    type = options.type || formatType.type;
  } else if (isArrayBuffer$1(src) || Array.isArray(src) && typeof src[0] === 'number') {
    type = options.type || getTextureTypeForArrayType(gl, src, formatType.type);
  } else {
    type = options.type || formatType.type;
  }
  if (target === TEXTURE_CUBE_MAP) {
    for (let ii = 0; ii < 6; ++ii) {
      gl.texImage2D(TEXTURE_CUBE_MAP_POSITIVE_X + ii, level, internalFormat, width, height, 0, format, type, null);
    }
  } else if (target === TEXTURE_3D || target === TEXTURE_2D_ARRAY) {
    gl.texImage3D(target, level, internalFormat, width, height, depth, 0, format, type, null);
  } else {
    gl.texImage2D(target, level, internalFormat, width, height, 0, format, type, null);
  }
}

/**
 * Check if a src is an async request.
 * if src is a string we're going to download an image
 * if src is an array of strings we're going to download cubemap images
 * @param {*} src The src from a TextureOptions
 * @returns {bool} true if src is async.
 * @private
 */
function isAsyncSrc(src) {
  return typeof src === 'string' || Array.isArray(src) && typeof src[0] === 'string';
}

/**
 * Creates a bunch of textures based on the passed in options.
 *
 * Example:
 *
 *     const textures = twgl.createTextures(gl, {
 *       // a power of 2 image
 *       hftIcon: { src: "images/hft-icon-16.png", mag: gl.NEAREST },
 *       // a non-power of 2 image
 *       clover: { src: "images/clover.jpg" },
 *       // From a canvas
 *       fromCanvas: { src: ctx.canvas },
 *       // A cubemap from 6 images
 *       yokohama: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: [
 *           'images/yokohama/posx.jpg',
 *           'images/yokohama/negx.jpg',
 *           'images/yokohama/posy.jpg',
 *           'images/yokohama/negy.jpg',
 *           'images/yokohama/posz.jpg',
 *           'images/yokohama/negz.jpg',
 *         ],
 *       },
 *       // A cubemap from 1 image (can be 1x6, 2x3, 3x2, 6x1)
 *       goldengate: {
 *         target: gl.TEXTURE_CUBE_MAP,
 *         src: 'images/goldengate.jpg',
 *       },
 *       // A 2x2 pixel texture from a JavaScript array
 *       checker: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         src: [
 *           255,255,255,255,
 *           192,192,192,255,
 *           192,192,192,255,
 *           255,255,255,255,
 *         ],
 *       },
 *       // a 1x2 pixel texture from a typed array.
 *       stripe: {
 *         mag: gl.NEAREST,
 *         min: gl.LINEAR,
 *         format: gl.LUMINANCE,
 *         src: new Uint8Array([
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *           255,
 *           128,
 *         ]),
 *         width: 1,
 *       },
 *     });
 *
 * Now
 *
 * *   `textures.hftIcon` will be a 2d texture
 * *   `textures.clover` will be a 2d texture
 * *   `textures.fromCanvas` will be a 2d texture
 * *   `textures.yohohama` will be a cubemap texture
 * *   `textures.goldengate` will be a cubemap texture
 * *   `textures.checker` will be a 2d texture
 * *   `textures.stripe` will be a 2d texture
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {Object.<string,module:twgl.TextureOptions>} options A object of TextureOptions one per texture.
 * @param {module:twgl.TexturesReadyCallback} [callback] A callback called when all textures have been downloaded.
 * @return {Object.<string,WebGLTexture>} the created textures by name
 * @memberOf module:twgl/textures
 */
function createTextures(gl, textureOptions, callback) {
  callback = callback || noop;
  let numDownloading = 0;
  const errors = [];
  const textures = {};
  const images = {};
  function callCallbackIfReady() {
    if (numDownloading === 0) {
      setTimeout(function () {
        callback(errors.length ? errors : undefined, textures, images);
      }, 0);
    }
  }
  Object.keys(textureOptions).forEach(function (name) {
    const options = textureOptions[name];
    let onLoadFn;
    if (isAsyncSrc(options.src)) {
      onLoadFn = function onLoadFn(err, tex, img) {
        images[name] = img;
        --numDownloading;
        if (err) {
          errors.push(err);
        }
        callCallbackIfReady();
      };
      ++numDownloading;
    }
    textures[name] = createTexture(gl, options, onLoadFn);
  });

  // queue the callback if there are no images to download.
  // We do this because if your code is structured to wait for
  // images to download but then you comment out all the async
  // images your code would break.
  callCallbackIfReady();
  return textures;
}
var textures = /*#__PURE__*/Object.freeze({
  __proto__: null,
  setTextureDefaults_: setDefaults$1,
  createSampler: createSampler,
  createSamplers: createSamplers,
  setSamplerParameters: setSamplerParameters,
  createTexture: createTexture,
  setEmptyTexture: setEmptyTexture,
  setTextureFromArray: setTextureFromArray,
  loadTextureFromUrl: loadTextureFromUrl,
  setTextureFromElement: setTextureFromElement,
  setTextureFilteringForSize: setTextureFilteringForSize,
  setTextureParameters: setTextureParameters,
  setDefaultTextureColor: setDefaultTextureColor,
  createTextures: createTextures,
  resizeTexture: resizeTexture,
  canGenerateMipmap: canGenerateMipmap,
  canFilter: canFilter,
  getNumComponentsForFormat: getNumComponentsForFormat,
  getBytesPerElementForInternalFormat: getBytesPerElementForInternalFormat,
  getFormatAndTypeForInternalFormat: getFormatAndTypeForInternalFormat
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * Low level shader program related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.programs` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/programs
 */

const error$1 = error;
const warn$1 = warn;
function getElementById(id) {
  return typeof document !== 'undefined' && document.getElementById ? document.getElementById(id) : null;
}
const TEXTURE0 = 0x84c0;
const DYNAMIC_DRAW = 0x88e8;
const ARRAY_BUFFER$1 = 0x8892;
const ELEMENT_ARRAY_BUFFER$1 = 0x8893;
const UNIFORM_BUFFER = 0x8a11;
const TRANSFORM_FEEDBACK_BUFFER = 0x8c8e;
const TRANSFORM_FEEDBACK = 0x8e22;
const COMPILE_STATUS = 0x8b81;
const LINK_STATUS = 0x8b82;
const FRAGMENT_SHADER = 0x8b30;
const VERTEX_SHADER = 0x8b31;
const SEPARATE_ATTRIBS = 0x8c8d;
const ACTIVE_UNIFORMS = 0x8b86;
const ACTIVE_ATTRIBUTES = 0x8b89;
const TRANSFORM_FEEDBACK_VARYINGS = 0x8c83;
const ACTIVE_UNIFORM_BLOCKS = 0x8a36;
const UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 0x8a44;
const UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 0x8a46;
const UNIFORM_BLOCK_DATA_SIZE = 0x8a40;
const UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 0x8a43;
const FLOAT$3 = 0x1406;
const FLOAT_VEC2 = 0x8B50;
const FLOAT_VEC3 = 0x8B51;
const FLOAT_VEC4 = 0x8B52;
const INT$3 = 0x1404;
const INT_VEC2 = 0x8B53;
const INT_VEC3 = 0x8B54;
const INT_VEC4 = 0x8B55;
const BOOL = 0x8B56;
const BOOL_VEC2 = 0x8B57;
const BOOL_VEC3 = 0x8B58;
const BOOL_VEC4 = 0x8B59;
const FLOAT_MAT2 = 0x8B5A;
const FLOAT_MAT3 = 0x8B5B;
const FLOAT_MAT4 = 0x8B5C;
const SAMPLER_2D = 0x8B5E;
const SAMPLER_CUBE = 0x8B60;
const SAMPLER_3D = 0x8B5F;
const SAMPLER_2D_SHADOW = 0x8B62;
const FLOAT_MAT2x3 = 0x8B65;
const FLOAT_MAT2x4 = 0x8B66;
const FLOAT_MAT3x2 = 0x8B67;
const FLOAT_MAT3x4 = 0x8B68;
const FLOAT_MAT4x2 = 0x8B69;
const FLOAT_MAT4x3 = 0x8B6A;
const SAMPLER_2D_ARRAY = 0x8DC1;
const SAMPLER_2D_ARRAY_SHADOW = 0x8DC4;
const SAMPLER_CUBE_SHADOW = 0x8DC5;
const UNSIGNED_INT$3 = 0x1405;
const UNSIGNED_INT_VEC2 = 0x8DC6;
const UNSIGNED_INT_VEC3 = 0x8DC7;
const UNSIGNED_INT_VEC4 = 0x8DC8;
const INT_SAMPLER_2D = 0x8DCA;
const INT_SAMPLER_3D = 0x8DCB;
const INT_SAMPLER_CUBE = 0x8DCC;
const INT_SAMPLER_2D_ARRAY = 0x8DCF;
const UNSIGNED_INT_SAMPLER_2D = 0x8DD2;
const UNSIGNED_INT_SAMPLER_3D = 0x8DD3;
const UNSIGNED_INT_SAMPLER_CUBE = 0x8DD4;
const UNSIGNED_INT_SAMPLER_2D_ARRAY = 0x8DD7;
const TEXTURE_2D$1 = 0x0DE1;
const TEXTURE_CUBE_MAP$1 = 0x8513;
const TEXTURE_3D$1 = 0x806F;
const TEXTURE_2D_ARRAY$1 = 0x8C1A;
const typeMap = {};

/**
 * Returns the corresponding bind point for a given sampler type
 * @private
 */
function getBindPointForSamplerType(gl, type) {
  return typeMap[type].bindPoint;
}

// This kind of sucks! If you could compose functions as in `var fn = gl[name];`
// this code could be a lot smaller but that is sadly really slow (T_T)

function floatSetter(gl, location) {
  return function (v) {
    gl.uniform1f(location, v);
  };
}
function floatArraySetter(gl, location) {
  return function (v) {
    gl.uniform1fv(location, v);
  };
}
function floatVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2fv(location, v);
  };
}
function floatVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3fv(location, v);
  };
}
function floatVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4fv(location, v);
  };
}
function intSetter(gl, location) {
  return function (v) {
    gl.uniform1i(location, v);
  };
}
function intArraySetter(gl, location) {
  return function (v) {
    gl.uniform1iv(location, v);
  };
}
function intVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2iv(location, v);
  };
}
function intVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3iv(location, v);
  };
}
function intVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4iv(location, v);
  };
}
function uintSetter(gl, location) {
  return function (v) {
    gl.uniform1ui(location, v);
  };
}
function uintArraySetter(gl, location) {
  return function (v) {
    gl.uniform1uiv(location, v);
  };
}
function uintVec2Setter(gl, location) {
  return function (v) {
    gl.uniform2uiv(location, v);
  };
}
function uintVec3Setter(gl, location) {
  return function (v) {
    gl.uniform3uiv(location, v);
  };
}
function uintVec4Setter(gl, location) {
  return function (v) {
    gl.uniform4uiv(location, v);
  };
}
function floatMat2Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2fv(location, false, v);
  };
}
function floatMat3Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3fv(location, false, v);
  };
}
function floatMat4Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4fv(location, false, v);
  };
}
function floatMat23Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x3fv(location, false, v);
  };
}
function floatMat32Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x2fv(location, false, v);
  };
}
function floatMat24Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix2x4fv(location, false, v);
  };
}
function floatMat42Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x2fv(location, false, v);
  };
}
function floatMat34Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix3x4fv(location, false, v);
  };
}
function floatMat43Setter(gl, location) {
  return function (v) {
    gl.uniformMatrix4x3fv(location, false, v);
  };
}
function samplerSetter(gl, type, unit, location) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  return isWebGL2(gl) ? function (textureOrPair) {
    let texture;
    let sampler;
    if (isTexture(gl, textureOrPair)) {
      texture = textureOrPair;
      sampler = null;
    } else {
      texture = textureOrPair.texture;
      sampler = textureOrPair.sampler;
    }
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
    gl.bindSampler(unit, sampler);
  } : function (texture) {
    gl.uniform1i(location, unit);
    gl.activeTexture(TEXTURE0 + unit);
    gl.bindTexture(bindPoint, texture);
  };
}
function samplerArraySetter(gl, type, unit, location, size) {
  const bindPoint = getBindPointForSamplerType(gl, type);
  const units = new Int32Array(size);
  for (let ii = 0; ii < size; ++ii) {
    units[ii] = unit + ii;
  }
  return isWebGL2(gl) ? function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (textureOrPair, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      let texture;
      let sampler;
      if (isTexture(gl, textureOrPair)) {
        texture = textureOrPair;
        sampler = null;
      } else {
        texture = textureOrPair.texture;
        sampler = textureOrPair.sampler;
      }
      gl.bindSampler(unit, sampler);
      gl.bindTexture(bindPoint, texture);
    });
  } : function (textures) {
    gl.uniform1iv(location, units);
    textures.forEach(function (texture, index) {
      gl.activeTexture(TEXTURE0 + units[index]);
      gl.bindTexture(bindPoint, texture);
    });
  };
}
typeMap[FLOAT$3] = {
  Type: Float32Array,
  size: 4,
  setter: floatSetter,
  arraySetter: floatArraySetter
};
typeMap[FLOAT_VEC2] = {
  Type: Float32Array,
  size: 8,
  setter: floatVec2Setter,
  cols: 2
};
typeMap[FLOAT_VEC3] = {
  Type: Float32Array,
  size: 12,
  setter: floatVec3Setter,
  cols: 3
};
typeMap[FLOAT_VEC4] = {
  Type: Float32Array,
  size: 16,
  setter: floatVec4Setter,
  cols: 4
};
typeMap[INT$3] = {
  Type: Int32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[INT_VEC2] = {
  Type: Int32Array,
  size: 8,
  setter: intVec2Setter,
  cols: 2
};
typeMap[INT_VEC3] = {
  Type: Int32Array,
  size: 12,
  setter: intVec3Setter,
  cols: 3
};
typeMap[INT_VEC4] = {
  Type: Int32Array,
  size: 16,
  setter: intVec4Setter,
  cols: 4
};
typeMap[UNSIGNED_INT$3] = {
  Type: Uint32Array,
  size: 4,
  setter: uintSetter,
  arraySetter: uintArraySetter
};
typeMap[UNSIGNED_INT_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: uintVec2Setter,
  cols: 2
};
typeMap[UNSIGNED_INT_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: uintVec3Setter,
  cols: 3
};
typeMap[UNSIGNED_INT_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: uintVec4Setter,
  cols: 4
};
typeMap[BOOL] = {
  Type: Uint32Array,
  size: 4,
  setter: intSetter,
  arraySetter: intArraySetter
};
typeMap[BOOL_VEC2] = {
  Type: Uint32Array,
  size: 8,
  setter: intVec2Setter,
  cols: 2
};
typeMap[BOOL_VEC3] = {
  Type: Uint32Array,
  size: 12,
  setter: intVec3Setter,
  cols: 3
};
typeMap[BOOL_VEC4] = {
  Type: Uint32Array,
  size: 16,
  setter: intVec4Setter,
  cols: 4
};
typeMap[FLOAT_MAT2] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat2Setter,
  rows: 2,
  cols: 2
};
typeMap[FLOAT_MAT3] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat3Setter,
  rows: 3,
  cols: 3
};
typeMap[FLOAT_MAT4] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat4Setter,
  rows: 4,
  cols: 4
};
typeMap[FLOAT_MAT2x3] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat23Setter,
  rows: 2,
  cols: 3
};
typeMap[FLOAT_MAT2x4] = {
  Type: Float32Array,
  size: 32,
  setter: floatMat24Setter,
  rows: 2,
  cols: 4
};
typeMap[FLOAT_MAT3x2] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat32Setter,
  rows: 3,
  cols: 2
};
typeMap[FLOAT_MAT3x4] = {
  Type: Float32Array,
  size: 48,
  setter: floatMat34Setter,
  rows: 3,
  cols: 4
};
typeMap[FLOAT_MAT4x2] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat42Setter,
  rows: 4,
  cols: 2
};
typeMap[FLOAT_MAT4x3] = {
  Type: Float32Array,
  size: 64,
  setter: floatMat43Setter,
  rows: 4,
  cols: 3
};
typeMap[SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D$1
};
typeMap[SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP$1
};
typeMap[SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D$1
};
typeMap[SAMPLER_2D_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D$1
};
typeMap[SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY$1
};
typeMap[SAMPLER_2D_ARRAY_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY$1
};
typeMap[SAMPLER_CUBE_SHADOW] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP$1
};
typeMap[INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D$1
};
typeMap[INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D$1
};
typeMap[INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP$1
};
typeMap[INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY$1
};
typeMap[UNSIGNED_INT_SAMPLER_2D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D$1
};
typeMap[UNSIGNED_INT_SAMPLER_3D] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_3D$1
};
typeMap[UNSIGNED_INT_SAMPLER_CUBE] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_CUBE_MAP$1
};
typeMap[UNSIGNED_INT_SAMPLER_2D_ARRAY] = {
  Type: null,
  size: 0,
  setter: samplerSetter,
  arraySetter: samplerArraySetter,
  bindPoint: TEXTURE_2D_ARRAY$1
};
function floatAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      switch (b.value.length) {
        case 4:
          gl.vertexAttrib4fv(index, b.value);
          break;
        case 3:
          gl.vertexAttrib3fv(index, b.value);
          break;
        case 2:
          gl.vertexAttrib2fv(index, b.value);
          break;
        case 1:
          gl.vertexAttrib1fv(index, b.value);
          break;
        default:
          throw new Error('the length of a float constant value must be between 1 and 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribPointer(index, b.numComponents || b.size, b.type || FLOAT$3, b.normalize || false, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}
function intAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4iv(index, b.value);
      } else {
        throw new Error('The length of an integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || INT$3, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}
function uintAttribSetter(gl, index) {
  return function (b) {
    if (b.value) {
      gl.disableVertexAttribArray(index);
      if (b.value.length === 4) {
        gl.vertexAttrib4uiv(index, b.value);
      } else {
        throw new Error('The length of an unsigned integer constant value must be 4!');
      }
    } else {
      gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
      gl.enableVertexAttribArray(index);
      gl.vertexAttribIPointer(index, b.numComponents || b.size, b.type || UNSIGNED_INT$3, b.stride || 0, b.offset || 0);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index, b.divisor);
      }
    }
  };
}
function matAttribSetter(gl, index, typeInfo) {
  const defaultSize = typeInfo.size;
  const count = typeInfo.count;
  return function (b) {
    gl.bindBuffer(ARRAY_BUFFER$1, b.buffer);
    const numComponents = b.size || b.numComponents || defaultSize;
    const size = numComponents / count;
    const type = b.type || FLOAT$3;
    const typeInfo = typeMap[type];
    const stride = typeInfo.size * numComponents;
    const normalize = b.normalize || false;
    const offset = b.offset || 0;
    const rowOffset = stride / count;
    for (let i = 0; i < count; ++i) {
      gl.enableVertexAttribArray(index + i);
      gl.vertexAttribPointer(index + i, size, type, normalize, stride, offset + rowOffset * i);
      if (b.divisor !== undefined) {
        gl.vertexAttribDivisor(index + i, b.divisor);
      }
    }
  };
}
const attrTypeMap = {};
attrTypeMap[FLOAT$3] = {
  size: 4,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC2] = {
  size: 8,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC3] = {
  size: 12,
  setter: floatAttribSetter
};
attrTypeMap[FLOAT_VEC4] = {
  size: 16,
  setter: floatAttribSetter
};
attrTypeMap[INT$3] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[INT_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[UNSIGNED_INT$3] = {
  size: 4,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC2] = {
  size: 8,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC3] = {
  size: 12,
  setter: uintAttribSetter
};
attrTypeMap[UNSIGNED_INT_VEC4] = {
  size: 16,
  setter: uintAttribSetter
};
attrTypeMap[BOOL] = {
  size: 4,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC2] = {
  size: 8,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC3] = {
  size: 12,
  setter: intAttribSetter
};
attrTypeMap[BOOL_VEC4] = {
  size: 16,
  setter: intAttribSetter
};
attrTypeMap[FLOAT_MAT2] = {
  size: 4,
  setter: matAttribSetter,
  count: 2
};
attrTypeMap[FLOAT_MAT3] = {
  size: 9,
  setter: matAttribSetter,
  count: 3
};
attrTypeMap[FLOAT_MAT4] = {
  size: 16,
  setter: matAttribSetter,
  count: 4
};
const errorRE = /ERROR:\s*\d+:(\d+)/gi;
function addLineNumbersWithError(src) {
  let log = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
  let lineOffset = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  // Note: Error message formats are not defined by any spec so this may or may not work.
  const matches = [...log.matchAll(errorRE)];
  const lineNoToErrorMap = new Map(matches.map((m, ndx) => {
    const lineNo = parseInt(m[1]);
    const next = matches[ndx + 1];
    const end = next ? next.index : log.length;
    const msg = log.substring(m.index, end);
    return [lineNo - 1, msg];
  }));
  return src.split('\n').map((line, lineNo) => {
    const err = lineNoToErrorMap.get(lineNo);
    return "".concat(lineNo + 1 + lineOffset, ": ").concat(line).concat(err ? "\n\n^^^ ".concat(err) : '');
  }).join('\n');
}

/**
 * Error Callback
 * @callback ErrorCallback
 * @param {string} msg error message.
 * @param {number} [lineOffset] amount to add to line number
 * @memberOf module:twgl
 */

/**
 * Program Callback
 * @callback ProgramCallback
 * @param {string} [err] error message, falsy if no error
 * @param {WebGLProgram|module:twgl.ProgramInfo} [result] the program or programInfo
 */

const spaceRE = /^[ \t]*\n/;

/**
 * Remove the first end of line because WebGL 2.0 requires
 * #version 300 es
 * as the first line. No whitespace allowed before that line
 * so
 *
 * <script>
 * #version 300 es
 * </script>
 *
 * Has one line before it which is invalid according to GLSL ES 3.00
 *
 * @param {string} shaderSource The source of the shader
 * @returns {{shaderSource: string, lineOffset: number}}
 * @private
 */
function prepShaderSource(shaderSource) {
  let lineOffset = 0;
  if (spaceRE.test(shaderSource)) {
    lineOffset = 1;
    shaderSource = shaderSource.replace(spaceRE, '');
  }
  return {
    lineOffset,
    shaderSource
  };
}

/**
 * @param {module:twgl.ProgramOptions} progOptions
 * @param {string} msg
 * @return null
 * @private
 */
function reportError(progOptions, msg) {
  progOptions.errorCallback(msg);
  if (progOptions.callback) {
    setTimeout(() => {
      progOptions.callback("".concat(msg, "\n").concat(progOptions.errors.join('\n')));
    });
  }
  return null;
}

/**
 * Loads a shader.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} shaderSource The shader source.
 * @param {number} shaderType The type of shader.
 * @param {module:twgl.ProgramOptions} progOptions
 * @return {WebGLShader} The created shader.
 * @private
 */
function loadShader(gl, shaderSource, shaderType, progOptions) {
  // Create the shader object
  const shader = gl.createShader(shaderType);

  // Load the shader source
  gl.shaderSource(shader, prepShaderSource(shaderSource).shaderSource);

  // Compile the shader
  gl.compileShader(shader);
  if (!progOptions.callback && !checkShaderStatus(gl, shaderType, shader, progOptions.errorCallback)) {
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

/**
 * Check Shader status
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {number} shaderType The shader type
 * @param {WebGLShader} shader The shader
 * @param {ErrorCallback} [errFn] function to receive error message.
 * @return {bool} true if shader is ok.
 * @private
 */
function checkShaderStatus(gl, shaderType, shader, errFn) {
  errFn = errFn || error$1;
  // Check the compile status
  const compiled = gl.getShaderParameter(shader, COMPILE_STATUS);
  if (!compiled) {
    // Something went wrong during compilation; get the error
    const lastError = gl.getShaderInfoLog(shader);
    const {
      lineOffset,
      shaderSource
    } = prepShaderSource(gl.getShaderSource(shader));
    errFn("".concat(addLineNumbersWithError(shaderSource, lastError, lineOffset), "\nError compiling ").concat(glEnumToString(gl, shaderType), ": ").concat(lastError));
  }
  return compiled;
}

/**
 * @typedef {Object} ProgramOptions
 * @property {function(string)} [errorCallback] callback for errors
 * @property {Object.<string,number>} [attribLocations] a attribute name to location map
 * @property {(module:twgl.BufferInfo|Object.<string,module:twgl.AttribInfo>|string[])} [transformFeedbackVaryings] If passed
 *   a BufferInfo will use the attribs names inside. If passed an object of AttribInfos will use the names from that object. Otherwise
 *   you can pass an array of names.
 * @property {number} [transformFeedbackMode] the mode to pass `gl.transformFeedbackVaryings`. Defaults to `SEPARATE_ATTRIBS`.
 * @property {ProgramCallback} [callback] callback for async program compilation.
 * @memberOf module:twgl
 */

/**
 * Gets the program options based on all these optional arguments
 * @param {module:twgl.ProgramOptions|string[]} [opt_attribs] Options for the program or an array of attribs names. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations] The locations for the. A parallel array to opt_attribs letting you assign locations.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramOptions} an instance of ProgramOptions based on the arguments passed in
 * @private
 */
function getProgramOptions(opt_attribs, opt_locations, opt_errorCallback) {
  let transformFeedbackVaryings;
  let transformFeedbackMode;
  let callback;
  if (typeof opt_locations === 'function') {
    opt_errorCallback = opt_locations;
    opt_locations = undefined;
  }
  if (typeof opt_attribs === 'function') {
    opt_errorCallback = opt_attribs;
    opt_attribs = undefined;
  } else if (opt_attribs && !Array.isArray(opt_attribs)) {
    // If we have an errorCallback we can just return this object
    // Otherwise we need to construct one with default errorCallback
    if (opt_attribs.errorCallback && opt_attribs.errors) {
      return opt_attribs;
    }
    const opt = opt_attribs;
    opt_errorCallback = opt.errorCallback;
    opt_attribs = opt.attribLocations;
    transformFeedbackVaryings = opt.transformFeedbackVaryings;
    transformFeedbackMode = opt.transformFeedbackMode;
    callback = opt.callback;
  }
  const errorCallback = opt_errorCallback || error$1;
  const errors = [];
  const options = {
    errorCallback(msg) {
      errors.push(msg);
      for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }
      errorCallback(msg, ...args);
    },
    transformFeedbackVaryings,
    transformFeedbackMode,
    callback,
    errors
  };
  if (opt_attribs) {
    let attribLocations = {};
    if (Array.isArray(opt_attribs)) {
      opt_attribs.forEach(function (attrib, ndx) {
        attribLocations[attrib] = opt_locations ? opt_locations[ndx] : ndx;
      });
    } else {
      attribLocations = opt_attribs;
    }
    options.attribLocations = attribLocations;
  }
  return options;
}
const defaultShaderType = ["VERTEX_SHADER", "FRAGMENT_SHADER"];
function getShaderTypeFromScriptType(gl, scriptType) {
  if (scriptType.indexOf("frag") >= 0) {
    return FRAGMENT_SHADER;
  } else if (scriptType.indexOf("vert") >= 0) {
    return VERTEX_SHADER;
  }
  return undefined;
}
function deleteShaders(gl, shaders) {
  shaders.forEach(function (shader) {
    gl.deleteShader(shader);
  });
}
const wait = function wait() {
  let ms = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
  return new Promise(resolve => setTimeout(resolve, ms));
};

/**
 * Creates a program, attaches (and/or compiles) shaders, binds attrib locations, links the
 * program.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgram(gl, [vs, fs], options);
 *     twgl.createProgram(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgram(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error of a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgram(gl, shaders, opt_attribs, opt_locations, opt_errorCallback) {
  // This code is really convoluted, because it may or may not be async
  // Maybe it would be better to have a separate function
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const realShaders = [];
  const newShaders = [];
  for (let ndx = 0; ndx < shaders.length; ++ndx) {
    let shader = shaders[ndx];
    if (typeof shader === 'string') {
      const elem = getElementById(shader);
      const src = elem ? elem.text : shader;
      let type = gl[defaultShaderType[ndx]];
      if (elem && elem.type) {
        type = getShaderTypeFromScriptType(gl, elem.type) || type;
      }
      shader = loadShader(gl, src, type, progOptions);
      newShaders.push(shader);
    }
    if (isShader(gl, shader)) {
      realShaders.push(shader);
    }
  }
  if (realShaders.length !== shaders.length) {
    deleteShaders(gl, newShaders);
    return reportError(progOptions, "not enough shaders for program");
  }
  const program = gl.createProgram();
  realShaders.forEach(function (shader) {
    gl.attachShader(program, shader);
  });
  if (progOptions.attribLocations) {
    Object.keys(progOptions.attribLocations).forEach(function (attrib) {
      gl.bindAttribLocation(program, progOptions.attribLocations[attrib], attrib);
    });
  }
  let varyings = progOptions.transformFeedbackVaryings;
  if (varyings) {
    if (varyings.attribs) {
      varyings = varyings.attribs;
    }
    if (!Array.isArray(varyings)) {
      varyings = Object.keys(varyings);
    }
    gl.transformFeedbackVaryings(program, varyings, progOptions.transformFeedbackMode || SEPARATE_ATTRIBS);
  }
  gl.linkProgram(program);
  if (progOptions.callback) {
    checkForProgramLinkCompletionAsync(gl, program, progOptions);
    return null;
  } else {
    if (!checkProgramStatus(gl, program, progOptions.errorCallback)) {
      gl.deleteProgram(program);
      deleteShaders(gl, newShaders);
      return null;
    }
    return program;
  }
}

/**
 * Same as createProgram but returns a promise
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramAsync(gl, [vs, fs], options);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramAsync(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLShader[]|string[]} shaders The shaders to attach, or element ids for their source, or strings that contain their source
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {Promise<WebGLProgram>} The created program
 * @memberOf module:twgl/programs
 */
function createProgramAsync(gl, shaders) {
  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
    args[_key2 - 2] = arguments[_key2];
  }
  return new Promise((resolve, reject) => {
    const programOptions = getProgramOptions(...args);
    programOptions.callback = (err, program) => {
      if (err) {
        reject(err);
      } else {
        resolve(program);
      }
    };
    createProgram(gl, shaders, programOptions);
  });
}

/**
 * Same as createProgramInfo but returns a promise
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {Promise<module:twgl.ProgramInfo>} The created ProgramInfo
 * @memberOf module:twgl/programs
 */
function createProgramInfoAsync(gl, shaders) {
  for (var _len3 = arguments.length, args = new Array(_len3 > 2 ? _len3 - 2 : 0), _key3 = 2; _key3 < _len3; _key3++) {
    args[_key3 - 2] = arguments[_key3];
  }
  return new Promise((resolve, reject) => {
    const programOptions = getProgramOptions(...args);
    programOptions.callback = (err, programInfo) => {
      if (err) {
        reject(err);
      } else {
        resolve(programInfo);
      }
    };
    createProgramInfo(gl, shaders, programOptions);
  });
}

/**
 * Asynchronously wait for program to link.
 * Note: if 'KHR_parallel_shader_compile' extension does not
 * exist then compilation will not be truly async.
 * @param {WebGLRenderingContext} gl The context
 * @param {WebGLProgram} program The program
 * @param {module:twgl.ProgramOptions} progOptions Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @private
 */
async function checkForProgramLinkCompletionAsync(gl, program, progOptions) {
  const ext = gl.getExtension('KHR_parallel_shader_compile');
  const checkFn = ext ? (gl, program) => gl.getProgramParameter(program, ext.COMPLETION_STATUS_KHR) : () => true;
  let waitTime = 0;
  do {
    await wait(waitTime); // must wait at least once
    waitTime = 1000 / 60;
  } while (!checkFn(gl, program));
  const success = checkProgramStatus(gl, program, progOptions.errorCallback);
  const err = success ? undefined : progOptions.errors.join('\n');
  if (!success) {
    const errFn = progOptions.errorCallback || error$1;
    errFn(err);
    gl.deleteProgram(program);
    // TODO: delete shaders, but only shaders that were created newly for this
    // program
    program = null;
  }
  progOptions.callback(err, program);
}

/**
 * Check a program's link status
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program Program to check
 * @param {ErrorCallback} [errFn] func for errors
 * @return {bool} true if program is ok
 * @private
 */
function checkProgramStatus(gl, program, errFn) {
  errFn = errFn || error$1;
  // Check the link status
  const linked = gl.getProgramParameter(program, LINK_STATUS);
  if (!linked) {
    // something went wrong with the link
    const lastError = gl.getProgramInfoLog(program);
    errFn("Error in program linking: ".concat(lastError));
  }
  return linked;
}

/**
 * Loads a shader from a script tag.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {string} scriptId The id of the script tag.
 * @param {number} [opt_shaderType] The type of shader. If not passed in it will
 *     be derived from the type of the script tag.
 * @param {module:twgl.ProgramOptions} [progOptions] callback for errors.
 * @return {WebGLShader?} The created shader or null if error.
 * @private
 */
function createShaderFromScript(gl, scriptId, opt_shaderType, progOptions) {
  let shaderSource = "";
  const shaderScript = getElementById(scriptId);
  if (!shaderScript) {
    return reportError(progOptions, "unknown script element: ".concat(scriptId));
  }
  shaderSource = shaderScript.text;
  const shaderType = opt_shaderType || getShaderTypeFromScriptType(gl, shaderScript.type);
  if (!shaderType) {
    return reportError(progOptions, 'unknown shader type');
  }
  return loadShader(gl, shaderSource, shaderType, progOptions);
}

/**
 * Creates a program from 2 script tags.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromScripts(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderScriptIds Array of ids of the script
 *        tags for the shaders. The first is assumed to be the
 *        vertex shader, the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error or a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgramFromScripts(gl, shaderScriptIds, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaders = [];
  for (let ii = 0; ii < shaderScriptIds.length; ++ii) {
    const shader = createShaderFromScript(gl, shaderScriptIds[ii], gl[defaultShaderType[ii]], progOptions);
    if (!shader) {
      return null;
    }
    shaders.push(shader);
  }
  return createProgram(gl, shaders, progOptions);
}

/**
 * Creates a program from 2 sources.
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_options);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramFromSource(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {WebGLProgram?} the created program or null if error or a callback was provided.
 * @memberOf module:twgl/programs
 */
function createProgramFromSources(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const shaders = [];
  for (let ii = 0; ii < shaderSources.length; ++ii) {
    const shader = loadShader(gl, shaderSources[ii], gl[defaultShaderType[ii]], progOptions);
    if (!progOptions.callback && !shader) {
      return null;
    }
    shaders.push(shader);
  }
  return createProgram(gl, shaders, progOptions);
}

/**
 * Returns true if attribute/uniform is a reserved/built in
 *
 * It makes no sense to me why GL returns these because it's
 * illegal to call `gl.getUniformLocation` and `gl.getAttribLocation`
 * with names that start with `gl_` (and `webgl_` in WebGL)
 *
 * I can only assume they are there because they might count
 * when computing the number of uniforms/attributes used when you want to
 * know if you are near the limit. That doesn't really make sense
 * to me but the fact that these get returned are in the spec.
 *
 * @param {WebGLActiveInfo} info As returned from `gl.getActiveUniform` or
 *    `gl.getActiveAttrib`.
 * @return {bool} true if it's reserved
 * @private
 */
function isBuiltIn(info) {
  const name = info.name;
  return name.startsWith("gl_") || name.startsWith("webgl_");
}
const tokenRE = /(\.|\[|]|\w+)/g;
const isDigit = s => s >= '0' && s <= '9';
function addSetterToUniformTree(fullPath, setter, node, uniformSetters) {
  const tokens = fullPath.split(tokenRE).filter(s => s !== '');
  let tokenNdx = 0;
  let path = '';
  for (;;) {
    const token = tokens[tokenNdx++]; // has to be name or number
    path += token;
    const isArrayIndex = isDigit(token[0]);
    const accessor = isArrayIndex ? parseInt(token) : token;
    if (isArrayIndex) {
      path += tokens[tokenNdx++]; // skip ']'
    }
    const isLastToken = tokenNdx === tokens.length;
    if (isLastToken) {
      node[accessor] = setter;
      break;
    } else {
      const token = tokens[tokenNdx++]; // has to be . or [
      const isArray = token === '[';
      const child = node[accessor] || (isArray ? [] : {});
      node[accessor] = child;
      node = child;
      uniformSetters[path] = uniformSetters[path] || function (node) {
        return function (value) {
          setUniformTree(node, value);
        };
      }(child);
      path += token;
    }
  }
}

/**
 * Creates setter functions for all uniforms of a shader
 * program.
 *
 * @see {@link module:twgl.setUniforms}
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @returns {Object.<string, function>} an object with a setter by name for each uniform
 * @memberOf module:twgl/programs
 */
function createUniformSetters(gl, program) {
  let textureUnit = 0;

  /**
   * Creates a setter for a uniform of the given program with it's
   * location embedded in the setter.
   * @param {WebGLProgram} program
   * @param {WebGLUniformInfo} uniformInfo
   * @returns {function} the created setter.
   */
  function createUniformSetter(program, uniformInfo, location) {
    const isArray = uniformInfo.name.endsWith("[0]");
    const type = uniformInfo.type;
    const typeInfo = typeMap[type];
    if (!typeInfo) {
      throw new Error("unknown type: 0x".concat(type.toString(16))); // we should never get here.
    }
    let setter;
    if (typeInfo.bindPoint) {
      // it's a sampler
      const unit = textureUnit;
      textureUnit += uniformInfo.size;
      if (isArray) {
        setter = typeInfo.arraySetter(gl, type, unit, location, uniformInfo.size);
      } else {
        setter = typeInfo.setter(gl, type, unit, location, uniformInfo.size);
      }
    } else {
      if (typeInfo.arraySetter && isArray) {
        setter = typeInfo.arraySetter(gl, location);
      } else {
        setter = typeInfo.setter(gl, location);
      }
    }
    setter.location = location;
    return setter;
  }
  const uniformSetters = {};
  const uniformTree = {};
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  for (let ii = 0; ii < numUniforms; ++ii) {
    const uniformInfo = gl.getActiveUniform(program, ii);
    if (isBuiltIn(uniformInfo)) {
      continue;
    }
    let name = uniformInfo.name;
    // remove the array suffix.
    if (name.endsWith("[0]")) {
      name = name.substr(0, name.length - 3);
    }
    const location = gl.getUniformLocation(program, uniformInfo.name);
    // the uniform will have no location if it's in a uniform block
    if (location) {
      const setter = createUniformSetter(program, uniformInfo, location);
      uniformSetters[name] = setter;
      addSetterToUniformTree(name, setter, uniformTree, uniformSetters);
    }
  }
  return uniformSetters;
}

/**
 * @typedef {Object} TransformFeedbackInfo
 * @property {number} index index of transform feedback
 * @property {number} type GL type
 * @property {number} size 1 - 4
 * @memberOf module:twgl
 */

/**
 * Create TransformFeedbackInfo for passing to bindTransformFeedbackInfo.
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {Object<string, module:twgl.TransformFeedbackInfo>}
 * @memberOf module:twgl
 */
function createTransformFeedbackInfo(gl, program) {
  const info = {};
  const numVaryings = gl.getProgramParameter(program, TRANSFORM_FEEDBACK_VARYINGS);
  for (let ii = 0; ii < numVaryings; ++ii) {
    const varying = gl.getTransformFeedbackVarying(program, ii);
    info[varying.name] = {
      index: ii,
      type: varying.type,
      size: varying.size
    };
  }
  return info;
}

/**
 * Binds buffers for transform feedback.
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {(module:twgl.ProgramInfo|Object<string, module:twgl.TransformFeedbackInfo>)} transformFeedbackInfo A ProgramInfo or TransformFeedbackInfo.
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @memberOf module:twgl
 */
function bindTransformFeedbackInfo(gl, transformFeedbackInfo, bufferInfo) {
  if (transformFeedbackInfo.transformFeedbackInfo) {
    transformFeedbackInfo = transformFeedbackInfo.transformFeedbackInfo;
  }
  if (bufferInfo.attribs) {
    bufferInfo = bufferInfo.attribs;
  }
  for (const name in bufferInfo) {
    const varying = transformFeedbackInfo[name];
    if (varying) {
      const buf = bufferInfo[name];
      if (buf.offset) {
        gl.bindBufferRange(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer, buf.offset, buf.size);
      } else {
        gl.bindBufferBase(TRANSFORM_FEEDBACK_BUFFER, varying.index, buf.buffer);
      }
    }
  }
}

/**
 * Creates a transform feedback and sets the buffers
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @param {(module:twgl.BufferInfo|Object<string, module:twgl.AttribInfo>)} [bufferInfo] A BufferInfo or set of AttribInfos.
 * @return {WebGLTransformFeedback} the created transform feedback
 * @memberOf module:twgl
 */
function createTransformFeedback(gl, programInfo, bufferInfo) {
  const tf = gl.createTransformFeedback();
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, tf);
  gl.useProgram(programInfo.program);
  bindTransformFeedbackInfo(gl, programInfo, bufferInfo);
  gl.bindTransformFeedback(TRANSFORM_FEEDBACK, null);
  return tf;
}

/**
 * @typedef {Object} UniformData
 * @property {string} name The name of the uniform
 * @property {number} type The WebGL type enum for this uniform
 * @property {number} size The number of elements for this uniform
 * @property {number} blockNdx The block index this uniform appears in
 * @property {number} offset The byte offset in the block for this uniform's value
 * @memberOf module:twgl
 */

/**
 * The specification for one UniformBlockObject
 *
 * @typedef {Object} BlockSpec
 * @property {number} index The index of the block.
 * @property {number} size The size in bytes needed for the block
 * @property {number[]} uniformIndices The indices of the uniforms used by the block. These indices
 *    correspond to entries in a UniformData array in the {@link module:twgl.UniformBlockSpec}.
 * @property {bool} usedByVertexShader Self explanatory
 * @property {bool} usedByFragmentShader Self explanatory
 * @property {bool} used Self explanatory
 * @memberOf module:twgl
 */

/**
 * A `UniformBlockSpec` represents the data needed to create and bind
 * UniformBlockObjects for a given program
 *
 * @typedef {Object} UniformBlockSpec
 * @property {Object.<string, module:twgl.BlockSpec>} blockSpecs The BlockSpec for each block by block name
 * @property {UniformData[]} uniformData An array of data for each uniform by uniform index.
 * @memberOf module:twgl
 */

/**
 * Creates a UniformBlockSpec for the given program.
 *
 * A UniformBlockSpec represents the data needed to create and bind
 * UniformBlockObjects
 *
 * @param {WebGL2RenderingContext} gl A WebGL2 Rendering Context
 * @param {WebGLProgram} program A WebGLProgram for a successfully linked program
 * @return {module:twgl.UniformBlockSpec} The created UniformBlockSpec
 * @memberOf module:twgl/programs
 */
function createUniformBlockSpecFromProgram(gl, program) {
  const numUniforms = gl.getProgramParameter(program, ACTIVE_UNIFORMS);
  const uniformData = [];
  const uniformIndices = [];
  for (let ii = 0; ii < numUniforms; ++ii) {
    uniformIndices.push(ii);
    uniformData.push({});
    const uniformInfo = gl.getActiveUniform(program, ii);
    uniformData[ii].name = uniformInfo.name;
  }
  [["UNIFORM_TYPE", "type"], ["UNIFORM_SIZE", "size"],
  // num elements
  ["UNIFORM_BLOCK_INDEX", "blockNdx"], ["UNIFORM_OFFSET", "offset"]].forEach(function (pair) {
    const pname = pair[0];
    const key = pair[1];
    gl.getActiveUniforms(program, uniformIndices, gl[pname]).forEach(function (value, ndx) {
      uniformData[ndx][key] = value;
    });
  });
  const blockSpecs = {};
  const numUniformBlocks = gl.getProgramParameter(program, ACTIVE_UNIFORM_BLOCKS);
  for (let ii = 0; ii < numUniformBlocks; ++ii) {
    const name = gl.getActiveUniformBlockName(program, ii);
    const blockSpec = {
      index: gl.getUniformBlockIndex(program, name),
      usedByVertexShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER),
      usedByFragmentShader: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER),
      size: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_DATA_SIZE),
      uniformIndices: gl.getActiveUniformBlockParameter(program, ii, UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES)
    };
    blockSpec.used = blockSpec.usedByVertexShader || blockSpec.usedByFragmentShader;
    blockSpecs[name] = blockSpec;
  }
  return {
    blockSpecs: blockSpecs,
    uniformData: uniformData
  };
}
const arraySuffixRE = /\[\d+\]\.$/; // better way to check?

const pad = (v, padding) => ((v + (padding - 1)) / padding | 0) * padding;
function createUniformBlockUniformSetter(view, isArray, rows, cols) {
  if (isArray || rows) {
    cols = cols || 1;
    const numElements = view.length;
    const totalRows = numElements / 4;
    return function (value) {
      let dst = 0;
      let src = 0;
      for (let row = 0; row < totalRows; ++row) {
        for (let col = 0; col < cols; ++col) {
          view[dst++] = value[src++];
        }
        dst += 4 - cols;
      }
    };
  } else {
    return function (value) {
      if (value.length) {
        view.set(value);
      } else {
        view[0] = value;
      }
    };
  }
}

/**
 * Represents a UniformBlockObject including an ArrayBuffer with all the uniform values
 * and a corresponding WebGLBuffer to hold those values on the GPU
 *
 * @typedef {Object} UniformBlockInfo
 * @property {string} name The name of the block
 * @property {ArrayBuffer} array The array buffer that contains the uniform values
 * @property {Float32Array} asFloat A float view on the array buffer. This is useful
 *    inspecting the contents of the buffer in the debugger.
 * @property {WebGLBuffer} buffer A WebGL buffer that will hold a copy of the uniform values for rendering.
 * @property {number} [offset] offset into buffer
 * @property {Object<string, ArrayBufferView>} uniforms A uniform name to ArrayBufferView map.
 *   each Uniform has a correctly typed `ArrayBufferView` into array at the correct offset
 *   and length of that uniform. So for example a float uniform would have a 1 float `Float32Array`
 *   view. A single mat4 would have a 16 element `Float32Array` view. An ivec2 would have an
 *   `Int32Array` view, etc.
 * @property {Object<string, function>} setters A setter for this uniform.
 *   The reason to use setters is elements of arrays are padded to vec4 sizes which
 *   means if you want to set an array of 4 floats you'd need to set 16 values
 *   (or set elements 0, 4, 8, 12). In other words
 *   `someBlockInfo.uniforms.some4FloatArrayUniform.set([0, , , , 1, , , , 2, , , , 3])`
 *   where as the setter handles just passing in [0, 1, 2, 3] either directly as in
 *   `someBlockInfo.setter.some4FloatArrayUniform.set([0, 1, 2, 3])` (not recommended)
 *   or via {@link module:twgl.setBlockUniforms}
 * @memberOf module:twgl
 */

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {WebGLProgram} program A WebGLProgram
 * @param {module:twgl.UniformBlockSpec} uniformBlockSpec. A UniformBlockSpec as returned
 *     from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfoFromProgram(gl, program, uniformBlockSpec, blockName) {
  const blockSpecs = uniformBlockSpec.blockSpecs;
  const uniformData = uniformBlockSpec.uniformData;
  const blockSpec = blockSpecs[blockName];
  if (!blockSpec) {
    warn$1("no uniform block object named:", blockName);
    return {
      name: blockName,
      uniforms: {}
    };
  }
  const array = new ArrayBuffer(blockSpec.size);
  const buffer = gl.createBuffer();
  const uniformBufferIndex = blockSpec.index;
  gl.bindBuffer(UNIFORM_BUFFER, buffer);
  gl.uniformBlockBinding(program, blockSpec.index, uniformBufferIndex);
  let prefix = blockName + ".";
  if (arraySuffixRE.test(prefix)) {
    prefix = prefix.replace(arraySuffixRE, ".");
  }
  const uniforms = {};
  const setters = {};
  const setterTree = {};
  blockSpec.uniformIndices.forEach(function (uniformNdx) {
    const data = uniformData[uniformNdx];
    let name = data.name;
    if (name.startsWith(prefix)) {
      name = name.substr(prefix.length);
    }
    const isArray = name.endsWith('[0]');
    if (isArray) {
      name = name.substr(0, name.length - 3);
    }
    const typeInfo = typeMap[data.type];
    const Type = typeInfo.Type;
    const byteLength = isArray ? pad(typeInfo.size, 16) * data.size : typeInfo.size * data.size;
    const uniformView = new Type(array, data.offset, byteLength / Type.BYTES_PER_ELEMENT);
    uniforms[name] = uniformView;
    // Note: I'm not sure what to do here. The original
    // idea was to create TypedArray views into each part
    // of the block. This is useful, for example if you have
    // a block with { mat4: model; mat4 view; mat4 projection; }
    // you'll get a Float32Array for each one suitable for
    // passing to most JS math libraries including twgl's and glMatrix.js.
    //
    // But, if you have a an array of structures, especially if that
    // array is large, you get a whole bunch of TypedArray views.
    // Every one of them has overhead and switching between them all
    // is probably a cache miss. In that case it would really be better
    // to just have one view (asFloat) and have all the setters
    // just reference the correct portion. But, then you can't easily
    // treat a matrix, or a vec4, as a standalone thing like you can
    // with all the views.
    //
    // Another problem with the views is they are not shared. With
    // uniforms you have one set of setters. With UniformBlockInfo
    // you have a set of setters *pre block instance*. That's because
    // TypedArray views can't be mapped to different buffers.
    //
    // My gut right now is if you really want the speed and compactness
    // then you should probably roll your own solution. TWGL's goal
    // here is ease of use as AFAICT there is no simple generic efficient
    // solution.
    const setter = createUniformBlockUniformSetter(uniformView, isArray, typeInfo.rows, typeInfo.cols);
    setters[name] = setter;
    addSetterToUniformTree(name, setter, setterTree, setters);
  });
  return {
    name: blockName,
    array,
    asFloat: new Float32Array(array),
    // for debugging
    buffer,
    uniforms,
    setters
  };
}

/**
 * Creates a `UniformBlockInfo` for the specified block
 *
 * Note: **If the blockName matches no existing blocks a warning is printed to the console and a dummy
 * `UniformBlockInfo` is returned**. This is because when debugging GLSL
 * it is common to comment out large portions of a shader or for example set
 * the final output to a constant. When that happens blocks get optimized out.
 * If this function did not create dummy blocks your code would crash when debugging.
 *
 * @param {WebGL2RenderingContext} gl A WebGL2RenderingContext
 * @param {module:twgl.ProgramInfo} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo}
 * @param {string} blockName The name of the block.
 * @return {module:twgl.UniformBlockInfo} The created UniformBlockInfo
 * @memberOf module:twgl/programs
 */
function createUniformBlockInfo(gl, programInfo, blockName) {
  return createUniformBlockInfoFromProgram(gl, programInfo.program, programInfo.uniformBlockSpec, blockName);
}

/**
 * Binds a uniform block to the matching uniform block point.
 * Matches by blocks by name so blocks must have the same name not just the same
 * structure.
 *
 * If you have changed any values and you upload the values into the corresponding WebGLBuffer
 * call {@link module:twgl.setUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @return {bool} true if buffer was bound. If the programInfo has no block with the same block name
 *     no buffer is bound.
 * @memberOf module:twgl/programs
 */
function bindUniformBlock(gl, programInfo, uniformBlockInfo) {
  const uniformBlockSpec = programInfo.uniformBlockSpec || programInfo;
  const blockSpec = uniformBlockSpec.blockSpecs[uniformBlockInfo.name];
  if (blockSpec) {
    const bufferBindIndex = blockSpec.index;
    gl.bindBufferRange(UNIFORM_BUFFER, bufferBindIndex, uniformBlockInfo.buffer, uniformBlockInfo.offset || 0, uniformBlockInfo.array.byteLength);
    return true;
  }
  return false;
}

/**
 * Uploads the current uniform values to the corresponding WebGLBuffer
 * and binds that buffer to the program's corresponding bind point for the uniform block object.
 *
 * If you haven't changed any values and you only need to bind the uniform block object
 * call {@link module:twgl.bindUniformBlock} instead.
 *
 * @param {WebGL2RenderingContext} gl A WebGL 2 rendering context.
 * @param {(module:twgl.ProgramInfo|module:twgl.UniformBlockSpec)} programInfo a `ProgramInfo`
 *     as returned from {@link module:twgl.createProgramInfo} or or `UniformBlockSpec` as
 *     returned from {@link module:twgl.createUniformBlockSpecFromProgram}.
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo a `UniformBlockInfo` as returned from
 *     {@link module:twgl.createUniformBlockInfo}.
 * @memberOf module:twgl/programs
 */
function setUniformBlock(gl, programInfo, uniformBlockInfo) {
  if (bindUniformBlock(gl, programInfo, uniformBlockInfo)) {
    gl.bufferData(UNIFORM_BUFFER, uniformBlockInfo.array, DYNAMIC_DRAW);
  }
}

/**
 * Sets values of a uniform block object
 *
 * @param {module:twgl.UniformBlockInfo} uniformBlockInfo A UniformBlockInfo as returned by {@link module:twgl.createUniformBlockInfo}.
 * @param {Object.<string, ?>} values A uniform name to value map where the value is correct for the given
 *    type of uniform. So for example given a block like
 *
 *       uniform SomeBlock {
 *         float someFloat;
 *         vec2 someVec2;
 *         vec3 someVec3Array[2];
 *         int someInt;
 *       }
 *
 *  You can set the values of the uniform block with
 *
 *       twgl.setBlockUniforms(someBlockInfo, {
 *          someFloat: 12.3,
 *          someVec2: [1, 2],
 *          someVec3Array: [1, 2, 3, 4, 5, 6],
 *          someInt: 5,
 *       }
 *
 *  Arrays can be JavaScript arrays or typed arrays
 *
 *  You can also fill out structure and array values either via
 *  shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *       float nearFar[2];
 *     };
 *     uniform Lights {
 *       Light lights[2];
 *     };
 *
 *     // in JavaScript
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.1, 10] },
 *         { intensity: 2.0, color: [0, 0, 1, 1], nearFar[0.2, 15] },
 *       ],
 *     });
 *
 *   or the more traditional way
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[0].nearFar": [0.1, 10],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *       "lights[1].nearFar": [0.2, 15],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       'lights[1]': { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.2, 15] },
 *     });
 *
 *   But you can not specify leaf array indices.
 *
 *     twgl.setBlockUniforms(someBlockInfo, {
 *       'lights[1].nearFar[1]': 15,     // BAD! nearFar is a leaf
 *       'lights[1].nearFar': [0.2, 15], // GOOD
 *     });
 *
 *  **IMPORTANT!**, packing in a UniformBlock is unintuitive.
 *  For example the actual layout of `someVec3Array` above in memory
 *  is `1, 2, 3, unused, 4, 5, 6, unused`. twgl takes in 6 values
 *  as shown about and copies them, skipping the padding. This might
 *  be confusing if you're already familiar with Uniform blocks.
 *
 *  If you want to deal with the padding yourself you can access the array
 *  buffer views directly. eg:
 *
 *      someBlockInfo.someVec3Array.set([1, 2, 3, 0, 4, 5, 6, 0]);
 *
 *  Any name that doesn't match will be ignored
 * @memberOf module:twgl/programs
 */
function setBlockUniforms(uniformBlockInfo, values) {
  const setters = uniformBlockInfo.setters;
  for (const name in values) {
    const setter = setters[name];
    if (setter) {
      const value = values[name];
      setter(value);
    }
  }
}
function setUniformTree(tree, values) {
  for (const name in values) {
    const prop = tree[name];
    if (typeof prop === 'function') {
      prop(values[name]);
    } else {
      setUniformTree(tree[name], values[name]);
    }
  }
}

/**
 * Set uniforms and binds related textures.
 *
 * example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs"]);
 *
 *     const tex1 = gl.createTexture();
 *     const tex2 = gl.createTexture();
 *
 *     ... assume we setup the textures with data ...
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the textures AND set the
 * uniforms.
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *
 * For the example above it is equivalent to
 *
 *     var texUnit = 0;
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex1);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.activeTexture(gl.TEXTURE0 + texUnit);
 *     gl.bindTexture(gl.TEXTURE_2D, tex2);
 *     gl.uniform1i(u_someSamplerLocation, texUnit++);
 *     gl.uniform4fv(u_someColorLocation, [1, 0, 0, 1]);
 *     gl.uniform3fv(u_somePositionLocation, [0, 1, 1]);
 *     gl.uniformMatrix4fv(u_someMatrix, false, [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ]);
 *
 * Note it is perfectly reasonable to call `setUniforms` multiple times. For example
 *
 *     const uniforms = {
 *       u_someSampler: tex1,
 *       u_someOtherSampler: tex2,
 *     };
 *
 *     const moreUniforms {
 *       u_someColor: [1,0,0,1],
 *       u_somePosition: [0,1,1],
 *       u_someMatrix: [
 *         1,0,0,0,
 *         0,1,0,0,
 *         0,0,1,0,
 *         0,0,0,0,
 *       ],
 *     };
 *
 *     twgl.setUniforms(programInfo, uniforms);
 *     twgl.setUniforms(programInfo, moreUniforms);
 *
 * You can also add WebGLSamplers to uniform samplers as in
 *
 *     const uniforms = {
 *       u_someSampler: {
 *         texture: someWebGLTexture,
 *         sampler: someWebGLSampler,
 *       },
 *     };
 *
 * In which case both the sampler and texture will be bound to the
 * same unit.
 *
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 *        uniforms.
 *   You can pass multiple objects by putting them in an array or by calling with more arguments.For example
 *
 *     const sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     const localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     twgl.setUniforms(programInfo, sharedUniforms, localUniforms);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, [sharedUniforms, localUniforms]);
 *
 *     // is the same as
 *
 *     twgl.setUniforms(programInfo, sharedUniforms);
 *     twgl.setUniforms(programInfo, localUniforms};
 *
 *   You can also fill out structure and array values either via
 *   shortcut. Example
 *
 *     // -- in shader --
 *     struct Light {
 *       float intensity;
 *       vec4 color;
 *       float nearFar[2];
 *     };
 *     uniform Light lights[2];
 *
 *     // in JavaScript
 *
 *     twgl.setUniforms(programInfo, {
 *       lights: [
 *         { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.1, 10] },
 *         { intensity: 2.0, color: [0, 0, 1, 1], nearFar[0.2, 15] },
 *       ],
 *     });
 *
 *   or the more traditional way
 *
 *     twgl.setUniforms(programInfo, {
 *       "lights[0].intensity": 5.0,
 *       "lights[0].color": [1, 0, 0, 1],
 *       "lights[0].nearFar": [0.1, 10],
 *       "lights[1].intensity": 2.0,
 *       "lights[1].color": [0, 0, 1, 1],
 *       "lights[1].nearFar": [0.2, 15],
 *     });
 *
 *   You can also specify partial paths
 *
 *     twgl.setUniforms(programInfo, {
 *       'lights[1]': { intensity: 5.0, color: [1, 0, 0, 1], nearFar[0.2, 15] },
 *     });
 *
 *   But you can not specify leaf array indices
 *
 *     twgl.setUniforms(programInfo, {
 *       'lights[1].nearFar[1]': 15,     // BAD! nearFar is a leaf
 *       'lights[1].nearFar': [0.2, 15], // GOOD
 *     });
 *
 * @memberOf module:twgl/programs
 */
function setUniforms(setters) {
  // eslint-disable-line
  const actualSetters = setters.uniformSetters || setters;
  const numArgs = arguments.length <= 1 ? 0 : arguments.length - 1;
  for (let aNdx = 0; aNdx < numArgs; ++aNdx) {
    const values = aNdx + 1 < 1 || arguments.length <= aNdx + 1 ? undefined : arguments[aNdx + 1];
    if (Array.isArray(values)) {
      const numValues = values.length;
      for (let ii = 0; ii < numValues; ++ii) {
        setUniforms(actualSetters, values[ii]);
      }
    } else {
      for (const name in values) {
        const setter = actualSetters[name];
        if (setter) {
          setter(values[name]);
        }
      }
    }
  }
}

/**
 * Alias for `setUniforms`
 * @function
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters a `ProgramInfo` as returned from `createProgramInfo` or the setters returned from
 *        `createUniformSetters`.
 * @param {Object.<string, ?>} values an object with values for the
 * @memberOf module:twgl/programs
 */
const setUniformsAndBindTextures = setUniforms;

/**
 * Creates setter functions for all attributes of a shader
 * program. You can pass this to {@link module:twgl.setBuffersAndAttributes} to set all your buffers and attributes.
 *
 * @see {@link module:twgl.setAttributes} for example
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {WebGLProgram} program the program to create setters for.
 * @return {Object.<string, function>} an object with a setter for each attribute by name.
 * @memberOf module:twgl/programs
 */
function createAttributeSetters(gl, program) {
  const attribSetters = {};
  const numAttribs = gl.getProgramParameter(program, ACTIVE_ATTRIBUTES);
  for (let ii = 0; ii < numAttribs; ++ii) {
    const attribInfo = gl.getActiveAttrib(program, ii);
    if (isBuiltIn(attribInfo)) {
      continue;
    }
    const index = gl.getAttribLocation(program, attribInfo.name);
    const typeInfo = attrTypeMap[attribInfo.type];
    const setter = typeInfo.setter(gl, index, typeInfo);
    setter.location = index;
    attribSetters[attribInfo.name] = setter;
  }
  return attribSetters;
}

/**
 * Sets attributes and binds buffers (deprecated... use {@link module:twgl.setBuffersAndAttributes})
 *
 * Example:
 *
 *     const program = createProgramFromScripts(
 *         gl, ["some-vs", "some-fs");
 *
 *     const attribSetters = createAttributeSetters(program);
 *
 *     const positionBuffer = gl.createBuffer();
 *     const texcoordBuffer = gl.createBuffer();
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *     };
 *
 *     gl.useProgram(program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setAttributes(attribSetters, attribs);
 *
 * Properties of attribs. For each attrib you can add
 * properties:
 *
 * *   type: the type of data in the buffer. Default = gl.FLOAT
 * *   normalize: whether or not to normalize the data. Default = false
 * *   stride: the stride. Default = 0
 * *   offset: offset into the buffer. Default = 0
 * *   divisor: the divisor for instances. Default = undefined
 *
 * For example if you had 3 value float positions, 2 value
 * float texcoord and 4 value uint8 colors you'd setup your
 * attribs like this
 *
 *     const attribs = {
 *       a_position: {buffer: positionBuffer, numComponents: 3},
 *       a_texcoord: {buffer: texcoordBuffer, numComponents: 2},
 *       a_color: {
 *         buffer: colorBuffer,
 *         numComponents: 4,
 *         type: gl.UNSIGNED_BYTE,
 *         normalize: true,
 *       },
 *     };
 *
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} buffers AttribInfos mapped by attribute name.
 * @memberOf module:twgl/programs
 * @deprecated use {@link module:twgl.setBuffersAndAttributes}
 * @private
 */
function setAttributes(setters, buffers) {
  for (const name in buffers) {
    const setter = setters[name];
    if (setter) {
      setter(buffers[name]);
    }
  }
}

/**
 * Sets attributes and buffers including the `ELEMENT_ARRAY_BUFFER` if appropriate
 *
 * Example:
 *
 *     const programInfo = createProgramInfo(
 *         gl, ["some-vs", "some-fs");
 *
 *     const arrays = {
 *       position: { numComponents: 3, data: [0, 0, 0, 10, 0, 0, 0, 10, 0, 10, 10, 0], },
 *       texcoord: { numComponents: 2, data: [0, 0, 0, 1, 1, 0, 1, 1],                 },
 *     };
 *
 *     const bufferInfo = createBufferInfoFromArrays(gl, arrays);
 *
 *     gl.useProgram(programInfo.program);
 *
 * This will automatically bind the buffers AND set the
 * attributes.
 *
 *     setBuffersAndAttributes(gl, programInfo, bufferInfo);
 *
 * For the example above it is equivalent to
 *
 *     gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
 *     gl.enableVertexAttribArray(a_positionLocation);
 *     gl.vertexAttribPointer(a_positionLocation, 3, gl.FLOAT, false, 0, 0);
 *     gl.bindBuffer(gl.ARRAY_BUFFER, texcoordBuffer);
 *     gl.enableVertexAttribArray(a_texcoordLocation);
 *     gl.vertexAttribPointer(a_texcoordLocation, 4, gl.FLOAT, false, 0, 0);
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext.
 * @param {(module:twgl.ProgramInfo|Object.<string, function>)} setters A `ProgramInfo` as returned from {@link module:twgl.createProgramInfo} or Attribute setters as returned from {@link module:twgl.createAttributeSetters}
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} buffers a `BufferInfo` as returned from {@link module:twgl.createBufferInfoFromArrays}.
 *   or a `VertexArrayInfo` as returned from {@link module:twgl.createVertexArrayInfo}
 * @memberOf module:twgl/programs
 */
function setBuffersAndAttributes(gl, programInfo, buffers) {
  if (buffers.vertexArrayObject) {
    gl.bindVertexArray(buffers.vertexArrayObject);
  } else {
    setAttributes(programInfo.attribSetters || programInfo, buffers.attribs);
    if (buffers.indices) {
      gl.bindBuffer(ELEMENT_ARRAY_BUFFER$1, buffers.indices);
    }
  }
}

/**
 * @typedef {Object} ProgramInfo
 * @property {WebGLProgram} program A shader program
 * @property {Object<string, function>} uniformSetters object of setters as returned from createUniformSetters,
 * @property {Object<string, function>} attribSetters object of setters as returned from createAttribSetters,
 * @property {module:twgl.UniformBlockSpec} [uniformBlockSpec] a uniform block spec for making UniformBlockInfos with createUniformBlockInfo etc..
 * @property {Object<string, module:twgl.TransformFeedbackInfo>} [transformFeedbackInfo] info for transform feedbacks
 * @memberOf module:twgl
 */

/**
 * Creates a ProgramInfo from an existing program.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {WebGLProgram} program an existing WebGLProgram.
 * @return {module:twgl.ProgramInfo} The created ProgramInfo.
 * @memberOf module:twgl/programs
 */
function createProgramInfoFromProgram(gl, program) {
  const uniformSetters = createUniformSetters(gl, program);
  const attribSetters = createAttributeSetters(gl, program);
  const programInfo = {
    program,
    uniformSetters,
    attribSetters
  };
  if (isWebGL2(gl)) {
    programInfo.uniformBlockSpec = createUniformBlockSpecFromProgram(gl, program);
    programInfo.transformFeedbackInfo = createTransformFeedbackInfo(gl, program);
  }
  return programInfo;
}
const notIdRE = /\s|{|}|;/;

/**
 * Creates a ProgramInfo from 2 sources.
 *
 * A ProgramInfo contains
 *
 *     programInfo = {
 *        program: WebGLProgram,
 *        uniformSetters: object of setters as returned from createUniformSetters,
 *        attribSetters: object of setters as returned from createAttribSetters,
 *     }
 *
 * NOTE: There are 4 signatures for this function
 *
 *     twgl.createProgramInfo(gl, [vs, fs], options);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_errFunc);
 *     twgl.createProgramInfo(gl, [vs, fs], opt_attribs, opt_locations, opt_errFunc);
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {string[]} shaderSources Array of sources for the
 *        shaders or ids. The first is assumed to be the vertex shader,
 *        the second the fragment shader.
 * @param {module:twgl.ProgramOptions|string[]|module:twgl.ErrorCallback} [opt_attribs] Options for the program or an array of attribs names or an error callback. Locations will be assigned by index if not passed in
 * @param {number[]} [opt_locations|module:twgl.ErrorCallback] The locations for the. A parallel array to opt_attribs letting you assign locations or an error callback.
 * @param {module:twgl.ErrorCallback} [opt_errorCallback] callback for errors. By default it just prints an error to the console
 *        on error. If you want something else pass an callback. It's passed an error message.
 * @return {module:twgl.ProgramInfo?} The created ProgramInfo or null if it failed to link or compile
 * @memberOf module:twgl/programs
 */
function createProgramInfo(gl, shaderSources, opt_attribs, opt_locations, opt_errorCallback) {
  const progOptions = getProgramOptions(opt_attribs, opt_locations, opt_errorCallback);
  const errors = [];
  shaderSources = shaderSources.map(function (source) {
    // Lets assume if there is no \n it's an id
    if (!notIdRE.test(source)) {
      const script = getElementById(source);
      if (!script) {
        const err = "no element with id: ".concat(source);
        progOptions.errorCallback(err);
        errors.push(err);
      } else {
        source = script.text;
      }
    }
    return source;
  });
  if (errors.length) {
    return reportError(progOptions, '');
  }
  const origCallback = progOptions.callback;
  if (origCallback) {
    progOptions.callback = (err, program) => {
      let programInfo;
      if (!err) {
        programInfo = createProgramInfoFromProgram(gl, program);
      }
      origCallback(err, programInfo);
    };
  }
  const program = createProgramFromSources(gl, shaderSources, progOptions);
  if (!program) {
    return null;
  }
  return createProgramInfoFromProgram(gl, program);
}
var programs = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createAttributeSetters: createAttributeSetters,
  createProgram: createProgram,
  createProgramAsync: createProgramAsync,
  createProgramFromScripts: createProgramFromScripts,
  createProgramFromSources: createProgramFromSources,
  createProgramInfo: createProgramInfo,
  createProgramInfoAsync: createProgramInfoAsync,
  createProgramInfoFromProgram: createProgramInfoFromProgram,
  createUniformSetters: createUniformSetters,
  createUniformBlockSpecFromProgram: createUniformBlockSpecFromProgram,
  createUniformBlockInfoFromProgram: createUniformBlockInfoFromProgram,
  createUniformBlockInfo: createUniformBlockInfo,
  createTransformFeedback: createTransformFeedback,
  createTransformFeedbackInfo: createTransformFeedbackInfo,
  bindTransformFeedbackInfo: bindTransformFeedbackInfo,
  setAttributes: setAttributes,
  setBuffersAndAttributes: setBuffersAndAttributes,
  setUniforms: setUniforms,
  setUniformsAndBindTextures: setUniformsAndBindTextures,
  setUniformBlock: setUniformBlock,
  setBlockUniforms: setBlockUniforms,
  bindUniformBlock: bindUniformBlock
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const TRIANGLES = 0x0004;
const UNSIGNED_SHORT$3 = 0x1403;

/**
 * Drawing related functions
 *
 * For backward compatibility they are available at both `twgl.draw` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/draw
 */

/**
 * Calls `gl.drawElements` or `gl.drawArrays`, whichever is appropriate
 *
 * normally you'd call `gl.drawElements` or `gl.drawArrays` yourself
 * but calling this means if you switch from indexed data to non-indexed
 * data you don't have to remember to update your draw call.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {(module:twgl.BufferInfo|module:twgl.VertexArrayInfo)} bufferInfo A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays} or
 *   a VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @param {number} [type] eg (gl.TRIANGLES, gl.LINES, gl.POINTS, gl.TRIANGLE_STRIP, ...). Defaults to `gl.TRIANGLES`
 * @param {number} [count] An optional count. Defaults to bufferInfo.numElements
 * @param {number} [offset] An optional offset. Defaults to 0.
 * @param {number} [instanceCount] An optional instanceCount. if set then `drawArraysInstanced` or `drawElementsInstanced` will be called
 * @memberOf module:twgl/draw
 */
function drawBufferInfo(gl, bufferInfo, type, count, offset, instanceCount) {
  type = type === undefined ? TRIANGLES : type;
  const indices = bufferInfo.indices;
  const elementType = bufferInfo.elementType;
  const numElements = count === undefined ? bufferInfo.numElements : count;
  offset = offset === undefined ? 0 : offset;
  if (elementType || indices) {
    if (instanceCount !== undefined) {
      gl.drawElementsInstanced(type, numElements, elementType === undefined ? UNSIGNED_SHORT$3 : bufferInfo.elementType, offset, instanceCount);
    } else {
      gl.drawElements(type, numElements, elementType === undefined ? UNSIGNED_SHORT$3 : bufferInfo.elementType, offset);
    }
  } else {
    if (instanceCount !== undefined) {
      gl.drawArraysInstanced(type, offset, numElements, instanceCount);
    } else {
      gl.drawArrays(type, offset, numElements);
    }
  }
}

/**
 * A DrawObject is useful for putting objects in to an array and passing them to {@link module:twgl.drawObjectList}.
 *
 * You need either a `BufferInfo` or a `VertexArrayInfo`.
 *
 * @typedef {Object} DrawObject
 * @property {boolean} [active] whether or not to draw. Default = `true` (must be `false` to be not true). In other words `undefined` = `true`
 * @property {number} [type] type to draw eg. `gl.TRIANGLES`, `gl.LINES`, etc...
 * @property {module:twgl.ProgramInfo} programInfo A ProgramInfo as returned from {@link module:twgl.createProgramInfo}
 * @property {module:twgl.BufferInfo} [bufferInfo] A BufferInfo as returned from {@link module:twgl.createBufferInfoFromArrays}
 * @property {module:twgl.VertexArrayInfo} [vertexArrayInfo] A VertexArrayInfo as returned from {@link module:twgl.createVertexArrayInfo}
 * @property {Object<string, ?>} uniforms The values for the uniforms.
 *   You can pass multiple objects by putting them in an array. For example
 *
 *     var sharedUniforms = {
 *       u_fogNear: 10,
 *       u_projection: ...
 *       ...
 *     };
 *
 *     var localUniforms = {
 *       u_world: ...
 *       u_diffuseColor: ...
 *     };
 *
 *     var drawObj = {
 *       ...
 *       uniforms: [sharedUniforms, localUniforms],
 *     };
 *
 * @property {number} [offset] the offset to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to 0.
 * @property {number} [count] the count to pass to `gl.drawArrays` or `gl.drawElements`. Defaults to bufferInfo.numElements.
 * @property {number} [instanceCount] the number of instances. Defaults to undefined.
 * @memberOf module:twgl
 */

/**
 * Draws a list of objects
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {DrawObject[]} objectsToDraw an array of objects to draw.
 * @memberOf module:twgl/draw
 */
function drawObjectList(gl, objectsToDraw) {
  let lastUsedProgramInfo = null;
  let lastUsedBufferInfo = null;
  objectsToDraw.forEach(function (object) {
    if (object.active === false) {
      return;
    }
    const programInfo = object.programInfo;
    const bufferInfo = object.vertexArrayInfo || object.bufferInfo;
    let bindBuffers = false;
    const type = object.type === undefined ? TRIANGLES : object.type;
    if (programInfo !== lastUsedProgramInfo) {
      lastUsedProgramInfo = programInfo;
      gl.useProgram(programInfo.program);

      // We have to rebind buffers when changing programs because we
      // only bind buffers the program uses. So if 2 programs use the same
      // bufferInfo but the 1st one uses only positions the when the
      // we switch to the 2nd one some of the attributes will not be on.
      bindBuffers = true;
    }

    // Setup all the needed attributes.
    if (bindBuffers || bufferInfo !== lastUsedBufferInfo) {
      if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject && !bufferInfo.vertexArrayObject) {
        gl.bindVertexArray(null);
      }
      lastUsedBufferInfo = bufferInfo;
      setBuffersAndAttributes(gl, programInfo, bufferInfo);
    }

    // Set the uniforms.
    setUniforms(programInfo, object.uniforms);

    // Draw
    drawBufferInfo(gl, bufferInfo, type, object.count, object.offset, object.instanceCount);
  });
  if (lastUsedBufferInfo && lastUsedBufferInfo.vertexArrayObject) {
    gl.bindVertexArray(null);
  }
}
var draw = /*#__PURE__*/Object.freeze({
  __proto__: null,
  drawBufferInfo: drawBufferInfo,
  drawObjectList: drawObjectList
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

const FRAMEBUFFER = 0x8d40;
const RENDERBUFFER = 0x8d41;
const TEXTURE_2D$2 = 0x0de1;
const UNSIGNED_BYTE$3 = 0x1401;

/* PixelFormat */
const DEPTH_COMPONENT$1 = 0x1902;
const RGBA$1 = 0x1908;
const DEPTH_COMPONENT24$1 = 0x81a6;
const DEPTH_COMPONENT32F$1 = 0x8cac;
const DEPTH24_STENCIL8$1 = 0x88f0;
const DEPTH32F_STENCIL8$1 = 0x8cad;

/* Framebuffer Object. */
const RGBA4$1 = 0x8056;
const RGB5_A1$1 = 0x8057;
const RGB565$1 = 0x8D62;
const DEPTH_COMPONENT16$1 = 0x81A5;
const STENCIL_INDEX = 0x1901;
const STENCIL_INDEX8 = 0x8D48;
const DEPTH_STENCIL$1 = 0x84F9;
const COLOR_ATTACHMENT0 = 0x8CE0;
const DEPTH_ATTACHMENT = 0x8D00;
const STENCIL_ATTACHMENT = 0x8D20;
const DEPTH_STENCIL_ATTACHMENT = 0x821A;

/* TextureWrapMode */
const CLAMP_TO_EDGE$1 = 0x812F;

/* TextureMagFilter */
const LINEAR$1 = 0x2601;

/**
 * The options for a framebuffer attachment.
 *
 * Note: For a `format` that is a texture include all the texture
 * options from {@link module:twgl.TextureOptions} for example
 * `min`, `mag`, `clamp`, etc... Note that unlike {@link module:twgl.TextureOptions}
 * `auto` defaults to `false` for attachment textures but `min` and `mag` default
 * to `gl.LINEAR` and `wrap` defaults to `CLAMP_TO_EDGE`
 *
 * @typedef {Object} AttachmentOptions
 * @property {number} [attachmentPoint] The attachment point. Defaults
 *   to `gl.COLOR_ATTACHMENT0 + ndx` unless type is a depth or stencil type
 *   then it's gl.DEPTH_ATTACHMENT or `gl.DEPTH_STENCIL_ATTACHMENT` depending
 *   on the format or attachment type.
 * @property {number} [format] The format. If one of `gl.RGBA4`,
 *   `gl.RGB565`, `gl.RGB5_A1`, `gl.DEPTH_COMPONENT16`,
 *   `gl.STENCIL_INDEX8` or `gl.DEPTH_STENCIL` then will create a
 *   renderbuffer. Otherwise will create a texture. Default = `gl.RGBA`
 * @property {number} [type] The type. Used for texture. Default = `gl.UNSIGNED_BYTE`.
 * @property {number} [target] The texture target for `gl.framebufferTexture2D`.
 *   Defaults to `gl.TEXTURE_2D`. Set to appropriate face for cube maps.
 * @property {number} [samples] The number of samples. Default = 1
 * @property {number} [level] level for `gl.framebufferTexture2D`. Defaults to 0.
 * @property {number} [layer] layer for `gl.framebufferTextureLayer`. Defaults to undefined.
 *   If set then `gl.framebufferTextureLayer` is called, if not then `gl.framebufferTexture2D`
 * @property {(WebGLRenderbuffer | WebGLTexture)} [attachment] An existing renderbuffer or texture.
 *    If provided will attach this Object. This allows you to share
 *    attachments across framebuffers.
 * @memberOf module:twgl
 * @mixes module:twgl.TextureOptions
 */

const defaultAttachments = [{
  format: RGBA$1,
  type: UNSIGNED_BYTE$3,
  min: LINEAR$1,
  wrap: CLAMP_TO_EDGE$1
}, {
  format: DEPTH_STENCIL$1
}];
const attachmentsByFormat = {};
attachmentsByFormat[DEPTH_STENCIL$1] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX] = STENCIL_ATTACHMENT;
attachmentsByFormat[STENCIL_INDEX8] = STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT16$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT24$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH_COMPONENT32F$1] = DEPTH_ATTACHMENT;
attachmentsByFormat[DEPTH24_STENCIL8$1] = DEPTH_STENCIL_ATTACHMENT;
attachmentsByFormat[DEPTH32F_STENCIL8$1] = DEPTH_STENCIL_ATTACHMENT;
function getAttachmentPointForFormat(format, internalFormat) {
  return attachmentsByFormat[format] || attachmentsByFormat[internalFormat];
}
const renderbufferFormats = {};
renderbufferFormats[RGBA4$1] = true;
renderbufferFormats[RGB5_A1$1] = true;
renderbufferFormats[RGB565$1] = true;
renderbufferFormats[DEPTH_STENCIL$1] = true;
renderbufferFormats[DEPTH_COMPONENT16$1] = true;
renderbufferFormats[STENCIL_INDEX] = true;
renderbufferFormats[STENCIL_INDEX8] = true;
function isRenderbufferFormat(format) {
  return renderbufferFormats[format];
}
const MAX_COLOR_ATTACHMENT_POINTS = 32; // even an 3090 only supports 8 but WebGL/OpenGL ES define constants for 32

function isColorAttachmentPoint(attachmentPoint) {
  return attachmentPoint >= COLOR_ATTACHMENT0 && attachmentPoint < COLOR_ATTACHMENT0 + MAX_COLOR_ATTACHMENT_POINTS;
}

/**
 * @typedef {Object} FramebufferInfo
 * @property {WebGLFramebuffer} framebuffer The WebGLFramebuffer for this framebufferInfo
 * @property {Array.<(WebGLRenderbuffer | WebGLTexture)>} attachments The created attachments in the same order as passed in to {@link module:twgl.createFramebufferInfo}.
 * @property {number} width The width of the framebuffer and its attachments
 * @property {number} height The width of the framebuffer and its attachments
 * @memberOf module:twgl
 */

/**
 * Creates a framebuffer and attachments.
 *
 * This returns a {@link module:twgl.FramebufferInfo} because it needs to return the attachments as well as the framebuffer.
 * It also leaves the framebuffer it just created as the currently bound `FRAMEBUFFER`.
 * Note: If this is WebGL2 or if you called {@link module:twgl.addExtensionsToContext} then it will set the drawBuffers
 * to `[COLOR_ATTACHMENT0, COLOR_ATTACHMENT1, ...]` for how ever many color attachments were created.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 * Passing in a specific size
 *
 *     const width = 256;
 *     const height = 256;
 *     const fbi = twgl.createFramebufferInfo(gl, attachments, width, height);
 *
 * **Note!!** It is up to you to check if the framebuffer is renderable by calling `gl.checkFramebufferStatus`.
 * [WebGL1 only guarantees 3 combinations of attachments work](https://www.khronos.org/registry/webgl/specs/latest/1.0/#6.6).
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.AttachmentOptions[]} [attachments] which attachments to create. If not provided the default is a framebuffer with an
 *    `RGBA`, `UNSIGNED_BYTE` texture `COLOR_ATTACHMENT0` and a `DEPTH_STENCIL` renderbuffer `DEPTH_STENCIL_ATTACHMENT`.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @return {module:twgl.FramebufferInfo} the framebuffer and attachments.
 * @memberOf module:twgl/framebuffers
 */
function createFramebufferInfo(gl, attachments, width, height) {
  const target = FRAMEBUFFER;
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(target, fb);
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  attachments = attachments || defaultAttachments;
  const usedColorAttachmentsPoints = [];
  const framebufferInfo = {
    framebuffer: fb,
    attachments: [],
    width: width,
    height: height
  };
  attachments.forEach(function (attachmentOptions, i) {
    let attachment = attachmentOptions.attachment;
    const samples = attachmentOptions.samples;
    const format = attachmentOptions.format;
    let attachmentPoint = attachmentOptions.attachmentPoint || getAttachmentPointForFormat(format, attachmentOptions.internalFormat);
    if (!attachmentPoint) {
      attachmentPoint = COLOR_ATTACHMENT0 + i;
    }
    if (isColorAttachmentPoint(attachmentPoint)) {
      usedColorAttachmentsPoints.push(attachmentPoint);
    }
    if (!attachment) {
      if (samples !== undefined || isRenderbufferFormat(format)) {
        attachment = gl.createRenderbuffer();
        gl.bindRenderbuffer(RENDERBUFFER, attachment);
        if (samples > 1) {
          gl.renderbufferStorageMultisample(RENDERBUFFER, samples, format, width, height);
        } else {
          gl.renderbufferStorage(RENDERBUFFER, format, width, height);
        }
      } else {
        const textureOptions = Object.assign({}, attachmentOptions);
        textureOptions.width = width;
        textureOptions.height = height;
        if (textureOptions.auto === undefined) {
          textureOptions.auto = false;
          textureOptions.min = textureOptions.min || textureOptions.minMag || LINEAR$1;
          textureOptions.mag = textureOptions.mag || textureOptions.minMag || LINEAR$1;
          textureOptions.wrapS = textureOptions.wrapS || textureOptions.wrap || CLAMP_TO_EDGE$1;
          textureOptions.wrapT = textureOptions.wrapT || textureOptions.wrap || CLAMP_TO_EDGE$1;
        }
        attachment = createTexture(gl, textureOptions);
      }
    }
    if (isRenderbuffer(gl, attachment)) {
      gl.framebufferRenderbuffer(target, attachmentPoint, RENDERBUFFER, attachment);
    } else if (isTexture(gl, attachment)) {
      if (attachmentOptions.layer !== undefined) {
        gl.framebufferTextureLayer(target, attachmentPoint, attachment, attachmentOptions.level || 0, attachmentOptions.layer);
      } else {
        gl.framebufferTexture2D(target, attachmentPoint, attachmentOptions.target || TEXTURE_2D$2, attachment, attachmentOptions.level || 0);
      }
    } else {
      throw new Error('unknown attachment type');
    }
    framebufferInfo.attachments.push(attachment);
  });
  if (gl.drawBuffers) {
    gl.drawBuffers(usedColorAttachmentsPoints);
  }
  return framebufferInfo;
}

/**
 * Resizes the attachments of a framebuffer.
 *
 * You need to pass in the same `attachments` as you passed in {@link module:twgl.createFramebufferInfo}
 * because TWGL has no idea the format/type of each attachment.
 *
 * The simplest usage
 *
 *     // create an RGBA/UNSIGNED_BYTE texture and DEPTH_STENCIL renderbuffer
 *     const fbi = twgl.createFramebufferInfo(gl);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments
 *         twgl.resizeFramebufferInfo(gl, fbi);
 *       }
 *
 * More complex usage
 *
 *     // create an RGB565 renderbuffer and a STENCIL_INDEX8 renderbuffer
 *     const attachments = [
 *       { format: RGB565, mag: NEAREST },
 *       { format: STENCIL_INDEX8 },
 *     ]
 *     const fbi = twgl.createFramebufferInfo(gl, attachments);
 *
 *     ...
 *
 *     function render() {
 *       if (twgl.resizeCanvasToDisplaySize(gl.canvas)) {
 *         // resize the attachments to match
 *         twgl.resizeFramebufferInfo(gl, fbi, attachments);
 *       }
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo} framebufferInfo a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 * @param {module:twgl.AttachmentOptions[]} [attachments] the same attachments options as passed to {@link module:twgl.createFramebufferInfo}.
 * @param {number} [width] the width for the attachments. Default = size of drawingBuffer
 * @param {number} [height] the height for the attachments. Default = size of drawingBuffer
 * @memberOf module:twgl/framebuffers
 */
function resizeFramebufferInfo(gl, framebufferInfo, attachments, width, height) {
  width = width || gl.drawingBufferWidth;
  height = height || gl.drawingBufferHeight;
  framebufferInfo.width = width;
  framebufferInfo.height = height;
  attachments = attachments || defaultAttachments;
  attachments.forEach(function (attachmentOptions, ndx) {
    const attachment = framebufferInfo.attachments[ndx];
    const format = attachmentOptions.format;
    const samples = attachmentOptions.samples;
    if (samples !== undefined || isRenderbuffer(gl, attachment)) {
      gl.bindRenderbuffer(RENDERBUFFER, attachment);
      if (samples > 1) {
        gl.renderbufferStorageMultisample(RENDERBUFFER, samples, format, width, height);
      } else {
        gl.renderbufferStorage(RENDERBUFFER, format, width, height);
      }
    } else if (isTexture(gl, attachment)) {
      resizeTexture(gl, attachment, attachmentOptions, width, height);
    } else {
      throw new Error('unknown attachment type');
    }
  });
}

/**
 * Binds a framebuffer
 *
 * This function pretty much solely exists because I spent hours
 * trying to figure out why something I wrote wasn't working only
 * to realize I forget to set the viewport dimensions.
 * My hope is this function will fix that.
 *
 * It is effectively the same as
 *
 *     gl.bindFramebuffer(gl.FRAMEBUFFER, someFramebufferInfo.framebuffer);
 *     gl.viewport(0, 0, someFramebufferInfo.width, someFramebufferInfo.height);
 *
 * @param {WebGLRenderingContext} gl the WebGLRenderingContext
 * @param {module:twgl.FramebufferInfo|null} [framebufferInfo] a framebufferInfo as returned from {@link module:twgl.createFramebufferInfo}.
 *   If falsy will bind the canvas.
 * @param {number} [target] The target. If not passed `gl.FRAMEBUFFER` will be used.
 * @memberOf module:twgl/framebuffers
 */

function bindFramebufferInfo(gl, framebufferInfo, target) {
  target = target || FRAMEBUFFER;
  if (framebufferInfo) {
    gl.bindFramebuffer(target, framebufferInfo.framebuffer);
    gl.viewport(0, 0, framebufferInfo.width, framebufferInfo.height);
  } else {
    gl.bindFramebuffer(target, null);
    gl.viewport(0, 0, gl.drawingBufferWidth, gl.drawingBufferHeight);
  }
}
var framebuffers = /*#__PURE__*/Object.freeze({
  __proto__: null,
  bindFramebufferInfo: bindFramebufferInfo,
  createFramebufferInfo: createFramebufferInfo,
  resizeFramebufferInfo: resizeFramebufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/**
 * vertex array object related functions
 *
 * You should generally not need to use these functions. They are provided
 * for those cases where you're doing something out of the ordinary
 * and you need lower level access.
 *
 * For backward compatibility they are available at both `twgl.attributes` and `twgl`
 * itself
 *
 * See {@link module:twgl} for core functions
 *
 * @module twgl/vertexArrays
 */

const ELEMENT_ARRAY_BUFFER$2 = 0x8893;

/**
 * @typedef {Object} VertexArrayInfo
 * @property {number} numElements The number of elements to pass to `gl.drawArrays` or `gl.drawElements`.
 * @property {number} [elementType] The type of indices `UNSIGNED_BYTE`, `UNSIGNED_SHORT` etc..
 * @property {WebGLVertexArrayObject} [vertexArrayObject] a vertex array object
 * @memberOf module:twgl
 */

/**
 * Creates a VertexArrayInfo from a BufferInfo and one or more ProgramInfos
 *
 * This can be passed to {@link module:twgl.setBuffersAndAttributes} and to
 * {@link module:twgl:drawBufferInfo}.
 *
 * > **IMPORTANT:** Vertex Array Objects are **not** a direct analog for a BufferInfo. Vertex Array Objects
 *   assign buffers to specific attributes at creation time. That means they can only be used with programs
 *   who's attributes use the same attribute locations for the same purposes.
 *
 * > Bind your attribute locations by passing an array of attribute names to {@link module:twgl.createProgramInfo}
 *   or use WebGL 2's GLSL ES 3's `layout(location = <num>)` to make sure locations match.
 *
 * also
 *
 * > **IMPORTANT:** After calling twgl.setBuffersAndAttribute with a BufferInfo that uses a Vertex Array Object
 *   that Vertex Array Object will be bound. That means **ANY MANIPULATION OF ELEMENT_ARRAY_BUFFER or ATTRIBUTES**
 *   will affect the Vertex Array Object state.
 *
 * > Call `gl.bindVertexArray(null)` to get back manipulating the global attributes and ELEMENT_ARRAY_BUFFER.
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @param {module:twgl.ProgramInfo|module:twgl.ProgramInfo[]} programInfo a programInfo or array of programInfos
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 *
 *    You need to make sure every attribute that will be used is bound. So for example assume shader 1
 *    uses attributes A, B, C and shader 2 uses attributes A, B, D. If you only pass in the programInfo
 *    for shader 1 then only attributes A, B, and C will have their attributes set because TWGL doesn't
 *    now attribute D's location.
 *
 *    So, you can pass in both shader 1 and shader 2's programInfo
 *
 * @return {module:twgl.VertexArrayInfo} The created VertexArrayInfo
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVertexArrayInfo(gl, programInfos, bufferInfo) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  if (!programInfos.length) {
    programInfos = [programInfos];
  }
  programInfos.forEach(function (programInfo) {
    setBuffersAndAttributes(gl, programInfo, bufferInfo);
  });
  gl.bindVertexArray(null);
  return {
    numElements: bufferInfo.numElements,
    elementType: bufferInfo.elementType,
    vertexArrayObject: vao
  };
}

/**
 * Creates a vertex array object and then sets the attributes on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext to use.
 * @param {Object.<string, function>} setters Attribute setters as returned from createAttributeSetters
 * @param {Object.<string, module:twgl.AttribInfo>} attribs AttribInfos mapped by attribute name.
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 *
 * @return {WebGLVertexArrayObject|null} The created WebGLVertexArrayObject
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVAOAndSetAttributes(gl, setters, attribs, indices) {
  const vao = gl.createVertexArray();
  gl.bindVertexArray(vao);
  setAttributes(setters, attribs);
  if (indices) {
    gl.bindBuffer(ELEMENT_ARRAY_BUFFER$2, indices);
  }
  // We unbind this because otherwise any change to ELEMENT_ARRAY_BUFFER
  // like when creating buffers for other stuff will mess up this VAO's binding
  gl.bindVertexArray(null);
  return vao;
}

/**
 * Creates a vertex array object and then sets the attributes
 * on it
 *
 * @param {WebGLRenderingContext} gl The WebGLRenderingContext
 *        to use.
 * @param {Object.<string, function>| module:twgl.ProgramInfo} programInfo as returned from createProgramInfo or Attribute setters as returned from createAttributeSetters
 * @param {module:twgl.BufferInfo} bufferInfo BufferInfo as returned from createBufferInfoFromArrays etc...
 * @param {WebGLBuffer} [indices] an optional ELEMENT_ARRAY_BUFFER of indices
 *
 * @return {WebGLVertexArrayObject|null} The created WebGLVertexArrayObject
 *
 * @memberOf module:twgl/vertexArrays
 */
function createVAOFromBufferInfo(gl, programInfo, bufferInfo) {
  return createVAOAndSetAttributes(gl, programInfo.attribSetters || programInfo, bufferInfo.attribs, bufferInfo.indices);
}
var vertexArrays = /*#__PURE__*/Object.freeze({
  __proto__: null,
  createVertexArrayInfo: createVertexArrayInfo,
  createVAOAndSetAttributes: createVAOAndSetAttributes,
  createVAOFromBufferInfo: createVAOFromBufferInfo
});

/*
 * Copyright 2019 Gregg Tavares
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
 * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */
const defaults$2 = {
  addExtensionsToContext: true
};

/**
 * Various default settings for twgl.
 *
 * Note: You can call this any number of times. Example:
 *
 *     twgl.setDefaults({ textureColor: [1, 0, 0, 1] });
 *     twgl.setDefaults({ attribPrefix: 'a_' });
 *
 * is equivalent to
 *
 *     twgl.setDefaults({
 *       textureColor: [1, 0, 0, 1],
 *       attribPrefix: 'a_',
 *     });
 *
 * @typedef {Object} Defaults
 * @property {string} [attribPrefix] The prefix to stick on attributes
 *
 *   When writing shaders I prefer to name attributes with `a_`, uniforms with `u_` and varyings with `v_`
 *   as it makes it clear where they came from. But, when building geometry I prefer using un-prefixed names.
 *
 *   In other words I'll create arrays of geometry like this
 *
 *       const arrays = {
 *         position: ...
 *         normal: ...
 *         texcoord: ...
 *       };
 *
 *   But need those mapped to attributes and my attributes start with `a_`.
 *
 *   Default: `""`
 *
 * @property {number[]} [textureColor] Array of 4 values in the range 0 to 1
 *
 *   The default texture color is used when loading textures from
 *   urls. Because the URL will be loaded async we'd like to be
 *   able to use the texture immediately. By putting a 1x1 pixel
 *   color in the texture we can start using the texture before
 *   the URL has loaded.
 *
 *   Default: `[0.5, 0.75, 1, 1]`
 *
 * @property {string} [crossOrigin]
 *
 *   If not undefined sets the crossOrigin attribute on images
 *   that twgl creates when downloading images for textures.
 *
 *   Also see {@link module:twgl.TextureOptions}.
 *
 * @property {bool} [addExtensionsToContext]
 *
 *   If true, then, when twgl will try to add any supported WebGL extensions
 *   directly to the context under their normal GL names. For example
 *   if ANGLE_instances_arrays exists then twgl would enable it,
 *   add the functions `vertexAttribDivisor`, `drawArraysInstanced`,
 *   `drawElementsInstanced`, and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR`
 *   to the `WebGLRenderingContext`.
 *
 * @memberOf module:twgl
 */

/**
 * Sets various defaults for twgl.
 *
 * In the interest of terseness which is kind of the point
 * of twgl I've integrated a few of the older functions here
 *
 * @param {module:twgl.Defaults} newDefaults The default settings.
 * @memberOf module:twgl
 */
function setDefaults$2(newDefaults) {
  copyExistingProperties(newDefaults, defaults$2);
  setDefaults(newDefaults); // eslint-disable-line
  setDefaults$1(newDefaults); // eslint-disable-line
}
const prefixRE = /^(.*?)_/;
function addExtensionToContext(gl, extensionName) {
  glEnumToString(gl, 0);
  const ext = gl.getExtension(extensionName);
  if (ext) {
    const enums = {};
    const fnSuffix = prefixRE.exec(extensionName)[1];
    const enumSuffix = '_' + fnSuffix;
    for (const key in ext) {
      const value = ext[key];
      const isFunc = typeof value === 'function';
      const suffix = isFunc ? fnSuffix : enumSuffix;
      let name = key;
      // examples of where this is not true are WEBGL_compressed_texture_s3tc
      // and WEBGL_compressed_texture_pvrtc
      if (key.endsWith(suffix)) {
        name = key.substring(0, key.length - suffix.length);
      }
      if (gl[name] !== undefined) {
        if (!isFunc && gl[name] !== value) {
          warn(name, gl[name], value, key);
        }
      } else {
        if (isFunc) {
          gl[name] = function (origFn) {
            return function () {
              return origFn.apply(ext, arguments);
            };
          }(value);
        } else {
          gl[name] = value;
          enums[name] = value;
        }
      }
    }
    // pass the modified enums to glEnumToString
    enums.constructor = {
      name: ext.constructor.name
    };
    glEnumToString(enums, 0);
  }
  return ext;
}

/*
 * If you're wondering why the code doesn't just iterate
 * over all extensions using `gl.getExtensions` is that it's possible
 * some future extension is incompatible with this code. Rather than
 * have thing suddenly break it seems better to manually add to this
 * list.
 *
 */
const supportedExtensions = ['ANGLE_instanced_arrays', 'EXT_blend_minmax', 'EXT_color_buffer_float', 'EXT_color_buffer_half_float', 'EXT_disjoint_timer_query', 'EXT_disjoint_timer_query_webgl2', 'EXT_frag_depth', 'EXT_sRGB', 'EXT_shader_texture_lod', 'EXT_texture_filter_anisotropic', 'OES_element_index_uint', 'OES_standard_derivatives', 'OES_texture_float', 'OES_texture_float_linear', 'OES_texture_half_float', 'OES_texture_half_float_linear', 'OES_vertex_array_object', 'WEBGL_color_buffer_float', 'WEBGL_compressed_texture_atc', 'WEBGL_compressed_texture_etc1', 'WEBGL_compressed_texture_pvrtc', 'WEBGL_compressed_texture_s3tc', 'WEBGL_compressed_texture_s3tc_srgb', 'WEBGL_depth_texture', 'WEBGL_draw_buffers'];

/**
 * Attempts to enable all of the following extensions
 * and add their functions and constants to the
 * `WebGLRenderingContext` using their normal non-extension like names.
 *
 *      ANGLE_instanced_arrays
 *      EXT_blend_minmax
 *      EXT_color_buffer_float
 *      EXT_color_buffer_half_float
 *      EXT_disjoint_timer_query
 *      EXT_disjoint_timer_query_webgl2
 *      EXT_frag_depth
 *      EXT_sRGB
 *      EXT_shader_texture_lod
 *      EXT_texture_filter_anisotropic
 *      OES_element_index_uint
 *      OES_standard_derivatives
 *      OES_texture_float
 *      OES_texture_float_linear
 *      OES_texture_half_float
 *      OES_texture_half_float_linear
 *      OES_vertex_array_object
 *      WEBGL_color_buffer_float
 *      WEBGL_compressed_texture_atc
 *      WEBGL_compressed_texture_etc1
 *      WEBGL_compressed_texture_pvrtc
 *      WEBGL_compressed_texture_s3tc
 *      WEBGL_compressed_texture_s3tc_srgb
 *      WEBGL_depth_texture
 *      WEBGL_draw_buffers
 *
 * For example if `ANGLE_instanced_arrays` exists then the functions
 * `drawArraysInstanced`, `drawElementsInstanced`, `vertexAttribDivisor`
 * and the constant `VERTEX_ATTRIB_ARRAY_DIVISOR` are added to the
 * `WebGLRenderingContext`.
 *
 * Note that if you want to know if the extension exists you should
 * probably call `gl.getExtension` for each extension. Alternatively
 * you can check for the existence of the functions or constants that
 * are expected to be added. For example
 *
 *    if (gl.drawBuffers) {
 *      // Either WEBGL_draw_buffers was enabled OR you're running in WebGL2
 *      ....
 *
 * @param {WebGLRenderingContext} gl A WebGLRenderingContext
 * @memberOf module:twgl
 */
function addExtensionsToContext(gl) {
  for (let ii = 0; ii < supportedExtensions.length; ++ii) {
    addExtensionToContext(gl, supportedExtensions[ii]);
  }
}

/**
 * Creates a webgl context.
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 * @private
 */
function create3DContext(canvas, opt_attribs) {
  const names = ["webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults$2.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL1 context.
 *
 * Note: Will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 * @deprecated
 * @private
 */
function getWebGLContext(canvas, opt_attribs) {
  const gl = create3DContext(canvas, opt_attribs);
  return gl;
}

/**
 * Creates a webgl context.
 *
 * Will return a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *     twgl.isWebGL2(gl);
 *
 * @param {HTMLCanvasElement} canvas The canvas tag to get
 *     context from. If one is not passed in one will be
 *     created.
 * @return {WebGLRenderingContext} The created context.
 */
function createContext(canvas, opt_attribs) {
  const names = ["webgl2", "webgl", "experimental-webgl"];
  let context = null;
  for (let ii = 0; ii < names.length; ++ii) {
    context = canvas.getContext(names[ii], opt_attribs);
    if (context) {
      if (defaults$2.addExtensionsToContext) {
        addExtensionsToContext(context);
      }
      break;
    }
  }
  return context;
}

/**
 * Gets a WebGL context.  Will create a WebGL2 context if possible.
 *
 * You can check if it's WebGL2 with
 *
 *    function isWebGL2(gl) {
 *      return gl.getParameter(gl.VERSION).indexOf("WebGL 2.0 ") == 0;
 *    }
 *
 * Note: For a WebGL1 context will attempt to enable Vertex Array Objects
 * and add WebGL2 entry points. (unless you first set defaults with
 * `twgl.setDefaults({enableVertexArrayObjects: false})`;
 *
 * @param {HTMLCanvasElement} canvas a canvas element.
 * @param {WebGLContextAttributes} [opt_attribs] optional webgl context creation attributes
 * @return {WebGLRenderingContext} The created context.
 * @memberOf module:twgl
 */
function getContext(canvas, opt_attribs) {
  const gl = createContext(canvas, opt_attribs);
  return gl;
}

/**
 * Resize a canvas to match the size it's displayed.
 * @param {HTMLCanvasElement} canvas The canvas to resize.
 * @param {number} [multiplier] So you can pass in `window.devicePixelRatio` or other scale value if you want to.
 * @return {boolean} true if the canvas was resized.
 * @memberOf module:twgl
 */
function resizeCanvasToDisplaySize(canvas, multiplier) {
  multiplier = multiplier || 1;
  multiplier = Math.max(0, multiplier);
  const width = canvas.clientWidth * multiplier | 0;
  const height = canvas.clientHeight * multiplier | 0;
  if (canvas.width !== width || canvas.height !== height) {
    canvas.width = width;
    canvas.height = height;
    return true;
  }
  return false;
}


/***/ }),

/***/ "./node_modules/unicode-trie/index.js":
/*!********************************************!*\
  !*** ./node_modules/unicode-trie/index.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

// Generated by CoffeeScript 1.7.1
var UnicodeTrie, inflate;
inflate = __webpack_require__(/*! tiny-inflate */ "./node_modules/tiny-inflate/index.js");
UnicodeTrie = function () {
  var DATA_BLOCK_LENGTH, DATA_GRANULARITY, DATA_MASK, INDEX_1_OFFSET, INDEX_2_BLOCK_LENGTH, INDEX_2_BMP_LENGTH, INDEX_2_MASK, INDEX_SHIFT, LSCP_INDEX_2_LENGTH, LSCP_INDEX_2_OFFSET, OMITTED_BMP_INDEX_1_LENGTH, SHIFT_1, SHIFT_1_2, SHIFT_2, UTF8_2B_INDEX_2_LENGTH, UTF8_2B_INDEX_2_OFFSET;
  SHIFT_1 = 6 + 5;
  SHIFT_2 = 5;
  SHIFT_1_2 = SHIFT_1 - SHIFT_2;
  OMITTED_BMP_INDEX_1_LENGTH = 0x10000 >> SHIFT_1;
  INDEX_2_BLOCK_LENGTH = 1 << SHIFT_1_2;
  INDEX_2_MASK = INDEX_2_BLOCK_LENGTH - 1;
  INDEX_SHIFT = 2;
  DATA_BLOCK_LENGTH = 1 << SHIFT_2;
  DATA_MASK = DATA_BLOCK_LENGTH - 1;
  LSCP_INDEX_2_OFFSET = 0x10000 >> SHIFT_2;
  LSCP_INDEX_2_LENGTH = 0x400 >> SHIFT_2;
  INDEX_2_BMP_LENGTH = LSCP_INDEX_2_OFFSET + LSCP_INDEX_2_LENGTH;
  UTF8_2B_INDEX_2_OFFSET = INDEX_2_BMP_LENGTH;
  UTF8_2B_INDEX_2_LENGTH = 0x800 >> 6;
  INDEX_1_OFFSET = UTF8_2B_INDEX_2_OFFSET + UTF8_2B_INDEX_2_LENGTH;
  DATA_GRANULARITY = 1 << INDEX_SHIFT;
  function UnicodeTrie(data) {
    var isBuffer, uncompressedLength, view;
    isBuffer = typeof data.readUInt32BE === 'function' && typeof data.slice === 'function';
    if (isBuffer || data instanceof Uint8Array) {
      if (isBuffer) {
        this.highStart = data.readUInt32BE(0);
        this.errorValue = data.readUInt32BE(4);
        uncompressedLength = data.readUInt32BE(8);
        data = data.slice(12);
      } else {
        view = new DataView(data.buffer);
        this.highStart = view.getUint32(0);
        this.errorValue = view.getUint32(4);
        uncompressedLength = view.getUint32(8);
        data = data.subarray(12);
      }
      data = inflate(data, new Uint8Array(uncompressedLength));
      data = inflate(data, new Uint8Array(uncompressedLength));
      this.data = new Uint32Array(data.buffer);
    } else {
      this.data = data.data, this.highStart = data.highStart, this.errorValue = data.errorValue;
    }
  }
  UnicodeTrie.prototype.get = function (codePoint) {
    var index;
    if (codePoint < 0 || codePoint > 0x10ffff) {
      return this.errorValue;
    }
    if (codePoint < 0xd800 || codePoint > 0xdbff && codePoint <= 0xffff) {
      index = (this.data[codePoint >> SHIFT_2] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint <= 0xffff) {
      index = (this.data[LSCP_INDEX_2_OFFSET + (codePoint - 0xd800 >> SHIFT_2)] << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    if (codePoint < this.highStart) {
      index = this.data[INDEX_1_OFFSET - OMITTED_BMP_INDEX_1_LENGTH + (codePoint >> SHIFT_1)];
      index = this.data[index + (codePoint >> SHIFT_2 & INDEX_2_MASK)];
      index = (index << INDEX_SHIFT) + (codePoint & DATA_MASK);
      return this.data[index];
    }
    return this.data[this.data.length - DATA_GRANULARITY];
  };
  return UnicodeTrie;
}();
module.exports = UnicodeTrie;

/***/ }),

/***/ "./node_modules/ify-loader/index.js!./node_modules/grapheme-breaker/src/GraphemeBreaker.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/ify-loader/index.js!./node_modules/grapheme-breaker/src/GraphemeBreaker.js ***!
  \*************************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ "./node_modules/buffer/index.js")["Buffer"];
// Generated by CoffeeScript 1.8.0
(function() {
  var CR, Control, Extend, L, LF, LV, LVT, Regional_Indicator, SpacingMark, T, UnicodeTrie, V, classTrie, codePointAt, fs, shouldBreak, _ref;

  _ref = __webpack_require__(/*! ./classes.json */ "./node_modules/grapheme-breaker/src/classes.json"), CR = _ref.CR, LF = _ref.LF, Control = _ref.Control, Extend = _ref.Extend, Regional_Indicator = _ref.Regional_Indicator, SpacingMark = _ref.SpacingMark, L = _ref.L, V = _ref.V, T = _ref.T, LV = _ref.LV, LVT = _ref.LVT;

  UnicodeTrie = __webpack_require__(/*! unicode-trie */ "./node_modules/unicode-trie/index.js");

  

  classTrie = new UnicodeTrie(Buffer("AA4QAAAAAAAAAHbgAQgG9/ntmkuIXjUUxzN+r3k4bUWQVotSHVCsoov6qIoiToWKFYvMuLHVtlaoLqQilLrwtakuxFYoLmQQYWalRYpUKYJV0am4mMUooojgSEG7EC2CdiHq/3rzMcc0yT333jyu0xz4kdwkN+ckOXncfN9QS4jzwCqwBqwHt5O0uuFGsBlsAhOM8lvATkv+LrAb7AXPgRfBAfAqeJ2UmwZvgcPgKDgGjoNZMAe+AN+C5W0hLgAXtvN3KZci7UpwFVgHbgHjYAPYJJ8nwCTYCnaQ58dI+cfBHvn8DFgL9kl9LyP8LLOflJ8CM+Q5K39IPo/28vfeyd6X8fcR/5jYP4v4nHyeR/iNjC8gPAl+BU+T8qcRFx0hBsGKzn/74LreIrdKxsGkRO0zE48wy7lmZSfnYkmWdhnCtTK+oHnnWqUPbuyY679N5t2J8B4ZnyTltyK+Dezq5P62G+Femf+sDPdp6n8JaQcterN5NWXJ5/Ij+FnGR0n6BvCbZk4kwjGjjO8rGh9woedNoudtBz6VSCQSiUQikUgkEomET97t5Hdp/ecvGfcXH+CdWfLNu6onxGowh7SvZPp3CE+A63v5feBJxMcQPyXz/0D4N2h18+cRhEcQnt+1674I+Q+inofANrAd7AAPg529lJfyUl7KS3mu8+4G94H7e/H3rPWRid3+RGIpc0nBGbAuE63F39VV1mjS6Pn4VCv++jN9bs4JMM5gbFSIdaNnpj+ppE3j+QQYWybEA8vytP0IPwF/gpXLsQ+AhWH0xYgQPwwJMTjA46YRXrnVw4vxzYjvke8dzvQx60gkEonE0uQA9oU3wB04J7yH/fDDVv4/j+x/QqfJXv0RuEueJe7t5vkTCLeQ88V2zVkjq+tRpD/Rzf+39hTC55lnkhdQbr+l7EHkTZH8GcTnSf4hkpf9/+uI57NQFT6HTSsC6hMYg3no/FrTF983sH84FJ3xNlroteOfQWNTp+8vL/CZeeX5mgb62A2w6WaDXa/9D/6DeFTafqwBfXtFT4irwacObMnm50/dPPwF4e/grwa0kUsTxiMEnQbcY9ZlsDXwL4iyOIfEB5jvcEgST1L/u/PjkP7vctzaZzkuJZSepknsMaw67jQ0xZe61F2XyvZ5k/ecJq4voXzQ1oZWQRm1Dl1ZH0LtiiVN8pUmy9nQD77bppuTLqWl1O9Ch+9vv9Dfm12COrZqOrXRJv13TX6i00XHyISLNamp3/e6eWWab9xyoYSr1+XeUoWug7ZWFTonhLDPO9M8pOX7cVHwbhn7Yu1VantC61ZtMPWhaiMtX0YXp1wsf7X5p65sW/OslnXpV3XrN803WneXlC0zvj5EZ5sP/6yyXsQQ01rRVdJV/+XWXUZ/rPmp7gf9dNuZoKjOmOOZibqv6fY43fi6bp9pfoXyL1tZ0x5Fy6u+UcVOrm1FZxdOPS7OLi7sFaKaXt+2c/X71qELqbhcD4v8wgRnb6+rr459rqgr3H5T21tmza0r3LOnj/6oWkcmnP6pa7OPvve9dvmqm+PD1HdteyP3e7xsX/mcK7Y26tJV0bXfVI/vOa9bZ3wIbS9nraehKHiH248cn/KxtpX1bV3bQoptnGx+S9ND2xujn6jo+ku3Jvic16oO3djo7CsrnHWdM1dd9UPR/OFQ9rtKl2ZaQ4vaWWe9KGOzSV8dcenPZdvhUny1QZdW1ce4fuhSdGuYb/F1h8IV3/PPlR0+pOya6dofdPuDbt8oug9uis+YvguqjiHnnVDz1KbfR30637f1Y5U+1o2VrVxZMX37qvfcof1XJzFtCKG76plJCJ7fhTq/FJ0hqI/FFtMaGWOv69vjUsrePZTZQ331h8lm07dj1fpCn2Fi3EX09atn2L6Ynsv4AFfUernj4HucbGc8dU0w+aDL+4M6YmtLX0z3I7Ha4Fpn1bufKucck2/YfIhrP3dfci0h5puv9TfUPs21g8bbmvzQZ4tQfhNSiuZ4HVzp4rShTHt9icl2l31YVTqB6Eus81pd/U2xuwyxpYrNPsik1wCoDEZmyDMjCmXFZVtV8d12DqoMizP7zCeh9anyDw==","base64"));

  codePointAt = function(str, idx) {
    var code, hi, low;
    idx = idx || 0;
    code = str.charCodeAt(idx);
    if ((0xD800 <= code && code <= 0xDBFF)) {
      hi = code;
      low = str.charCodeAt(idx + 1);
      if ((0xDC00 <= low && low <= 0xDFFF)) {
        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
      }
      return hi;
    }
    if ((0xDC00 <= code && code <= 0xDFFF)) {
      hi = str.charCodeAt(idx - 1);
      low = code;
      if ((0xD800 <= hi && hi <= 0xDBFF)) {
        return ((hi - 0xD800) * 0x400) + (low - 0xDC00) + 0x10000;
      }
      return low;
    }
    return code;
  };

  shouldBreak = function(previous, current) {
    if (previous === CR && current === LF) {
      return false;
    } else if (previous === Control || previous === CR || previous === LF) {
      return true;
    } else if (current === Control || current === CR || current === LF) {
      return true;
    } else if (previous === L && (current === L || current === V || current === LV || current === LVT)) {
      return false;
    } else if ((previous === LV || previous === V) && (current === V || current === T)) {
      return false;
    } else if ((previous === LVT || previous === T) && current === T) {
      return false;
    } else if (previous === Regional_Indicator && current === Regional_Indicator) {
      return false;
    } else if (current === Extend) {
      return false;
    } else if (current === SpacingMark) {
      return false;
    }
    return true;
  };

  exports.nextBreak = function(string, index) {
    var i, next, prev, _i, _ref1, _ref2, _ref3, _ref4;
    if (index == null) {
      index = 0;
    }
    if (index < 0) {
      return 0;
    }
    if (index >= string.length - 1) {
      return string.length;
    }
    prev = classTrie.get(codePointAt(string, index));
    for (i = _i = _ref1 = index + 1, _ref2 = string.length; _i < _ref2; i = _i += 1) {
      if ((0xd800 <= (_ref3 = string.charCodeAt(i - 1)) && _ref3 <= 0xdbff) && (0xdc00 <= (_ref4 = string.charCodeAt(i)) && _ref4 <= 0xdfff)) {
        continue;
      }
      next = classTrie.get(codePointAt(string, i));
      if (shouldBreak(prev, next)) {
        return i;
      }
      prev = next;
    }
    return string.length;
  };

  exports.previousBreak = function(string, index) {
    var i, next, prev, _i, _ref1, _ref2, _ref3;
    if (index == null) {
      index = string.length;
    }
    if (index > string.length) {
      return string.length;
    }
    if (index <= 1) {
      return 0;
    }
    index--;
    next = classTrie.get(codePointAt(string, index));
    for (i = _i = _ref1 = index - 1; _i >= 0; i = _i += -1) {
      if ((0xd800 <= (_ref2 = string.charCodeAt(i)) && _ref2 <= 0xdbff) && (0xdc00 <= (_ref3 = string.charCodeAt(i + 1)) && _ref3 <= 0xdfff)) {
        continue;
      }
      prev = classTrie.get(codePointAt(string, i));
      if (shouldBreak(prev, next)) {
        return i + 1;
      }
      next = prev;
    }
    return 0;
  };

  exports["break"] = function(str) {
    var brk, index, res;
    res = [];
    index = 0;
    while ((brk = exports.nextBreak(str, index)) < str.length) {
      res.push(str.slice(index, brk));
      index = brk;
    }
    if (index < str.length) {
      res.push(str.slice(index));
    }
    return res;
  };

  exports.countBreaks = function(str) {
    var brk, count, index;
    count = 0;
    index = 0;
    while ((brk = exports.nextBreak(str, index)) < str.length) {
      index = brk;
      count++;
    }
    if (index < str.length) {
      count++;
    }
    return count;
  };

}).call(this);


/***/ }),

/***/ "./node_modules/ify-loader/index.js!./node_modules/linebreak/src/linebreaker.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/ify-loader/index.js!./node_modules/linebreak/src/linebreaker.js ***!
  \**************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

// Generated by CoffeeScript 1.7.1
(function() {
  var AI, AL, BA, BK, CB, CI_BRK, CJ, CP_BRK, CR, DI_BRK, ID, IN_BRK, LF, LineBreaker, NL, NS, PR_BRK, SA, SG, SP, UnicodeTrie, WJ, XX, base64, characterClasses, classTrie, data, fs, pairTable, _ref, _ref1;

  UnicodeTrie = __webpack_require__(/*! unicode-trie */ "./node_modules/unicode-trie/index.js");

  

  base64 = __webpack_require__(/*! base64-js */ "./node_modules/base64-js/lib/b64.js");

  _ref = __webpack_require__(/*! ./classes */ "./node_modules/linebreak/src/classes.js"), BK = _ref.BK, CR = _ref.CR, LF = _ref.LF, NL = _ref.NL, CB = _ref.CB, BA = _ref.BA, SP = _ref.SP, WJ = _ref.WJ, SP = _ref.SP, BK = _ref.BK, LF = _ref.LF, NL = _ref.NL, AI = _ref.AI, AL = _ref.AL, SA = _ref.SA, SG = _ref.SG, XX = _ref.XX, CJ = _ref.CJ, ID = _ref.ID, NS = _ref.NS, characterClasses = _ref.characterClasses;

  _ref1 = __webpack_require__(/*! ./pairs */ "./node_modules/linebreak/src/pairs.js"), DI_BRK = _ref1.DI_BRK, IN_BRK = _ref1.IN_BRK, CI_BRK = _ref1.CI_BRK, CP_BRK = _ref1.CP_BRK, PR_BRK = _ref1.PR_BRK, pairTable = _ref1.pairTable;

  data = base64.toByteArray("AA4IAAAAAAAAAhqg5VV7NJtZvz7fTC8zU5deplUlMrQoWqmqahD5So0aipYWrUhVFSVBQ10iSTtUtW6nKDVF6k7d75eQfEUbFcQ9KiFS90tQEolcP23nrLPmO+esr/+f39rr/a293t/e7/P8nmfvlz0O6RvrBJADtbBNaD88IOKTOmOrCqhu9zE770vc1pBV/xL5dxj2V7Zj4FGSomFKStCWNlV7hG1VabZfZ1LaHbFrRwzzLjzPoi1UHDnlV/lWbhgIIJvLBp/pu7AHEdRnIY+ROdXxg4fNpMdTxVnnm08OjozejAVsBqwqz8kddGRlRxsd8c55dNZoPuex6a7Dt6L0NNb03sqgTlR2/OT7eTt0Y0WnpUXxLsp5SMANc4DsmX4zJUBQvznwexm9tsMH+C9uRYMPOd96ZHB29NZjCIM2nfO7tsmQveX3l2r7ft0N4/SRJ7kO6Y8ZCaeuUQ4gMTZ67cp7TgxvlNDsPgOBdZi2YTam5Q7m3+00l+XG7PrDe6YoPmHgK+yLih7fAR16ZFCeD9WvOVt+gfNW/KT5/M6rb/9KERt+N1lad5RneVjzxXHsLofuU+TvrEsr3+26sVz5WJh6L/svoPK3qepFH9bysDljWtD1F7KrxzW1i9r+e/NLxV/acts7zuo304J9+t3Pd6Y6u8f3EAqxNRgv5DZjaI3unyvkvHPya/v3mWVYOC38qBq11+yHZ2bAyP1HbkV92vdno7r2lxz9UwCdCJVfd14NLcpO2CadHS/XPJ9doXgz5vLv/1OBVS3gX0D9n6LiNIDfpilO9RsLgZ2W/wIy8W/Rh93jfoz4qmRV2xElv6p2lRXQdO6/Cv8f5nGn3u0wLXjhnvClabL1o+7yvIpvLfT/xsKG30y/sTvq30ia9Czxp9dr9v/e7Yn/O0QJXxxBOJmceP/DBFa1q1v6oudn/e6qc/37dUoNvnYL4plQ9OoneYOh/r8fOFm7yl7FETHY9dXd5K2n/qEc53dOEe1TTJcvCfp1dpTC334l0vyaFL6mttNEbFjzO+ZV2mLk0qc3BrxJ4d9gweMmjRorxb7vic0rSq6D4wzAyFWas1TqPE0sLI8XLAryC8tPChaN3ALEZSWmtB34SyZcxXYn/E4Tg0LeMIPhgPKD9zyHGMxxhxnDDih7eI86xECTM8zodUCdgffUmRh4rQ8zyA6ow/Aei+01a8OMfziQQ+GAEkhwN/cqUFYAVzA9ex4n6jgtsiMvXf5BtXxEU4hSphvx3v8+9au8eEekEEpkrkne/zB1M+HAPuXIz3paxKlfe8aDMfGWAX6Md6PuuAdKHFVH++Ed5LEji94Z5zeiJIxbmWeN7rr1/ZcaBl5/nimdHsHgIH/ssyLUXZ4fDQ46HnBb+hQqG8yNiKRrXL/b1IPYDUsu3dFKtRMcjqlRvONd4xBvOufx2cUHuk8pmG1D7PyOQmUmluisVFS9OWS8fPIe8LiCtjwJKnEC9hrS9uKmISI3Wa5+vdXUG9dtyfr7g/oJv2wbzeZU838G6mEvntUb3SVV/fBZ6H/sL+lElzeRrHy2Xbe7UWX1q5sgOQ81rv+2baej4fP4m5Mf/GkoxfDtT3++KP7do9Jn26aa6xAhCf5L9RZVfkWKCcjI1eYbm2plvTEqkDxKC402bGzXCYaGnuALHabBT1dFLuOSB7RorOPEhZah1NjZIgR/UFGfK3p1ElYnevOMBDLURdpIjrI+qZk4sffGbRFiXuEmdFjiAODlQCJvIaB1rW61Ljg3y4eS4LAcSgDxxZQs0DYa15wA032Z+lGUfpoyOrFo3mg1sRQtN/fHHCx3TrM8eTrldMbYisDLXbUDoXMLejSq0fUNuO1muX0gEa8vgyegkqiqqbC3W0S4cC9Kmt8MuS/hFO7Xei3f8rSvIjeveMM7kxjUixOrl6gJshe4JU7PhOHpfrRYvu7yoAZKa3Buyk2J+K5W+nNTz1nhJDhRUfDJLiUXxjxXCJeeaOe/r7HlBP/uURc/5efaZEPxr55Qj39rfTLkugUGyMrwo7HAglfEjDriehF1jXtwJkPoiYkYQ5aoXSA7qbCBGKq5hwtu2VkpI9xVDop/1xrC52eiIvCoPWx4lLl40jm9upvycVPfpaH9/o2D4xKXpeNjE2HPQRS+3RFaYTc4Txw7Dvq5X6JBRwzs9mvoB49BK6b+XgsZVJYiInTlSXZ+62FT18mkFVcPKCJsoF5ahb19WheZLUYsSwdrrVM3aQ2XE6SzU2xHDS6iWkodk5AF6F8WUNmmushi8aVpMPwiIfEiQWo3CApONDRjrhDiVnkaFsaP5rjIJkmsN6V26li5LNM3JxGSyKgomknTyyrhcnwv9Qcqaq5utAh44W30SWo8Q0XHKR0glPF4fWst1FUCnk2woFq3iy9fAbzcjJ8fvSjgKVOfn14RDqyQuIgaGJZuswTywdCFSa89SakMf6fe+9KaQMYQlKxiJBczuPSho4wmBjdA+ag6QUOr2GdpcbSl51Ay6khhBt5UXdrnxc7ZGMxCvz96A4oLocxh2+px+1zkyLacCGrxnPzTRSgrLKpStFpH5ppKWm7PgMKZtwgytKLOjbGCOQLTm+KOowqa1sdut9raj1CZFkZD0jbaKNLpJUarSH5Qknx1YiOxdA5L6d5sfI/unmkSF65Ic/AvtXt98Pnrdwl5vgppQ3dYzWFwknZsy6xh2llmLxpegF8ayLwniknlXRHiF4hzzrgB8jQ4wdIqcaHCEAxyJwCeGkXPBZYSrrGa4vMwZvNN9aK0F4JBOK9mQ8g8EjEbIQVwvfS2D8GuCYsdqwqSWbQrfWdTRUJMqmpnWPax4Z7E137I6brHbvjpPlfNZpF1d7PP7HB/MPHcHVKTMhLO4f3CZcaccZEOiS2DpKiQB5KXDJ+Ospcz4qTRCRxgrKEQIgUkKLTKKwskdx2DWo3bg3PEoB5h2nA24olwfKSR+QR6TAvEDi/0czhUT59RZmO1MGeKGeEfuOSPWfL+XKmhqpZmOVR9mJVNDPKOS49Lq+Um10YsBybzDMtemlPCOJEtE8zaXhsaqEs9bngSJGhlOTTMlCXly9Qv5cRN3PVLK7zoMptutf7ihutrQ/Xj7VqeCdUwleTTKklOI8Wep9h7fCY0kVtDtIWKnubWAvbNZtsRRqOYl802vebPEkZRSZc6wXOfPtpPtN5HI63EUFfsy7U/TLr8NkIzaY3vx4A28x765XZMzRZTpMk81YIMuwJ5+/zoCuZj1wGnaHObxa5rpKZj4WhT670maRw04w0e3cZW74Z0aZe2n05hjZaxm6urenz8Ef5O6Yu1J2aqYAlqsCXs5ZB5o1JJ5l3xkTVr8rJQ09NLsBqRRDT2IIjOPmcJa6xQ1R5yGP9jAsj23xYDTezdyqG8YWZ7vJBIWK56K+iDgcHimiQOTIasNSua1fOBxsKMMEKd15jxTl+3CyvGCR+UyRwuSI2XuwRIPoNNclPihfJhaq2mKkNijwYLY6feqohktukmI3KDvOpN7ItCqHHhNuKlxMfBAEO5LjW2RKh6lE5Hd1dtAOopac/Z4FdsNsjMhXz/ug8JGmbVJTA+VOBJXdrYyJcIn5+OEeoK8kWEWF+wdG8ZtZHKSquWDtDVyhFPkRVqguKFkLkKCz46hcU1SUY9oJ2Sk+dmq0kglqk4kqKT1CV9JDELPjK1WsWGkEXF87g9P98e5ff0mIupm/w6vc3kCeq04X5bgJQlcMFRjlFWmSk+kssXCAVikfeAlMuzpUvCSdXiG+dc6KrIiLxxhbEVuKf7vW7KmDQI95bZe3H9mN3/77F6fZ2Yx/F9yClllj8gXpLWLpd5+v90iOaFa9sd7Pvx0lNa1o1+bkiZ69wCiC2x9UIb6/boBCuNMB/HYR0RC6+FD9Oe5qrgQl6JbXtkaYn0wkdNhROLqyhv6cKvyMj1Fvs2o3OOKoMYTubGENLfY5F6H9d8wX1cnINsvz+wZFQu3zhWVlwJvwBEp69Dqu/ZnkBf3nIfbx4TK7zOVJH5sGJX+IMwkn1vVBn38GbpTg9bJnMcTOb5F6Ci5gOn9Fcy6Qzcu+FL6mYJJ+f2ZZJGda1VqruZ0JRXItp8X0aTjIcJgzdaXlha7q7kV4ebrMsunfsRyRa9qYuryBHA0hc1KVsKdE+oI0ljLmSAyMze8lWmc5/lQ18slyTVC/vADTc+SNM5++gztTBLz4m0aVUKcfgOEExuKVomJ7XQDZuziMDjG6JP9tgR7JXZTeo9RGetW/Xm9/TgPJpTgHACPOGvmy2mDm9fl09WeMm9sQUAXP3Su2uApeCwJVT5iWCXDgmcuTsFgU9Nm6/PusJzSbDQIMfl6INY/OAEvZRN54BSSXUClM51im6Wn9VhVamKJmzOaFJErgJcs0etFZ40LIF3EPkjFTjGmAhsd174NnOwJW8TdJ1Dja+E6Wa6FVS22Haj1DDA474EesoMP5nbspAPJLWJ8rYcP1DwCslhnn+gTFm+sS9wY+U6SogAa9tiwpoxuaFeqm2OK+uozR6SfiLCOPz36LiDlzXr6UWd7BpY6mlrNANkTOeme5EgnnAkQRTGo9T6iYxbUKfGJcI9B+ub2PcyUOgpwXbOf3bHFWtygD7FYbRhb+vkzi87dB0JeXl/vBpBUz93VtqZi7AL7C1VowTF+tGmyurw7DBcktc+UMY0E10Jw4URojf8NdaNpN6E1q4+Oz+4YePtMLy8FPRP");

  classTrie = new UnicodeTrie(data);

  LineBreaker = (function() {
    var Break, mapClass, mapFirst;

    function LineBreaker(string) {
      this.string = string;
      this.pos = 0;
      this.lastPos = 0;
      this.curClass = null;
      this.nextClass = null;
    }

    LineBreaker.prototype.nextCodePoint = function() {
      var code, next;
      code = this.string.charCodeAt(this.pos++);
      next = this.string.charCodeAt(this.pos);
      if ((0xd800 <= code && code <= 0xdbff) && (0xdc00 <= next && next <= 0xdfff)) {
        this.pos++;
        return ((code - 0xd800) * 0x400) + (next - 0xdc00) + 0x10000;
      }
      return code;
    };

    mapClass = function(c) {
      switch (c) {
        case AI:
          return AL;
        case SA:
        case SG:
        case XX:
          return AL;
        case CJ:
          return NS;
        default:
          return c;
      }
    };

    mapFirst = function(c) {
      switch (c) {
        case LF:
        case NL:
          return BK;
        case CB:
          return BA;
        case SP:
          return WJ;
        default:
          return c;
      }
    };

    LineBreaker.prototype.nextCharClass = function(first) {
      if (first == null) {
        first = false;
      }
      return mapClass(classTrie.get(this.nextCodePoint()));
    };

    Break = (function() {
      function Break(position, required) {
        this.position = position;
        this.required = required != null ? required : false;
      }

      return Break;

    })();

    LineBreaker.prototype.nextBreak = function() {
      var cur, lastClass, shouldBreak;
      if (this.curClass == null) {
        this.curClass = mapFirst(this.nextCharClass());
      }
      while (this.pos < this.string.length) {
        this.lastPos = this.pos;
        lastClass = this.nextClass;
        this.nextClass = this.nextCharClass();
        if (this.curClass === BK || (this.curClass === CR && this.nextClass !== LF)) {
          this.curClass = mapFirst(mapClass(this.nextClass));
          return new Break(this.lastPos, true);
        }
        cur = (function() {
          switch (this.nextClass) {
            case SP:
              return this.curClass;
            case BK:
            case LF:
            case NL:
              return BK;
            case CR:
              return CR;
            case CB:
              return BA;
          }
        }).call(this);
        if (cur != null) {
          this.curClass = cur;
          if (this.nextClass === CB) {
            return new Break(this.lastPos);
          }
          continue;
        }
        shouldBreak = false;
        switch (pairTable[this.curClass][this.nextClass]) {
          case DI_BRK:
            shouldBreak = true;
            break;
          case IN_BRK:
            shouldBreak = lastClass === SP;
            break;
          case CI_BRK:
            shouldBreak = lastClass === SP;
            if (!shouldBreak) {
              continue;
            }
            break;
          case CP_BRK:
            if (lastClass !== SP) {
              continue;
            }
        }
        this.curClass = this.nextClass;
        if (shouldBreak) {
          return new Break(this.lastPos);
        }
      }
      if (this.pos >= this.string.length) {
        if (this.lastPos < this.string.length) {
          this.lastPos = this.string.length;
          return new Break(this.string.length);
        } else {
          return null;
        }
      }
    };

    return LineBreaker;

  })();

  module.exports = LineBreaker;

}).call(this);


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.frag":
/*!************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.frag ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = "precision mediump float;\n\n#ifdef DRAW_MODE_silhouette\nuniform vec4 u_silhouetteColor;\n#else // DRAW_MODE_silhouette\n# ifdef ENABLE_color\nuniform float u_color;\n# endif // ENABLE_color\n# ifdef ENABLE_brightness\nuniform float u_brightness;\n# endif // ENABLE_brightness\n#endif // DRAW_MODE_silhouette\n\n#ifdef DRAW_MODE_colorMask\nuniform vec3 u_colorMask;\nuniform float u_colorMaskTolerance;\n#endif // DRAW_MODE_colorMask\n\n#ifdef ENABLE_fisheye\nuniform float u_fisheye;\n#endif // ENABLE_fisheye\n#ifdef ENABLE_whirl\nuniform float u_whirl;\n#endif // ENABLE_whirl\n#ifdef ENABLE_pixelate\nuniform float u_pixelate;\nuniform vec2 u_skinSize;\n#endif // ENABLE_pixelate\n#ifdef ENABLE_mosaic\nuniform float u_mosaic;\n#endif // ENABLE_mosaic\n#ifdef ENABLE_ghost\nuniform float u_ghost;\n#endif // ENABLE_ghost\n\n#ifdef DRAW_MODE_line\nuniform vec4 u_lineColor;\nuniform float u_lineThickness;\nuniform float u_lineLength;\n#endif // DRAW_MODE_line\n\n#ifdef DRAW_MODE_background\nuniform vec4 u_backgroundColor;\n#endif // DRAW_MODE_background\n\nuniform sampler2D u_skin;\n\n#ifndef DRAW_MODE_background\nvarying vec2 v_texCoord;\n#endif\n\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\n// Smaller values can cause problems on some mobile devices.\nconst float epsilon = 1e-3;\n\n#if !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\n// Branchless color conversions based on code from:\n// http://www.chilliant.com/rgb2hsv.html by Ian Taylor\n// Based in part on work by Sam Hocevar and Emil Persson\n// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Formal_derivation\n\n\n// Convert an RGB color to Hue, Saturation, and Value.\n// All components of input and output are expected to be in the [0,1] range.\nvec3 convertRGB2HSV(vec3 rgb)\n{\n\t// Hue calculation has 3 cases, depending on which RGB component is largest, and one of those cases involves a \"mod\"\n\t// operation. In order to avoid that \"mod\" we split the M==R case in two: one for G<B and one for B>G. The B>G case\n\t// will be calculated in the negative and fed through abs() in the hue calculation at the end.\n\t// See also: https://en.wikipedia.org/wiki/HSL_and_HSV#Hue_and_chroma\n\tconst vec4 hueOffsets = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n\n\t// temp1.xy = sort B & G (largest first)\n\t// temp1.z = the hue offset we'll use if it turns out that R is the largest component (M==R)\n\t// temp1.w = the hue offset we'll use if it turns out that R is not the largest component (M==G or M==B)\n\tvec4 temp1 = rgb.b > rgb.g ? vec4(rgb.bg, hueOffsets.wz) : vec4(rgb.gb, hueOffsets.xy);\n\n\t// temp2.x = the largest component of RGB (\"M\" / \"Max\")\n\t// temp2.yw = the smaller components of RGB, ordered for the hue calculation (not necessarily sorted by magnitude!)\n\t// temp2.z = the hue offset we'll use in the hue calculation\n\tvec4 temp2 = rgb.r > temp1.x ? vec4(rgb.r, temp1.yzx) : vec4(temp1.xyw, rgb.r);\n\n\t// m = the smallest component of RGB (\"min\")\n\tfloat m = min(temp2.y, temp2.w);\n\n\t// Chroma = M - m\n\tfloat C = temp2.x - m;\n\n\t// Value = M\n\tfloat V = temp2.x;\n\n\treturn vec3(\n\t\tabs(temp2.z + (temp2.w - temp2.y) / (6.0 * C + epsilon)), // Hue\n\t\tC / (temp2.x + epsilon), // Saturation\n\t\tV); // Value\n}\n\nvec3 convertHue2RGB(float hue)\n{\n\tfloat r = abs(hue * 6.0 - 3.0) - 1.0;\n\tfloat g = 2.0 - abs(hue * 6.0 - 2.0);\n\tfloat b = 2.0 - abs(hue * 6.0 - 4.0);\n\treturn clamp(vec3(r, g, b), 0.0, 1.0);\n}\n\nvec3 convertHSV2RGB(vec3 hsv)\n{\n\tvec3 rgb = convertHue2RGB(hsv.x);\n\tfloat c = hsv.z * hsv.y;\n\treturn rgb * c + hsv.z - c;\n}\n#endif // !defined(DRAW_MODE_silhouette) && (defined(ENABLE_color))\n\nconst vec2 kCenter = vec2(0.5, 0.5);\n\nvoid main()\n{\n\t#if !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\n\tvec2 texcoord0 = v_texCoord;\n\n\t#ifdef ENABLE_mosaic\n\ttexcoord0 = fract(u_mosaic * texcoord0);\n\t#endif // ENABLE_mosaic\n\n\t#ifdef ENABLE_pixelate\n\t{\n\t\t// TODO: clean up \"pixel\" edges\n\t\tvec2 pixelTexelSize = u_skinSize / u_pixelate;\n\t\ttexcoord0 = (floor(texcoord0 * pixelTexelSize) + kCenter) / pixelTexelSize;\n\t}\n\t#endif // ENABLE_pixelate\n\n\t#ifdef ENABLE_whirl\n\t{\n\t\tconst float kRadius = 0.5;\n\t\tvec2 offset = texcoord0 - kCenter;\n\t\tfloat offsetMagnitude = length(offset);\n\t\tfloat whirlFactor = max(1.0 - (offsetMagnitude / kRadius), 0.0);\n\t\tfloat whirlActual = u_whirl * whirlFactor * whirlFactor;\n\t\tfloat sinWhirl = sin(whirlActual);\n\t\tfloat cosWhirl = cos(whirlActual);\n\t\tmat2 rotationMatrix = mat2(\n\t\t\tcosWhirl, -sinWhirl,\n\t\t\tsinWhirl, cosWhirl\n\t\t);\n\n\t\ttexcoord0 = rotationMatrix * offset + kCenter;\n\t}\n\t#endif // ENABLE_whirl\n\n\t#ifdef ENABLE_fisheye\n\t{\n\t\tvec2 vec = (texcoord0 - kCenter) / kCenter;\n\t\tfloat vecLength = length(vec);\n\t\tfloat r = pow(min(vecLength, 1.0), u_fisheye) * max(1.0, vecLength);\n\t\tvec2 unit = vec / vecLength;\n\n\t\ttexcoord0 = kCenter + r * unit * kCenter;\n\t}\n\t#endif // ENABLE_fisheye\n\n\tgl_FragColor = texture2D(u_skin, texcoord0);\n\n\t#if defined(ENABLE_color) || defined(ENABLE_brightness)\n\t// Divide premultiplied alpha values for proper color processing\n\t// Add epsilon to avoid dividing by 0 for fully transparent pixels\n\tgl_FragColor.rgb = clamp(gl_FragColor.rgb / (gl_FragColor.a + epsilon), 0.0, 1.0);\n\n\t#ifdef ENABLE_color\n\t{\n\t\tvec3 hsv = convertRGB2HSV(gl_FragColor.xyz);\n\n\t\t// this code forces grayscale values to be slightly saturated\n\t\t// so that some slight change of hue will be visible\n\t\tconst float minLightness = 0.11 / 2.0;\n\t\tconst float minSaturation = 0.09;\n\t\tif (hsv.z < minLightness) hsv = vec3(0.0, 1.0, minLightness);\n\t\telse if (hsv.y < minSaturation) hsv = vec3(0.0, minSaturation, hsv.z);\n\n\t\thsv.x = mod(hsv.x + u_color, 1.0);\n\t\tif (hsv.x < 0.0) hsv.x += 1.0;\n\n\t\tgl_FragColor.rgb = convertHSV2RGB(hsv);\n\t}\n\t#endif // ENABLE_color\n\n\t#ifdef ENABLE_brightness\n\tgl_FragColor.rgb = clamp(gl_FragColor.rgb + vec3(u_brightness), vec3(0), vec3(1));\n\t#endif // ENABLE_brightness\n\n\t// Re-multiply color values\n\tgl_FragColor.rgb *= gl_FragColor.a + epsilon;\n\n\t#endif // defined(ENABLE_color) || defined(ENABLE_brightness)\n\n\t#ifdef ENABLE_ghost\n\tgl_FragColor *= u_ghost;\n\t#endif // ENABLE_ghost\n\n\t#ifdef DRAW_MODE_silhouette\n\t// Discard fully transparent pixels for stencil test\n\tif (gl_FragColor.a == 0.0) {\n\t\tdiscard;\n\t}\n\t// switch to u_silhouetteColor only AFTER the alpha test\n\tgl_FragColor = u_silhouetteColor;\n\t#else // DRAW_MODE_silhouette\n\n\t#ifdef DRAW_MODE_colorMask\n\tvec3 maskDistance = abs(gl_FragColor.rgb - u_colorMask);\n\tvec3 colorMaskTolerance = vec3(u_colorMaskTolerance, u_colorMaskTolerance, u_colorMaskTolerance);\n\tif (any(greaterThan(maskDistance, colorMaskTolerance)))\n\t{\n\t\tdiscard;\n\t}\n\t#endif // DRAW_MODE_colorMask\n\t#endif // DRAW_MODE_silhouette\n\n\t#ifdef DRAW_MODE_straightAlpha\n\t// Un-premultiply alpha.\n\tgl_FragColor.rgb /= gl_FragColor.a + epsilon;\n\t#endif\n\n\t#endif // !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\n\n\t#ifdef DRAW_MODE_line\n\t// Maaaaagic antialiased-line-with-round-caps shader.\n\n\t// \"along-the-lineness\". This increases parallel to the line.\n\t// It goes from negative before the start point, to 0.5 through the start to the end, then ramps up again\n\t// past the end point.\n\tfloat d = ((v_texCoord.x - clamp(v_texCoord.x, 0.0, u_lineLength)) * 0.5) + 0.5;\n\n\t// Distance from (0.5, 0.5) to (d, the perpendicular coordinate). When we're in the middle of the line,\n\t// d will be 0.5, so the distance will be 0 at points close to the line and will grow at points further from it.\n\t// For the \"caps\", d will ramp down/up, giving us rounding.\n\t// See https://www.youtube.com/watch?v=PMltMdi1Wzg for a rough outline of the technique used to round the lines.\n\tfloat line = distance(vec2(0.5), vec2(d, v_texCoord.y)) * 2.0;\n\t// Expand out the line by its thickness.\n\tline -= ((u_lineThickness - 1.0) * 0.5);\n\t// Because \"distance to the center of the line\" decreases the closer we get to the line, but we want more opacity\n\t// the closer we are to the line, invert it.\n\tgl_FragColor = u_lineColor * clamp(1.0 - line, 0.0, 1.0);\n\t#endif // DRAW_MODE_line\n\n\t#ifdef DRAW_MODE_background\n\tgl_FragColor = u_backgroundColor;\n\t#endif\n}\n"

/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.vert":
/*!************************************************************************************************!*\
  !*** ./node_modules/raw-loader/index.js!./node_modules/scratch-render/src/shaders/sprite.vert ***!
  \************************************************************************************************/
/***/ ((module) => {

module.exports = "precision mediump float;\n\n#ifdef DRAW_MODE_line\nuniform vec2 u_stageSize;\nuniform float u_lineThickness;\nuniform float u_lineLength;\n// The X and Y components of u_penPoints hold the first pen point. The Z and W components hold the difference between\n// the second pen point and the first. This is done because calculating the difference in the shader leads to floating-\n// point error when both points have large-ish coordinates.\nuniform vec4 u_penPoints;\n\n// Add this to divisors to prevent division by 0, which results in NaNs propagating through calculations.\n// Smaller values can cause problems on some mobile devices.\nconst float epsilon = 1e-3;\n#endif\n\n#if !(defined(DRAW_MODE_line) || defined(DRAW_MODE_background))\nuniform mat4 u_projectionMatrix;\nuniform mat4 u_modelMatrix;\nattribute vec2 a_texCoord;\n#endif\n\nattribute vec2 a_position;\n\nvarying vec2 v_texCoord;\n\nvoid main() {\n\t#ifdef DRAW_MODE_line\n\t// Calculate a rotated (\"tight\") bounding box around the two pen points.\n\t// Yes, we're doing this 6 times (once per vertex), but on actual GPU hardware,\n\t// it's still faster than doing it in JS combined with the cost of uniformMatrix4fv.\n\n\t// Expand line bounds by sqrt(2) / 2 each side-- this ensures that all antialiased pixels\n\t// fall within the quad, even at a 45-degree diagonal\n\tvec2 position = a_position;\n\tfloat expandedRadius = (u_lineThickness * 0.5) + 1.4142135623730951;\n\n\t// The X coordinate increases along the length of the line. It's 0 at the center of the origin point\n\t// and is in pixel-space (so at n pixels along the line, its value is n).\n\tv_texCoord.x = mix(0.0, u_lineLength + (expandedRadius * 2.0), a_position.x) - expandedRadius;\n\t// The Y coordinate is perpendicular to the line. It's also in pixel-space.\n\tv_texCoord.y = ((a_position.y - 0.5) * expandedRadius) + 0.5;\n\n\tposition.x *= u_lineLength + (2.0 * expandedRadius);\n\tposition.y *= 2.0 * expandedRadius;\n\n\t// 1. Center around first pen point\n\tposition -= expandedRadius;\n\n\t// 2. Rotate quad to line angle\n\tvec2 pointDiff = u_penPoints.zw;\n\t// Ensure line has a nonzero length so it's rendered properly\n\t// As long as either component is nonzero, the line length will be nonzero\n\t// If the line is zero-length, give it a bit of horizontal length\n\tpointDiff.x = (abs(pointDiff.x) < epsilon && abs(pointDiff.y) < epsilon) ? epsilon : pointDiff.x;\n\t// The `normalized` vector holds rotational values equivalent to sine/cosine\n\t// We're applying the standard rotation matrix formula to the position to rotate the quad to the line angle\n\t// pointDiff can hold large values so we must divide by u_lineLength instead of calling GLSL's normalize function:\n\t// https://asawicki.info/news_1596_watch_out_for_reduced_precision_normalizelength_in_opengl_es\n\tvec2 normalized = pointDiff / max(u_lineLength, epsilon);\n\tposition = mat2(normalized.x, normalized.y, -normalized.y, normalized.x) * position;\n\n\t// 3. Translate quad\n\tposition += u_penPoints.xy;\n\n\t// 4. Apply view transform\n\tposition *= 2.0 / u_stageSize;\n\tgl_Position = vec4(position, 0, 1);\n\t#elif defined(DRAW_MODE_background)\n\tgl_Position = vec4(a_position * 2.0, 0, 1);\n\t#else\n\tgl_Position = u_projectionMatrix * u_modelMatrix * vec4(a_position, 0, 1);\n\tv_texCoord = a_texCoord;\n\t#endif\n}\n"

/***/ }),

/***/ "./node_modules/scratch-audio/src/index.js":
/*!*************************************************!*\
  !*** ./node_modules/scratch-audio/src/index.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/**
 * @fileOverview Scratch Audio is divided into a single AudioEngine, that
 * handles global functionality, and AudioPlayers, belonging to individual
 * sprites and clones.
 */

const AudioEngine = __webpack_require__(/*! ./AudioEngine */ "./node_modules/scratch-audio/src/AudioEngine.js");

module.exports = AudioEngine;


/***/ }),

/***/ "./node_modules/scratch-render/src/index.js":
/*!**************************************************!*\
  !*** ./node_modules/scratch-render/src/index.js ***!
  \**************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

const RenderWebGL = __webpack_require__(/*! ./RenderWebGL */ "./node_modules/scratch-render/src/RenderWebGL.js");

/**
 * Export for NPM & Node.js
 * @type {RenderWebGL}
 */
module.exports = RenderWebGL;


/***/ }),

/***/ "./node_modules/grapheme-breaker/src/classes.json":
/*!********************************************************!*\
  !*** ./node_modules/grapheme-breaker/src/classes.json ***!
  \********************************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"Other":0,"CR":1,"LF":2,"Control":3,"Extend":4,"Regional_Indicator":5,"SpacingMark":6,"L":7,"V":8,"T":9,"LV":10,"LVT":11}');

/***/ })

}]);
//# sourceMappingURL=vendors-node_modules_scratch-audio_src_index-exposed_js-node_modules_scratch-render_src_index-35ce81.b31039d309d42f1fa878.js.map